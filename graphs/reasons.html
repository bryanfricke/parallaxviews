<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Resurrection Hypotheses</title>
  <style>
    :root {
      --bg: #ffffff;
      --ink: #1f2937;
      --muted: #6b7280;
      --line: #e5e7eb;
      --accent: #334155;
      --primary: #0b5fff;
      --primary-600: #084fd6;
      --panel-bg: #ffffff;
      --modal-shadow: 0 20px 60px rgba(0, 0, 0, .2);
      --cell-mid: #9ca3af;
      --cell-high: #374151;
      --control-accent: #111
    }

    html,
    body {
      height: 100%
    }

    /* Reserve scrollbar gutter to avoid layout shifts when scrollbars appear/disappear */
    html {
      scrollbar-gutter: stable;
    }

    body {
      margin: 0;
      font: 14px/1.45 system-ui, -apple-system, Segoe UI, Roboto, Inter, sans-serif;
      color: var(--ink);
      background: var(--bg);
      overflow: hidden
    }

    #topbar {
      position: sticky;
      top: 0;
      z-index: 10;
      background: var(--bg);
      border-bottom: 1px solid var(--line);
      padding: 10px 14px;
      display: flex;
      align-items: flex-start;
      flex-wrap: nowrap;
      flex-direction: column;
      gap: 0
    }

    #topbar h1 {
      font-size: 16px;
      margin: 0 12px 0 0;
      font-weight: 600;
      color: var(--accent)
    }

    .topbar-primary {
      display: flex;
      align-items: center;
      width: 100%;
      min-height: 56px
    }

    #controlsToggle {
      display: none;
      margin-left: auto
    }

    #controls-panel {
      display: flex;
      gap: 16px;
      align-items: center;
      flex-wrap: wrap;
      width: 100%;
      padding: 6px 0 4px 0
    }

    /* Mobile layout: collapse panel without moving primary row */
    @media (max-width:768px) {
      #topbar {
        padding: 10px 14px 6px 14px
      }

      #controlsToggle {
        display: inline-flex;
        align-items: center;
        gap: 4px;
        font-weight: 500
      }

      #topbar[data-state='collapsed'] #controls-panel {
        display: none
      }

      #hypotheses {
        height: 40px;
        line-height: 40px;
        padding: 4px 6px 0 6px
      }

      .pill {
        padding: 4px 8px;
        font-size: 13px
      }

      #chart {
        height: calc(var(--vh, 1vh) * 100 - var(--header-h, 60px));
      }
    }

    /* Desktop: row layout with hypothesis pills on separate line */
    @media (min-width:769px) {
      #topbar {
        flex-direction: column;
        align-items: flex-start;
        gap: 8px;
        padding: 10px 14px;
      }

      .topbar-primary {
        width: 100%;
        min-height: auto
      }

      #controls-panel {
        padding: 0;
        width: 100%;
        justify-content: flex-start;
      }

      #hypotheses {
        width: 100%;
        justify-content: flex-start;
        margin-left: 0;
      }

      #controlsToggle {
        display: none
      }
    }

    #loaders {
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap
    }

    /* base button */
    button,
    .btn {
      border: 1px solid var(--line);
      background: var(--panel-bg);
      padding: 6px 10px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 14px
    }

    input[type="text"] {
      border: 1px solid var(--line);
      border-radius: 8px;
      padding: 6px 10px;
      min-width: 280px
    }

    #hypotheses {
      display: flex;
      gap: 10px;
      /* keep legend on a single row and center it in the topbar */
      flex-wrap: nowrap;
      margin-left: 0;
      flex: 1 1 auto;
      justify-content: center;
      /* fixed-height single-line scroller so it cannot grow and push the chart down */
      height: 44px;
      line-height: 44px;
      overflow-x: auto;
      overflow-y: hidden;
      -webkit-overflow-scrolling: touch;
      padding: 6px 8px 12px 8px;
    }

    .pill {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      border: 1px solid var(--line);
      padding: 6px 10px;
      border-radius: 999px;
      flex: 0 0 auto
    }

    /* prevent pill contents from wrapping and increasing vertical size */
    .pill {
      white-space: nowrap
    }

    /* Prevent the horizontal scroller from showing a large scrollbar in most browsers while keeping it usable on touch devices */
    #hypotheses::-webkit-scrollbar {
      height: 8px
    }

    #hypotheses::-webkit-scrollbar-thumb {
      background: rgba(0, 0, 0, 0.12);
      border-radius: 6px
    }

    @media (max-width:520px) {

      /* Slightly reduce pill padding on small screens so more fit before scrolling */
      .pill {
        padding: 6px 8px;
        font-size: 13px
      }
    }

    .pill .sw {
      width: 12px;
      height: 12px;
      border-radius: 3px
    }

    /* High-contrast custom checkbox for hypothesis pills */
    .pill input[type="checkbox"] {
      -webkit-appearance: none;
      appearance: none;
      width: 18px;
      height: 18px;
      border-radius: 6px;
      border: 2px solid var(--line);
      background: transparent;
      display: inline-block;
      vertical-align: middle;
      transition: background-color .15s ease, border-color .15s ease, box-shadow .15s ease;
    }

    .pill input[type="checkbox"]:focus-visible {
      outline: 2px solid var(--primary);
      outline-offset: 2px;
    }

    .pill input[type="checkbox"]:checked {
      background-color: var(--control-accent);
      border-color: var(--control-accent);
      /* white check glyph for maximum contrast */
      background-image: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16' fill='none' stroke='white' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><polyline points='3.5,8.5 6.5,11.5 12.5,4.5'/></svg>");
      background-repeat: no-repeat;
      background-position: center;
      background-size: 12px 12px;
    }

    /* Unchecked state should still be visible in dark mode */
    :root[data-theme="dark"] .pill input[type="checkbox"] {
      border-color: rgba(255, 255, 255, 0.45);
      background-color: rgba(255, 255, 255, 0.06);
      box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.2) inset;
    }

    :root[data-theme="dark"] .pill input[type="checkbox"]:checked {
      /* Option A: maximum contrast — white box with dark check */
      background-color: #ffffff;
      border-color: #ffffff;
      box-shadow: none;
      background-image: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16' fill='none' stroke='%230f1724' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><polyline points='3.5,8.5 6.5,11.5 12.5,4.5'/></svg>");
      background-repeat: no-repeat;
      background-position: center;
      background-size: 12px 12px;
    }

    .viewtabs {
      display: flex;
      gap: 6px
    }

    .viewtabs button.active {
      background: var(--control-accent);
      color: var(--panel-bg)
    }

    #main {
      display: grid;
      grid-template-rows: auto 1fr auto;
      gap: 10px
    }

    /* Chart area: restrict touch gestures here only so D3 can manage them; leave page zoom accessible elsewhere */
    #chart {
      width: 100%;
      height: calc(var(--vh, 1vh) * 100 - var(--header-h, 92px));
      min-height: 380px;
      padding-top: 14px;
      box-sizing: border-box;
      touch-action: none;
      overscroll-behavior: contain
    }

    #chart svg {
      display: block;
      width: 100%;
      height: 100%;
      touch-action: none;
      /* allow soft glows and ring strokes to extend beyond the viewport without being clipped */
      overflow: visible;
    }

    /* Add a touch of side padding on very small screens so the chart doesn't hug the edges */
    @media (max-width:520px) {
      #chart {
        padding-left: 10px;
        padding-right: 10px;
      }
    }

    /* Prevent the browser from handling pinch/zoom inside the chart area so D3 can manage gestures.
  iOS sometimes ignores touch-action, so we also add an explicit touchstart listener in JS below. */
    #chart svg {
      touch-action: none;
      -webkit-user-select: none;
      user-select: none;
      -ms-touch-action: none;
      -webkit-tap-highlight-color: transparent;
    }

    /* Keep strokes visually constant while zooming the chart. Target common axis/path elements and
  the vertex outer rings; filled shapes (dots) will still scale unless adjusted in JS. */
    #chart svg path,
    #chart svg line,
    #chart svg polygon,
    #chart svg .vertex-ring,
    #chart svg .axis-dot {
      vector-effect: non-scaling-stroke;
    }
    /* Keyboard focus indicator for vertices */
    #chart svg .vertices .vertex:focus-visible .vertex-ring {
      stroke-width: 3 !important;
    }

    /* Remove default browser focus outline box on SVG elements (Chrome) and use our custom ring instead */
    #chart svg .vertices .vertex:focus,
    #chart svg .vertices .vertex:focus-visible,
    #chart svg .axis-hit:focus,
    #chart svg .axis-hit:focus-visible {
      outline: none;
    }

    /* Keyboard focus indicator for criteria */
    #chart svg .axis-hit:focus-visible {
      stroke: var(--primary) !important;
      stroke-width: 3 !important;
      fill: rgba(11, 95, 255, 0.1) !important;
    }

    .help,
    #controlsToggle,
    #themeToggle {
      font-size: 14px;
      color: var(--primary);
      border: 2px solid var(--primary);
      background: transparent;
      padding: 6px 10px;
      border-radius: 8px;
      cursor: pointer;
      box-shadow: none;
      transition: background .12s ease, color .12s ease, transform .12s ease;
    }

    .help {
      margin-left: 8px;
      padding: 8px 12px;
      border-radius: 12px;
      font-weight: 600;
    }

    .legend {
      display: none
    }

    .tooltip {
      position: fixed;
      pointer-events: auto;
      z-index: 9999;
      background: var(--panel-bg);
      border: 1px solid var(--line);
      padding: 8px 10px;
      border-radius: 8px;
      box-shadow: 0 6px 20px rgba(0, 0, 0, .12);
      max-width: 360px;
      font-size: 12px;
      contain: paint;
      will-change: transform;
      max-height: calc(100vh - 96px);
      overflow: auto
    }

    .tooltip .q {
      margin-top: 6px;
      font-style: italic
    }

    .tooltip .src {
      color: var(--muted)
    }

    /* Pager buttons inside the tooltip (left/right) - ensure visibility in dark mode */
    .tooltip button {
      background: transparent;
      border: 1px solid var(--line);
      color: var(--ink);
      width: 36px;
      height: 36px;
      border-radius: 8px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      line-height: 1
    }

    .tooltip button:focus {
      outline: 3px solid rgba(0, 0, 0, 0.08);
      outline-offset: 2px
    }

    /* Pinned tooltip state (desktop only): colored outline matching hypothesis and draggable cursor */
    .tooltip.pinned {
      border-color: var(--tooltip-pinned-color, var(--primary));
      border-width: 2px;
      box-shadow: var(--tooltip-pinned-shadow, 0 12px 36px rgba(11, 95, 255, 0.12));
      cursor: move;
    }

    .tooltip.pinned:focus {
      outline: 2px solid var(--tooltip-pinned-color, var(--primary));
      outline-offset: 2px;
    }

    /* When tooltip is pinned, block pointer interaction with the chart until user clicks the chart.
  This transparent blocker sits above the chart and below the tooltip. */
    .tt-blocker {
      position: fixed;
      background: transparent;
      z-index: 9998;
      pointer-events: auto;
    }

    .modalOverlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, .35);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 9998
    }

    .modal {
      background: var(--panel-bg);
      border: 1px solid var(--line);
      border-radius: 12px;
      padding: 16px 18px;
      width: min(720px, calc(100% - 40px));
      max-height: 80vh;
      overflow: auto;
      box-shadow: var(--modal-shadow)
    }

    .modalHeader {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      margin-bottom: 8px
    }

    .modalHeader h2 {
      font-size: 16px;
      margin: 0
    }

    .modalHeader button {
      border: 1px solid var(--line);
      background: var(--panel-bg);
      border-radius: 8px;
      padding: 4px 8px;
      cursor: pointer
    }

    .modalBody p {
      margin: 8px 0
    }

    #drop {
      border: 1px dashed var(--line);
      border-radius: 10px;
      padding: 8px 10px
    }

    .small {
      font-size: 12px;
      color: var(--muted)
    }

    /* Prominent action styles for Help / Facts buttons */
    .btn.primary {
      background: var(--primary);
      border-color: var(--primary);
      color: #fff;
      padding: 10px 14px;
      border-radius: 12px;
      font-weight: 600;
      box-shadow: 0 8px 20px rgba(11, 95, 255, 0.14);
      transition: transform .12s ease, box-shadow .12s ease, background-color .12s ease
    }

    .btn.primary:hover {
      background: var(--primary-600);
      transform: translateY(-1px);
      box-shadow: 0 12px 30px rgba(11, 79, 255, 0.18)
    }

    .btn.primary:active {
      transform: translateY(0);
      box-shadow: 0 6px 14px rgba(11, 79, 255, 0.12)
    }

    #themeToggle {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      min-width: 40px;
      padding: 8px 10px;
    }

    #themeToggle svg {
      display: block;
    }

    .help:hover,
    #controlsToggle:hover,
    #themeToggle:hover {
      background: var(--primary);
      color: #fff;
      transform: translateY(-1px);
      box-shadow: 0 10px 28px rgba(11, 95, 255, 0.10)
    }

    .help:active,
    #controlsToggle:active,
    #themeToggle:active {
      transform: translateY(0)
    }

    .help:focus,
    #controlsToggle:focus,
    #themeToggle:focus,
    .btn.primary:focus {
      outline: 3px solid rgba(11, 95, 255, 0.16);
      outline-offset: 2px
    }

    /* Slightly larger click targets for accessibility */
    button,
    .btn,
    #helpBtn {
      min-height: 40px
    }

    /* smooth color transitions when switching themes */
    body,
    #topbar,
    .modal,
    .tooltip,
    button,
    .btn,
    .pill {
      transition: background-color .18s ease, color .18s ease, border-color .18s ease, box-shadow .18s ease;
    }

    /* Theme toggle icon visibility */
    #icon-moon {
      display: inline-block;
      vertical-align: middle
    }

    #icon-sun {
      display: none;
      vertical-align: middle
    }

    :root[data-theme="dark"] #icon-moon {
      display: none
    }

    :root[data-theme="dark"] #icon-sun {
      display: inline-block
    }

    /* Dark-theme overrides */
    :root[data-theme="dark"] {
      --bg: #071022;
      --ink: #e6eef8;
      /* brighter muted color so labels are legible on dark backgrounds */
      --muted: #cbd6e1;
      /* stronger grid/axis stroke for contrast in dark mode */
      --line: rgba(255, 255, 255, 0.14);
      --accent: #93c5fd;
      --primary: #3b82f6;
      --primary-600: #2563eb;
      --panel-bg: #0f1724;
      --modal-shadow: 0 20px 60px rgba(0, 0, 0, .6);
      --cell-mid: #7b8794;
      --cell-high: #a3b0c0;
      /* Use a brighter accent for checkboxes/toggles to ensure sufficient contrast on dark backgrounds */
      --control-accent: #9ec6ff;
    }

    /* Make links inside floating UI readable; use primary color by default and a lighter tint in dark mode */
    .tooltip a,
    .modal a,
    .mobile-bottom-sheet a {
      color: var(--primary);
      text-decoration: underline;
    }

    /* Ensure visited links don't fall back to low-contrast purple */
    .tooltip a:visited,
    .modal a:visited,
    .mobile-bottom-sheet a:visited {
      color: var(--primary);
    }

    /* Stronger contrast for dark mode links across tooltip, modal, and bottom sheet */
    :root[data-theme="dark"] .tooltip a,
    :root[data-theme="dark"] .modal a,
    :root[data-theme="dark"] .mobile-bottom-sheet a {
      color: #9ec6ff;
    }

    :root[data-theme="dark"] .tooltip a:visited,
    :root[data-theme="dark"] .modal a:visited,
    :root[data-theme="dark"] .mobile-bottom-sheet a:visited {
      color: #9ec6ff;
    }

    /* Clear focus ring for keyboard users */
    .tooltip a:focus-visible,
    .modal a:focus-visible,
    .mobile-bottom-sheet a:focus-visible {
      outline: 2px solid currentColor;
      outline-offset: 2px;
      border-radius: 4px;
    }

    /* Header/title color adjustments for dark mode:
  - Keep the non-link title text high-contrast (var(--ink)).
  - Make the linked part of the title use the lighter tint used for tooltip links so the link stands out. */
    :root[data-theme="dark"] #topbar h1 {
      color: var(--ink);
    }

    :root[data-theme="dark"] #topbar h1 a,
    :root[data-theme="dark"] #topbar h1 a:visited {
      color: #9ec6ff;
      text-decoration: underline;
    }

    /* Improve visibility of modal close buttons in dark mode */
    :root[data-theme="dark"] .modalHeader button {
      background: rgba(255, 255, 255, 0.1);
      border-color: rgba(255, 255, 255, 0.2);
      color: var(--ink);
    }

    :root[data-theme="dark"] .modalHeader button:hover {
      background: rgba(255, 255, 255, 0.15);
      border-color: rgba(255, 255, 255, 0.3);
    }

    /* Dark-mode: ensure keyboard focus rings are visible (use brighter accent) */
    :root[data-theme="dark"] .help:focus,
    :root[data-theme="dark"] #controlsToggle:focus,
    :root[data-theme="dark"] #themeToggle:focus,
    :root[data-theme="dark"] .btn.primary:focus,
    :root[data-theme="dark"] .btn:focus,
    :root[data-theme="dark"] button:focus,
    :root[data-theme="dark"] .help:focus-visible,
    :root[data-theme="dark"] #controlsToggle:focus-visible,
    :root[data-theme="dark"] #themeToggle:focus-visible,
    :root[data-theme="dark"] .btn.primary:focus-visible,
    :root[data-theme="dark"] .btn:focus-visible,
    :root[data-theme="dark"] button:focus-visible {
      /* Use the control accent (light tint) with slightly stronger alpha for contrast */
      outline: 3px solid rgba(158,198,255,0.22);
      outline-offset: 2px;
    }

    /* Tooltip and bottom-sheet controls can have separate, slightly smaller rings */
    :root[data-theme="dark"] .tooltip button:focus,
    :root[data-theme="dark"] .mobile-bottom-sheet .close-btn:focus,
    :root[data-theme="dark"] .mobile-bottom-sheet .pager button:focus {
      outline: 2px solid rgba(158,198,255,0.18);
      outline-offset: 2px;
      border-radius: 6px;
    }

    /* Extra specific rule to override external stylesheet focus-visible for buttons in dark mode */
    body[data-theme="dark"] .btn:focus-visible,
    body[data-theme="dark"] button:focus-visible {
      outline: 3px solid rgba(158,198,255,0.22) !important;
      outline-offset: 2px !important;
    }

    /* Make chart axis labels and grid lines use the theme variables so they remain visible in dark mode.
  IMPORTANT: avoid overriding vertex marker strokes (they live inside the .vertices group). */
    :root[data-theme="dark"] #chart svg text {
      fill: var(--muted);
      font-size: 12px;
    }

    :root[data-theme="dark"] #chart svg line {
      stroke: var(--line);
    }

    /* Target only circles that are not inside the .vertices group (grid/axis dots) */
    :root[data-theme="dark"] #chart svg g:not(.vertices) circle {
      stroke: var(--line);
    }

    :root[data-theme="dark"] #chart svg path {
      stroke-opacity: 0.9;
    }

    /* (Pin functionality removed; legacy pinned styles deleted) */

    /* Mobile bottom-sheet style for tooltips (shown only on touch / small screens) */
    .mobile-bottom-sheet {
      position: fixed;
      left: 0;
      right: 0;
      bottom: -100%;
      background: var(--panel-bg);
      color: var(--ink);
      border-top-left-radius: 16px;
      border-top-right-radius: 16px;
      box-shadow: 0 -8px 28px rgba(0, 0, 0, 0.28);
      border: 1px solid var(--line);
      padding: 18px 20px 26px 20px;
      z-index: 11000;
      max-height: 65vh;
      overflow: auto;
      transition: bottom .28s ease;
      -webkit-overflow-scrolling: touch;
      font-size: 13px;
      line-height: 1.45
    }

    .mobile-bottom-sheet.open {
      bottom: 0
    }

    .mobile-bottom-sheet h3 {
      margin: 0 0 6px 0;
      font-size: 15px;
      font-weight: 600
    }

    .mobile-bottom-sheet .sheet-meta {
      font-size: 12px;
      color: var(--muted);
      margin-bottom: 6px
    }

    .mobile-bottom-sheet .close-btn {
      position: absolute;
      top: 10px;
      right: 10px;
      width: 34px;
      height: 34px;
      border-radius: 999px;
      border: 1px solid var(--line);
      background: rgba(0, 0, 0, 0.04);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      line-height: 0;
      color: inherit
    }

    .mobile-bottom-sheet .close-btn:focus {
      outline: 2px solid rgba(0, 0, 0, 0.2);
      outline-offset: 2px
    }

    :root[data-theme="dark"] .mobile-bottom-sheet .close-btn {
      background: rgba(255, 255, 255, 0.06)
    }

    /* Pager controls (top-left) for overlapping vertices on mobile */
    .mobile-bottom-sheet .pager {
      position: static;
      display: flex;
      gap: 8px;
      margin-left: auto;
      z-index: 2
    }

    .mobile-bottom-sheet .pager button {
      width: 34px;
      height: 34px;
      border-radius: 999px;
      border: 1px solid var(--line);
      background: var(--panel-bg);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      cursor: pointer;
      padding: 0;
      line-height: 0;
      color: var(--ink)
    }

    .mobile-bottom-sheet .pager button:focus {
      outline: 2px solid rgba(0, 0, 0, 0.25);
      outline-offset: 2px
    }

    :root[data-theme="dark"] .mobile-bottom-sheet .pager button {
      background: rgba(255, 255, 255, 0.06)
    }

    /* Ensure content doesn't sit underneath absolute pager row */
    .mobile-bottom-sheet .with-pager {
      padding-top: 0;
    }

    /* Pager row now flows in normal document flow (not absolute) */
    .mobile-bottom-sheet .pager-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      margin: 4px 0 8px 0;
      padding-right: 60px;
    }

    .mobile-bottom-sheet .pager-info {
      font-size: 13px;
      font-weight: 600;
      white-space: nowrap;
    }

    :root[data-theme="dark"] .mobile-bottom-sheet .pager-info {
      color: var(--ink)
    }

    /* Inline header with its own close to align with pager */
    .mobile-bottom-sheet.has-inline-close>.close-btn {
      display: none;
    }

    .mobile-bottom-sheet .hdr {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      margin: 2px 0 8px 0;
    }

    .mobile-bottom-sheet .hdr-left {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .mobile-bottom-sheet .hdr .hdr-close {
      width: 34px;
      height: 34px;
      border-radius: 999px;
      border: 1px solid var(--line);
      background: var(--panel-bg);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      line-height: 0;
      color: inherit;
      cursor: pointer;
    }

    :root[data-theme="dark"] .mobile-bottom-sheet .hdr .hdr-close {
      background: rgba(255, 255, 255, 0.06)
    }

    /* Add a divider before quotes in the mobile sheet to match desktop affordance */
    .mobile-bottom-sheet .q {
      border-top: 1px solid var(--line);
      padding-top: 8px;
      margin-top: 10px;
    }

    :root[data-theme="dark"] .mobile-bottom-sheet {
      box-shadow: 0 -8px 34px rgba(0, 0, 0, 0.6)
    }

    :root[data-theme="dark"] .mobile-bottom-sheet .close-btn {
      background: rgba(255, 255, 255, 0.06)
    }
    /* Visually hidden utility for focus management */
    .sr-only {
      position: absolute !important;
      width: 1px; height: 1px;
      padding: 0; margin: -1px;
      overflow: hidden; clip: rect(0, 0, 0, 0);
      white-space: nowrap; border: 0;
    }
  </style>
</head>

<body>
  <!-- Focus sentinel: ensures first Tab lands on top controls -->
  <a id="focusSentinel" class="sr-only" href="#" aria-hidden="true" tabindex="-1">Start</a>
  <div id="topbar" data-state="collapsed">
    <div class="topbar-primary">
      <h1>Resurrection Hypotheses</h1>
      <button id="controlsToggle" tabindex="1" aria-expanded="false" aria-controls="controls-panel"
        aria-label="Show controls">Controls ▼</button>
    </div>
    <div id="controls-panel">
      <button id="factsBtn" class="btn primary" tabindex="2" aria-expanded="false" aria-controls="factsOverlay">Facts</button>
      <button id="dimsBtn" class="btn primary" tabindex="3" aria-expanded="false" aria-haspopup="dialog" aria-controls="dimsOverlay"
        title="About the seven dimensions">Criteria</button>
      <button id="helpBtn" role="button" tabindex="4" aria-haspopup="dialog" aria-controls="helpOverlay" class="help">? Help</button>
      <button id="themeToggle" tabindex="5" aria-pressed="false" title="Toggle dark mode" style="margin-left:8px">
        <span id="icon-moon" aria-hidden="true"><svg width="16" height="16" viewBox="0 0 24 24" fill="none"
            stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
            <path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"></path>
          </svg></span>
        <span id="icon-sun" aria-hidden="true"><svg width="16" height="16" viewBox="0 0 24 24" fill="none"
            stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
            <circle cx="12" cy="12" r="4"></circle>
            <path
              d="M12 2v2M12 20v2M4.93 4.93l1.41 1.41M17.66 17.66l1.41 1.41M2 12h2M20 12h2M4.93 19.07l1.41-1.41M17.66 6.34l1.41-1.41" />
          </svg></span>
      </button>
      <div id="loaders"></div>
      <div id="hypotheses"></div>
    </div>
  </div>

  <div id="main">
    <div id="chart" aria-live="polite">
      <div id="loader" class="small">Loading data from <code>data/resurrection-data.json</code>…</div>
    </div>
    <!-- Facts modal overlay (opened by Facts button) -->
    <div id="factsOverlay" class="modalOverlay" role="dialog" aria-modal="true" aria-labelledby="factsTitle"
      style="display:none">
      <div class="modal">
        <div class="modalHeader">
          <h2 id="factsTitle">Key facts and supporting reasons</h2>
          <button id="factsClose" aria-label="Close facts">×</button>
        </div>
        <div class="modalBody">
          <p><strong>Source</strong>: <a href="https://www.reasonablefaith.org/" target="_blank"
              rel="noopener">reasonablefaith.org</a></p>

          <h4>Burial of Jesus by Joseph of Arimathea</h4>
          <p>After the crucifixion, Jesus was buried in a tomb by Joseph of Arimathea.</p>
          <ul>
            <li>Paul’s early tradition (1 Corinthians 15:3-5) mentions that Jesus “was buried.”</li>
            <li>The burial account is part of the early source material used by Mark.</li>
            <li>Joseph of Arimathea was on the Jewish council that condemned Jesus, so inventing him as someone who
              gives Jesus a proper burial would be unlikely.</li>
            <li>There is no competing burial story.</li>
          </ul>

          <h4>The Empty Tomb</h4>
          <p>On the Sunday following the Crucifixion, the tomb of Jesus was found empty by a group of women followers.
          </p>
          <ul>
            <li>The empty tomb story is part of the old passion tradition in Mark.</li>
            <li>Paul’s tradition implies a vacant tomb (buried then raised).</li>
            <li>The story is relatively simple and lacks legendary embellishment compared to apocryphal stories.</li>
            <li>Women as the discoverers is significant, because women’s testimony was less valued in that culture — a
              detail harder to invent.</li>
            <li>Early opponents of Christianity admitted the tomb was empty and claimed disciples stole the body.</li>
          </ul>

          <h4>Post-Mortem Appearances</h4>
          <p>On multiple occasions, different individuals and groups experienced appearances of Jesus alive after his
            death.</p>
          <ul>
            <li>Paul’s list of witnesses in 1 Corinthians 15 mentions appearances to Peter, the Twelve, 500 brethren,
              James, etc.</li>
            <li>Gospel tradition gives multiple, independent attestations of appearances.</li>
            <li>The transformation of people who had been skeptical (e.g. Jesus’ family—James) after having seen him.
            </li>
          </ul>

          <h4>The Origin of the Disciples’ Belief in the Resurrection</h4>
          <p>The original disciples came to believe that Jesus rose from the dead, even though they had strong reasons
            to the contrary.</p>
          <ul>
            <li>Their leader was dead; Jewish expectations did not include a suffering Messiah who dies.</li>
            <li>The crucifixion made them look like they were following a heretic.</li>
            <li>Jewish belief in resurrection was of a future general resurrection, not an individual resurrection to
              glory before the end of the world.</li>
          </ul>
          <p>Yet, despite these strong obstacles, they were willing to suffer (and in some cases die) for their belief.
          </p>
        </div>
      </div>
    </div>
  </div>

  <!-- Help Modal -->
  <div id="helpOverlay" class="modalOverlay" role="dialog" aria-modal="true" aria-labelledby="helpTitle">
    <div class="modal">
      <div class="modalHeader">
        <h2 id="helpTitle">How to read this chart</h2>
        <button id="helpClose" aria-label="Close help">×</button>
      </div>
      <div class="modalBody">
        <p><strong>Purpose</strong><br>Compare hypotheses using seven historiographic criteria inspired by McCullagh’s
          formulation. This chart displays assessments as discrete ordinal bands rather than precise numeric estimates
          so that comparisons emphasize consistent, repeatable judgments (rankings and band membership) over
          fine-grained decimals.</p>
        <p><strong>Rings & levels</strong><br>The three rings represent the midpoints of the discrete bands used here:
          Low (0.25), Medium (0.50), High (0.75). Individual raw scores are snapped to the nearest band midpoint for
          display. This is an explicit design choice to surface ordinal differences; other reasonable segmentation
          schemes (e.g., quartiles, custom thresholds, or continuous scoring) could be used instead depending on your
          methodology.</p>
        <p><strong>Axes</strong> (each shows its anchors): 1. Observable Implications; 2. Scope; 3. Power; 4.
          Plausibility; 5. Fewer assumptions; 6. Fewer conflicts; 7. Overall vs. rivals. Each axis has human-readable
          anchors that explain what Low/Medium/High mean in that dimension; see the <em>Dimensions</em> dialog for the
          full text.</p>
        <p><strong>Colors</strong><br>Colors distinguish hypotheses (not the numeric magnitude of scores). The radar
          uses colored outlines and filled polygons for visual grouping.</p>
        <p><strong>Tooltips</strong><br>
          Desktop: Hover a dot (vertex) to see band, any short note, and an optional source quote (closes when you move
          away or press Esc).<br>
          Mobile: Tap a vertex to open a bottom sheet with the same details; swipe down or tap × to dismiss. When
          multiple hypotheses share a vertex, use the left/right pager controls (or swipe) to cycle through them.</p>
        <p class="small" style="margin-top:8px;color:var(--muted)">Note for advanced users: the snapping behavior, band
          anchors, and the underlying numeric assessments are driven by the JSON data in
          <code>graphs/data/resurrection-data.json</code>. If you prefer a different segmentation (for example,
          quartiles or a continuous scale), adjust the data or the quantization function in the script.</p>
      </div>
    </div>
  </div>

  <!-- Dimensions Modal -->
  <div id="dimsOverlay" class="modalOverlay" role="dialog" aria-modal="true" aria-labelledby="dimsTitle"
    style="display:none">
    <div class="modal">
      <div class="modalHeader">
        <h2 id="dimsTitle">The seven dimensions (framework consistency)</h2>
        <button id="dimsClose" aria-label="Close dimensions">×</button>
      </div>
      <div class="modalBody">
        <p>This visualization uses C. Behan McCullagh’s seven criteria (as applied by comparative historians) to assess
          hypotheses about historical events. The seven dimensions are used consistently as ordinal bands (Low · Medium
          · High) across hypotheses so relative strengths and trade-offs are comparable.</p>
        <ol>
          <li><strong>Observable Implications</strong> — How directly does the hypothesis produce observable
            consequences in the primary material?</li>
          <li><strong>Scope</strong> — How wide an explanatory reach does the hypothesis have?</li>
          <li><strong>Power</strong> — How well does it account for the specific facts under consideration?</li>
          <li><strong>Plausibility</strong> — Consistency with background knowledge and auxiliary hypotheses.</li>
          <li><strong>Fewer assumptions</strong> — Simplicity and fewer ad-hoc auxiliaries.</li>
          <li><strong>Fewer conflicts</strong> — Compatibility with other accepted facts.</li>
          <li><strong>Overall vs. rivals</strong> — Comparative explanatory superiority.</li>
        </ol>
        <p>The chart snaps scores to three ordinal bands so comparisons emphasize consistent, repeatable judgments
          rather than fine-grained numeric precision.</p>
      </div>
    </div>
  </div>

  <!-- Tooltip -->
  <div id="tt" class="tooltip" style="display:none" role="dialog" aria-modal="false" aria-live="polite"></div>
  <!-- Mobile bottom-sheet container for tooltip content -->
  <div id="ttSheet" class="mobile-bottom-sheet" aria-hidden="true" role="dialog" aria-modal="false">
    <button class="close-btn" aria-label="Close" type="button">×</button>
    <div class="sheet-inner"></div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
  <script>
    let Data = null; // loaded JSON
    const state = {
      view: 'radar',
      selected: new Set(),
      showQuotes: true,
      applyWeights: false,
      showAxisTicks: true,
      // pin feature removed
      pagerActive: null,
      lastActiveHypothesis: null,
      _highlightClearTimer: null,
      // suppress brief late hides immediately after pin to avoid first-click race
      _suppressHideUntil: 0
    };
  // Selected vertex visual scales
  const SELECTED_DOT_SCALE = 1.35;  // how much bigger than baseline the inner dot gets
  const SELECTED_RING_SCALE = 1.6;  // how much bigger than baseline the outer ring gets (kept > dot so white outline shows)
  // Axis-end selection scale
  const AXIS_SELECTED_SCALE = 1.5;
    // Track currently active vertex (hypothesis + criterion) for precise highlighting
    state.activeVertex = null;
    // current zoom scale applied to chart (1 == identity). Updated by zoom handler.
    state.zoomK = 1;
    // flags to track pointer location for auto-hide logic
    state.isOverChart = false;
    state.isOverTT = false;
  // Persist selection while the mobile bottom sheet is open to avoid a mid-zoom "third state"
  state.sheetActiveVertex = null;
  // Track active axis id to visually emphasize axis-end marker when its info is shown
  state.activeAxisId = null;

    // ---------- UI: loading
    const loader = document.getElementById('loader');
    // Remove any potential heatmap UI elements (no surface per requirements)
    document.querySelectorAll('[data-view="heatmap"], [data-feature="heatmap"], #heatmap-btn').forEach(n => n.remove());

    // Mobile Controls toggle logic
    const topbar = document.getElementById('topbar');
    const controlsToggle = document.getElementById('controlsToggle');
    const controlsPanel = document.getElementById('controls-panel');
    function isMobile() { return window.innerWidth <= 768; }
    function updateHeaderHeight() { if (topbar) document.documentElement.style.setProperty('--header-h', topbar.offsetHeight + 'px'); }
    function setControls(open) {
      if (!topbar) return;
      if (!isMobile()) { topbar.dataset.state = 'expanded'; controlsToggle.setAttribute('aria-expanded', 'true'); controlsToggle.setAttribute('aria-label', 'Hide controls'); updateHeaderHeight(); return; }
      topbar.dataset.state = open ? 'expanded' : 'collapsed';
      controlsToggle.setAttribute('aria-expanded', open ? 'true' : 'false');
      controlsToggle.setAttribute('aria-label', open ? 'Hide controls' : 'Show controls');
      if (open) {
        // focus first interactive control inside panel
        const first = controlsPanel.querySelector('button, input, select');
        if (first) setTimeout(() => { first.focus({ preventScroll: true }); }, 10);
      } else {
        setTimeout(() => controlsToggle.focus({ preventScroll: true }), 10);
      }
      updateHeaderHeight();
      window.dispatchEvent(new Event('resize'));
    }
    if (controlsToggle) {
      controlsToggle.addEventListener('click', () => {
        const open = topbar.dataset.state !== 'expanded';
        setControls(open);
      });
    }
    // Focus sentinel: on first Tab from browser chrome, move focus into the controls
    (function(){
      const fs = document.getElementById('focusSentinel');
      if (!fs) return;
      fs.addEventListener('focus', (e) => {
        try {
          // Ensure controls are visible on mobile before focusing into them
          if (isMobile() && topbar && topbar.dataset.state !== 'expanded') setControls(true);
          const first = controlsPanel && controlsPanel.querySelector('button, input, select');
          if (first && typeof first.focus === 'function') { first.focus(); }
        } catch(_) {}
      });
    })();
    window.addEventListener('resize', () => {
      if (!isMobile()) {
        setControls(true); // always expanded on desktop
      } else {
        // remain in whatever state currently set except initialize
        updateHeaderHeight();
      }
    });
    // Initialize state (collapsed on mobile, expanded otherwise)
    setTimeout(() => { setControls(!isMobile() ? true : false); }, 0);
    // drag/drop removed; page will attempt to auto-load `data/resurrection-data.json` on load

    function loadFromText(txt) {
      try {
        const json = JSON.parse(txt);
        validate(json);
        initialize(json);
      } catch (err) { alert('Invalid JSON: ' + err.message); }
    }

    function validate(j) {
      if (!j.criteria || !Array.isArray(j.criteria)) throw new Error('Missing criteria[]');
      if (!j.hypotheses || !Array.isArray(j.hypotheses)) throw new Error('Missing hypotheses[]');
      j.criteria.forEach(c => { if (!c.id || !c.label || !c.short || !c.anchors) throw new Error('Each criterion needs id,label,short,anchors'); });
    }

    // ---------- helpers
    const byId = arr => Object.fromEntries(arr.map(d => [d.id, d]));
    const clamp01 = x => Math.max(0, Math.min(1, x));
    const avg = a => d3.mean(a);
    const ordinalLabel = (crit, val, Criteria) => { const a = Criteria[crit].anchors; if (val < 1 / 3) return a[0]; if (val < 2 / 3) return a[1]; return a[2]; };
    function quantize(v) { if (v < 1 / 3) return 0.25; if (v < 2 / 3) return 0.5; return 0.75; }
    // point-in-polygon (ray-casting)
    function pointInPoly(x, y, vs) {
      let inside = false;
      for (let i = 0, j = vs.length - 1; i < vs.length; j = i++) {
        const xi = vs[i][0], yi = vs[i][1];
        const xj = vs[j][0], yj = vs[j][1];
        const intersect = ((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi + 0.0) + xi);
        if (intersect) inside = !inside;
      }
      return inside;
    }

    // ---------- tooltip plumbing
    const tt = d3.select('#tt'); let hideTimer = null;
    // tooltip pinned state (desktop only)
    state.ttPinned = false;
    // store the hypothesis color for pinned tooltips
    state.ttPinnedColor = null;
    // store last manual position when pinned
    state.ttPos = { left: null, top: null };
    // flag to track if user has manually dragged the tooltip
    state.ttUserMoved = false;
    // store anchor point for leader line
    state.ttAnchor = { x: null, y: null };
    const sheetEl = document.getElementById('ttSheet');
    const sheetInner = sheetEl ? sheetEl.querySelector('.sheet-inner') : null;
    const sheetClose = sheetEl ? sheetEl.querySelector('.close-btn') : null;
    // track the bounding rect of the last tapped element so the sheet can avoid obscuring it
    let sheetAnchorRect = null;
    
    // Leader line SVG for connecting tooltip to anchor point
    let leaderSvg = null;
    function ensureLeaderSvg() {
      if (leaderSvg) return leaderSvg;
      leaderSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
      leaderSvg.id = 'tt-leader';
      leaderSvg.style.position = 'fixed';
      leaderSvg.style.top = '0';
      leaderSvg.style.left = '0';
      leaderSvg.style.width = '100%';
      leaderSvg.style.height = '100%';
      leaderSvg.style.pointerEvents = 'none';
      leaderSvg.style.zIndex = '9998'; // Below tooltip (9999) but above blocker
      leaderSvg.style.display = 'none';
      const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
      line.id = 'tt-leader-line';
      line.setAttribute('stroke', 'var(--tooltip-pinned-color, var(--primary))');
      line.setAttribute('stroke-width', '1.5');
      line.setAttribute('stroke-dasharray', '4 3');
      line.setAttribute('opacity', '0.6');
      leaderSvg.appendChild(line);
      document.body.appendChild(leaderSvg);
      return leaderSvg;
    }
    
    function updateLeaderLine() {
      if (!state.ttPinned || !state.ttAnchor.x || !state.ttAnchor.y) {
        hideLeaderLine();
        return;
      }
      const ttNode = tt.node();
      if (!ttNode) return;
      const ttRect = ttNode.getBoundingClientRect();
      const anchorX = state.ttAnchor.x;
      const anchorY = state.ttAnchor.y;
      
      // Calculate tooltip center
      const ttCenterX = ttRect.left + ttRect.width / 2;
      const ttCenterY = ttRect.top + ttRect.height / 2;
      
      // Only show leader if tooltip has moved significantly from anchor
      const distance = Math.sqrt(Math.pow(ttCenterX - anchorX, 2) + Math.pow(ttCenterY - anchorY, 2));
      if (distance < 30) {
        hideLeaderLine();
        return;
      }
      
      const svg = ensureLeaderSvg();
      const line = svg.querySelector('#tt-leader-line');
      if (!line) return;
      
      // Update line color to match tooltip (or default primary color for criteria)
      if (state.ttPinnedColor) {
        line.setAttribute('stroke', state.ttPinnedColor);
      } else {
        // Use default primary color when no hypothesis color is set (e.g., for criteria)
        line.setAttribute('stroke', 'var(--primary)');
      }
      
      // Find the best connection point on the tooltip edge
      const dx = anchorX - ttCenterX;
      const dy = anchorY - ttCenterY;
      const angle = Math.atan2(dy, dx);
      
      // Calculate intersection with tooltip rectangle
      const halfW = ttRect.width / 2;
      const halfH = ttRect.height / 2;
      let ttEdgeX, ttEdgeY;
      
      // Determine which edge to connect to based on angle
      const tanAngle = Math.abs(Math.tan(angle));
      if (tanAngle < halfH / halfW) {
        // Connect to left or right edge
        ttEdgeX = ttCenterX + (dx > 0 ? halfW : -halfW);
        ttEdgeY = ttCenterY + (dx > 0 ? halfW : -halfW) * Math.tan(angle);
      } else {
        // Connect to top or bottom edge
        ttEdgeX = ttCenterX + (dy > 0 ? halfH : -halfH) / Math.tan(angle);
        ttEdgeY = ttCenterY + (dy > 0 ? halfH : -halfH);
      }
      
      line.setAttribute('x1', anchorX);
      line.setAttribute('y1', anchorY);
      line.setAttribute('x2', ttEdgeX);
      line.setAttribute('y2', ttEdgeY);
      
      svg.style.display = 'block';
    }
    
    function hideLeaderLine() {
      if (leaderSvg) {
        leaderSvg.style.display = 'none';
      }
    }
    
    // Helper to set the tooltip pinned color
    function setTooltipColor(color) {
      if (!color) return;
      state.ttPinnedColor = color;
      const ttNode = tt.node();
      if (ttNode) {
        ttNode.style.setProperty('--tooltip-pinned-color', color);
        // Convert hex color to rgba for the shadow
        const rgb = hexToRgb(color);
        if (rgb) {
          const shadow = `0 12px 36px rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 0.12)`;
          ttNode.style.setProperty('--tooltip-pinned-shadow', shadow);
        }
      }
    }
    
    // Helper to clear the tooltip pinned color
    function clearTooltipColor() {
      state.ttPinnedColor = null;
      const ttNode = tt.node();
      if (ttNode) {
        ttNode.style.removeProperty('--tooltip-pinned-color');
        ttNode.style.removeProperty('--tooltip-pinned-shadow');
      }
    }
    
    // Helper to convert hex color to RGB object
    function hexToRgb(hex) {
      // Remove # if present
      hex = hex.replace(/^#/, '');
      // Handle 3-digit hex
      if (hex.length === 3) {
        hex = hex.split('').map(c => c + c).join('');
      }
      const num = parseInt(hex, 16);
      return {
        r: (num >> 16) & 255,
        g: (num >> 8) & 255,
        b: num & 255
      };
    }
    // track active chart vertical shift (pixels)
    let chartShift = 0;
    // last applied D3 transform so we can reapply it after re-render
    state.lastTransform = null;
    state.currentSvg = null;
    state.currentZoom = null;

    function prefersSheet() {
      // Use bottom sheet if viewport narrow or primary pointer coarse (touch)
      const coarse = window.matchMedia && window.matchMedia('(pointer: coarse)').matches;
      return coarse || window.innerWidth < 640;
    }

    // Convert an SVG-bound datum anchor or an element into a screen-space rect.
    // If the element has a D3 datum with x/y in chart-local coordinates, use the D3 zoom transform
    // and stored chart center to map coordinates exactly to screen pixels. Otherwise fall back
    // to getBoundingClientRect when available.
    function getScreenRectForAnchor(anchor, svgNode) {
      if (!anchor) return null;
      try {
        // Prefer the browser rect when available — it reflects the post-render screen position
        if (anchor && typeof anchor.getBoundingClientRect === 'function') {
          return anchor.getBoundingClientRect();
        }
        // Fallback: compute from datum + d3 transform when anchor is a data-bound SVG node
        if (anchor && anchor.__data__ && svgNode) {
          const d = anchor.__data__;
          const svgRect = svgNode.getBoundingClientRect();
          const tcur = d3.zoomTransform(svgNode) || d3.zoomIdentity;
          const k = tcur.k || 1;
          const cx = (state.chartCenter && state.chartCenter.cx) ? state.chartCenter.cx : (svgRect.width / 2);
          const cy = (state.chartCenter && state.chartCenter.cy) ? state.chartCenter.cy : (svgRect.height / 2);
          const localX = (typeof d.x === 'number') ? (d.x + cx) : null;
          const localY = (typeof d.y === 'number') ? (d.y + cy) : null;
          if (localX !== null && localY !== null) {
            const screenX = svgRect.left + (tcur.x || 0) + localX * k;
            const screenY = svgRect.top + (tcur.y || 0) + localY * k;
            const r = (d.baseR || d.baseRing || 6) * k;
            return { left: screenX - r, top: screenY - r, right: screenX + r, bottom: screenY + r, width: r * 2, height: r * 2 };
          }
        }
      } catch (_e) { }
      return null;
    }

    // anchorRect is an optional DOMRect of the tapped item so we can shift the chart on mobile
    function openSheet(html, highlight = null, anchorRect = null) {
      if (!sheetEl) return;
      // Store the currently focused element so we can restore focus when sheet closes
      state.sheetTriggerElement = document.activeElement;
      sheetInner.innerHTML = html;
      sheetEl.classList.add('open');
      sheetEl.setAttribute('aria-hidden', 'false');
      // prevent background scroll while open
      document.body.style.overflow = 'hidden';
      // remember anchor for potential layout adjustments
      sheetAnchorRect = anchorRect || sheetAnchorRect;
      // optional debug overlay when ?pv_debug_sheet is present in URL
      try {
        if (window.location.search && window.location.search.indexOf('pv_debug_sheet') >= 0 && sheetAnchorRect) {
          const dbg = document.createElement('div'); dbg.id = 'pv-sheet-anchor-debug';
          dbg.style.position = 'fixed'; dbg.style.pointerEvents = 'none'; dbg.style.zIndex = 12000;
          dbg.style.border = '2px dashed rgba(255,40,40,0.95)'; dbg.style.borderRadius = '6px';
          dbg.style.left = (sheetAnchorRect.left) + 'px'; dbg.style.top = (sheetAnchorRect.top) + 'px';
          dbg.style.width = (sheetAnchorRect.width || (sheetAnchorRect.right - sheetAnchorRect.left)) + 'px';
          dbg.style.height = (sheetAnchorRect.height || (sheetAnchorRect.bottom - sheetAnchorRect.top)) + 'px';
          document.body.appendChild(dbg);
          setTimeout(() => { try { dbg.remove(); } catch (e) { } }, 1600);
          try { console.log('pv_debug_sheet anchor', sheetAnchorRect); } catch (e) { }
        }
      } catch (e) { }
      try {
        if (highlight) {
          if (typeof highlight === 'object' && highlight.hypId) {
            highlightSeries(highlight.hypId, highlight.critId || null);
            if (highlight.critId) state.sheetActiveVertex = { hypId: highlight.hypId, critId: highlight.critId };
          }
          else { highlightSeries(highlight); }
        }
      } catch (e) { }
      // On mobile / coarse pointer, shift the chart up if the sheet would cover the tapped point.
      // Measure after the sheet is painted (use two RAF ticks) so we get the final sheet position
      if (prefersSheet() && sheetAnchorRect) {
        try {
          const chartEl = state.chartRoot || document.getElementById('chart');
          const anchor = sheetAnchorRect;
          const padding = 12; // pixels of breathing room between anchor and sheet
          // Wait for the sheet open transition to finish so getBoundingClientRect reflects the final position.
          const doMeasure = () => {
            try {
              const sheetRect = sheetEl.getBoundingClientRect();
              // Prefer computing anchor rect from the underlying datum when available (most robust under
              // D3 zoom/pan). Only fall back to getBoundingClientRect when datum-based mapping isn't possible.
              let curAnchor = anchor;
              try {
                if (anchor && anchor.__data__ && state.currentSvg && state.currentSvg.node()) {
                  // compute screen position from datum and current D3 transform
                  const d = anchor.__data__;
                  const svgNode = state.currentSvg.node();
                  const svgRect = svgNode.getBoundingClientRect();
                  const tcur = d3.zoomTransform(svgNode) || d3.zoomIdentity;
                  const k = tcur.k || 1;
                  const cx = (state.chartCenter && state.chartCenter.cx) ? state.chartCenter.cx : (svgRect.width / 2);
                  const cy = (state.chartCenter && state.chartCenter.cy) ? state.chartCenter.cy : (svgRect.height / 2);
                  const localY = (typeof d.y === 'number') ? (d.y + cy) : null;
                  if (localY !== null) {
                    const screenY = svgRect.top + (tcur.y || 0) + localY * k;
                    const screenX = svgRect.left + (tcur.x || 0) + ((d.x || 0) + cx) * k;
                    const r = (d.baseR || d.baseRing || 6) * k;
                    curAnchor = { top: screenY - r, bottom: screenY + r, left: screenX - r, right: screenX + r, width: r * 2, height: r * 2 };
                  }
                } else if (anchor && typeof anchor.getBoundingClientRect === 'function') {
                  curAnchor = anchor.getBoundingClientRect();
                }
              } catch (_e) { }
              const chartRect = chartEl ? chartEl.getBoundingClientRect() : null;
              const overlap = (curAnchor && curAnchor.bottom ? curAnchor.bottom : (anchor && anchor.bottom)) - (sheetRect.top) + padding;
              if (overlap > 0 && chartEl && chartRect) {
                // state.chartShift stores the desired total vertical shift in screen pixels
                // Prefer to derive the current screen shift from the live D3 transform so we don't rely on stale state.
                let currentScreen = parseFloat(state.chartShift || '0') || 0;
                try {
                  if (state.currentSvg && state.currentSvg.node()) {
                    const tcur = d3.zoomTransform(state.currentSvg.node());
                    if (tcur && typeof tcur.y === 'number') currentScreen = Math.max(0, -tcur.y);
                  }
                } catch (_e) { }
                const desiredTotalUncapped = currentScreen + overlap;
                // Allow the desired shift to be as large as needed to bring the anchor above the sheet.
                // Previously we capped this to chartRect.height-40 which could be too small at some zoom levels.
                const desiredTotal = desiredTotalUncapped;
                // only increase the shift in screen pixels
                if (desiredTotal > currentScreen) {
                  state.chartShift = desiredTotal;
                  // compute applied transform in chart-local units by dividing by zoom
                  const scale = state.zoomK || 1;
                  const applied = desiredTotal / scale;
                  // Prefer composing this bump into the D3 zoom transform so it behaves like a normal pan.
                  try {
                    if (state.currentSvg && state.currentZoom && state.currentSvg.node()) {
                      // read the current transform directly from the svg so we use the exact applied transform
                      const t = d3.zoomTransform(state.currentSvg.node()) || state.lastTransform || d3.zoomIdentity;
                      // desiredTotal is the total desired screen-pixel shift. Only apply the incremental delta
                      // because t.y already includes prior programmatic pans.
                      const delta = (desiredTotal - currentScreen) || 0;
                      const newT = d3.zoomIdentity.translate(t.x, t.y - delta).scale(t.k || 1);
                      // animate the transform so the chart visibly moves up
                      state.currentSvg.transition().duration(280).call(state.currentZoom.transform, newT);
                      // remove any leftover inline transform on the chart element to avoid double-counting
                      try { chartEl.style.transform = ''; chartEl.dataset.shift = ''; } catch (_e) { }
                      // remember the transform we just requested (zoom handler will also update on progress)
                      try { state.lastTransform = newT; } catch (_e) { }
                    } else {
                      // fallback: directly translate the chart root element (chart-local units)
                      chartEl.style.transition = 'transform .28s ease'; chartEl.style.transform = `translateY(-${applied}px)`; chartEl.dataset.shift = String(applied);
                    }
                  } catch (e) {
                    try { chartEl.style.transition = 'transform .28s ease'; chartEl.style.transform = `translateY(-${applied}px)`; chartEl.dataset.shift = String(applied); } catch (_e) { }
                  }
                  chartShift = desiredTotal;
                  try {
                    if (window.location.search && window.location.search.indexOf('pv_debug_sheet') >= 0) {
                      const tcur = (state.currentSvg && state.currentSvg.node()) ? d3.zoomTransform(state.currentSvg.node()) : null;
                      console.debug('openSheet shift (applied)', { anchor: curAnchor || anchor, sheetRect, chartRect, overlap, desiredTotal, applied, previous: currentScreen, scale, tcur, delta: desiredTotal - currentScreen, newTransform: state.lastTransform });
                    }
                  } catch (e) { }
                } else {
                  try { console.debug('openSheet shift (kept existing)', { anchor, sheetRect, chartRect, overlap, desiredTotal: currentScreen, previous: currentScreen }); } catch (e) { }
                }
              }
            } catch (e) { }
          };
          let handled = false;
          const onEnd = (ev) => {
            if (handled) return;
            handled = true;
            sheetEl.removeEventListener('transitionend', onEnd);
            doMeasure();
          };
          sheetEl.addEventListener('transitionend', onEnd);
          // fallback in case transitionend doesn't fire
          setTimeout(() => { if (!handled) { handled = true; sheetEl.removeEventListener('transitionend', onEnd); doMeasure(); } }, 420);
        } catch (e) { }
      }
    }
    function closeSheet() {
      if (!sheetEl) return;
      sheetEl.classList.remove('open');
      sheetEl.setAttribute('aria-hidden', 'true');
      document.body.style.overflow = '';
      // clear anchor
      sheetAnchorRect = null;
      // clear persisted active vertex used during sheet interactions
      state.sheetActiveVertex = null;
      // clear any active axis highlight
      try { state.activeAxisId = null; if (typeof updateAxisSelection === 'function') updateAxisSelection(); } catch (_) {}
      // clear highlight after closing (slight delay so user perceives action end)
      setTimeout(() => { clearHighlight(); }, 60);
      
      // Restore focus to the element that triggered the sheet
      if (state.sheetTriggerElement) {
        state.sheetTriggerElement.focus();
        state.sheetTriggerElement = null;
      }
    }
    if (sheetClose) { sheetClose.addEventListener('click', () => closeSheet()); }
    // swipe-down gesture to close
    (function () { if (!sheetEl) return; let startY = null, startT = null; sheetEl.addEventListener('touchstart', e => { if (e.touches.length === 1) { startY = e.touches[0].clientY; startT = Date.now(); } }); sheetEl.addEventListener('touchmove', e => { if (startY == null) return; const dy = e.touches[0].clientY - startY; if (dy > 60) { closeSheet(); startY = null; } }); sheetEl.addEventListener('touchend', () => { startY = null; startT = null; }); })();
    function showTTAt(html, svgEl, sx, sy, dy = -10) {
      if (prefersSheet()) {
        // compute an approximate anchor rect from svgEl + sx/sy so openSheet can shift the chart
        try {
          const svgRect = svgEl.getBoundingClientRect();
          const ax = svgRect.left + sx;
          const ay = svgRect.top + sy + dy;
          // small rect centered on the point
          const anchorRectApprox = { left: ax - 8, right: ax + 8, top: ay - 8, bottom: ay + 8, width: 16, height: 16 };
          openSheet(html, null, anchorRectApprox);
        } catch (e) {
          openSheet(html, null, sheetAnchorRect || null);
        }
        return;
      }
      clearTimeout(hideTimer);
      // Save scroll position to avoid any reflow caused by inserting tooltip content
      const scrollTop = document.documentElement.scrollTop || document.body.scrollTop;
      const scrollLeft = document.documentElement.scrollLeft || document.body.scrollLeft;
      const r = svgEl.getBoundingClientRect();
      // Use transform for compositing where possible to avoid layout jumps
      tt.html(html).style('display', 'block').style('left', (r.left + sx) + 'px').style('top', (r.top + sy + dy) + 'px').style('transform', 'translateZ(0)');
      // (pin button removed)
      // pin UI removed
      // clamp tooltip so it doesn't force scrollbars on small viewports
      const ttNode = tt.node();
      if (ttNode) {
        const ttr = ttNode.getBoundingClientRect();
        let left = parseFloat(tt.style('left')) || ttr.left;
        let top = parseFloat(tt.style('top')) || ttr.top;
        const pad = 8;
        const vw = window.innerWidth, vh = window.innerHeight;
        // shift horizontally if overflowing
        if (left + ttr.width + pad > vw) left = Math.max(pad, vw - ttr.width - pad);
        if (left < pad) left = pad;
        // shift vertically if overflowing
        if (top + ttr.height + pad > vh) top = Math.max(pad, vh - ttr.height - pad);
        if (top < pad) top = pad;
        tt.style('left', left + 'px').style('top', top + 'px');
      }
      // restore scroll position in case browser adjusted it
      window.scrollTo(scrollLeft, scrollTop);
    }
    // Toggle pinned state (desktop only) when user clicks the tooltip. When pinned, add visual style
    // and enable dragging. Clicking again will unpin and resume normal hover hide behavior.
    (function () {
      const node = tt.node();
      if (!node) return;
      // click to toggle pinned state
      node.addEventListener('click', function (ev) {
        // only on primary button and only on non-touch (desktop) interactions
        if (prefersSheet()) return;
        if (ev.button !== 0) return;
        // If this click immediately follows a drag, ignore it (it was the drag-release)
        // Use a time-based suppression window managed by the pointer handlers
        if (Date.now() < (state._suppressClickUntil || 0)) { ev.stopPropagation(); return; }
        ev.stopPropagation();
        state.ttPinned = !state.ttPinned;
        if (state.ttPinned) {
          tt.classed('pinned', true);
          // record absolute position so we can maintain it while pinned
          const r = node.getBoundingClientRect(); state.ttPos.left = r.left; state.ttPos.top = r.top;
          // When pinning via tooltip click, set the leader-line anchor to the currently active point or axis.
          try {
            const svgEl = (state.currentSvg && state.currentSvg.node && state.currentSvg.node()) ? state.currentSvg.node() : document.querySelector('#chart svg');
            let anchorNode = null;
            if (state.activeVertex && svgEl) {
              // active vertex: find its g.vertex node by datum match
              anchorNode = d3.select(svgEl).selectAll('.vertex')
                .filter(v => v && v.h && v.c && v.h.id === state.activeVertex.hypId && v.c.id === state.activeVertex.critId)
                .node();
            } else if (state.activeAxisId && svgEl) {
              // active axis: use the axis-hit circle
              anchorNode = d3.select(svgEl).selectAll('.axis-hit')
                .filter(x => x && x.id === state.activeAxisId)
                .node();
            }
            if (anchorNode && svgEl) {
              const br = (typeof getScreenRectForAnchor === 'function') ? (getScreenRectForAnchor(anchorNode, svgEl) || (anchorNode.getBoundingClientRect ? anchorNode.getBoundingClientRect() : null)) : (anchorNode.getBoundingClientRect ? anchorNode.getBoundingClientRect() : null);
              if (br) {
                state.ttAnchor.x = br.left + (br.width || 0) / 2;
                state.ttAnchor.y = br.top + (br.height || 0) / 2;
              }
            } else {
              // No active item; clear the anchor so no stale line is drawn
              state.ttAnchor.x = null; state.ttAnchor.y = null;
            }
          } catch (_) { try { state.ttAnchor.x = null; state.ttAnchor.y = null; } catch(e) {} }
          // prevent scheduled hide while pinned
          clearTimeout(hideTimer);
          showTTBlocker();
          // Show leader line (will be hidden if tooltip hasn't moved)
          updateLeaderLine();
        } else {
          tt.classed('pinned', false);
          clearTooltipColor();
          hideLeaderLine();
          // Clear anchor so future pin doesn't use a stale point
          try { state.ttAnchor.x = null; state.ttAnchor.y = null; } catch(_) {}
          // Clear stored position and user moved flag so next tooltip appears at default position
          state.ttPos.left = null; state.ttPos.top = null; state.ttUserMoved = false;
          // allow tooltip to hide on mouseleave again
          scheduleHide(150);
          hideTTBlocker();
        }
      });
      // draggable: use pointer events so it works with mouse and stylus on desktop
      let dragging = false; let startX = 0, startY = 0, origLeft = 0, origTop = 0;
      // time-based suppression window to ignore clicks immediately following a drag
      state._suppressClickUntil = 0;
      node.addEventListener('pointerdown', function (ev) {
        if (prefersSheet()) return; // no drag on mobile sheets
        // only drag when pinned
        if (!state.ttPinned) return;
        // only left button
        if (ev.button !== 0) return;
        dragging = true; node.setPointerCapture(ev.pointerId);
        state._dragging = true;
        // start suppressing clicks for a short window while dragging
        state._suppressClickUntil = Date.now() + 400;
        startX = ev.clientX; startY = ev.clientY;
        const r = node.getBoundingClientRect(); origLeft = r.left; origTop = r.top;
        ev.preventDefault(); ev.stopPropagation();
      });
      node.addEventListener('pointermove', function (ev) {
        if (!dragging) return; ev.preventDefault(); ev.stopPropagation();
        const dx = ev.clientX - startX; const dy = ev.clientY - startY;
        const newLeft = Math.round(origLeft + dx); const newTop = Math.round(origTop + dy);
        node.style.left = newLeft + 'px'; node.style.top = newTop + 'px'; state.ttPos.left = newLeft; state.ttPos.top = newTop;
        // Mark that user has manually moved the tooltip
        state.ttUserMoved = true;
        // Update leader line during drag
        updateLeaderLine();
        // extend suppression window because a drag is happening
        state._suppressClickUntil = Date.now() + 400;
      });
      node.addEventListener('pointerup', function (ev) {
        if (!dragging) return; dragging = false; state._dragging = false;
        try { node.releasePointerCapture(ev.pointerId); } catch (e) { }
        // keep suppression window briefly after release so the click generated by the release is ignored
        state._suppressClickUntil = Date.now() + 400;
        // ensure the pointerup doesn't bubble and trigger blocker/document handlers
        ev.stopPropagation();
      });
      node.addEventListener('pointercancel', function (ev) { if (!dragging) return; dragging = false; state._dragging = false; try { node.releasePointerCapture(ev.pointerId); } catch (e) { } ev.stopPropagation(); });
      // ensure mouseenter keeps tooltip visible even when pinned
      node.addEventListener('mouseenter', () => { state.isOverTT = true; clearTimeout(hideTimer); });
      node.addEventListener('mouseleave', () => { state.isOverTT = false; if (!state.ttPinned) scheduleHide(); });
    })();
    // blocker element that prevents interaction with the chart while tooltip is pinned
    let _ttBlocker = null;
    function ensureTTBlocker() {
      if (_ttBlocker) return _ttBlocker; _ttBlocker = document.createElement('div'); _ttBlocker.className = 'tt-blocker'; _ttBlocker.style.display = 'none'; document.body.appendChild(_ttBlocker);
      // clicking the blocker should either forward the click to an underlying vertex (so a new
      // popup can be pinned) or unpin/close the tooltip when clicking elsewhere on the chart.
      _ttBlocker.addEventListener('click', function (ev) {
        // ignore clicks generated by a recent drag-release of the tooltip
        if (Date.now() < (state._suppressClickUntil || 0)) { ev.stopPropagation(); return; }
        ev.stopPropagation();
        // Temporarily hide the blocker so we can detect the underlying element at the click point.
        try {
          _ttBlocker.style.display = 'none';
          const under = document.elementFromPoint(ev.clientX, ev.clientY);
          // Restore blocker visibility immediately
          _ttBlocker.style.display = 'block';
          if (under) {
            // Prefer dispatching clicks to underlying interactive elements so the user's intent
            // to open/pin another tooltip is honored. Support axis markers and vertex groups.
            const interactive = under.closest && under.closest('.vertex, .axis-hit, .axis-dot, .hit-target');
            if (interactive) {
              // Dispatch a synthetic click on the underlying interactive element so its click handler runs
              // Use bubbling MouseEvent so listeners see it like a normal click.
              const evt = new MouseEvent('click', { bubbles: true, cancelable: true, clientX: ev.clientX, clientY: ev.clientY });
              interactive.dispatchEvent(evt);
              return; // don't unpin; the clicked element's handler will manage pin/blocker
            }
          }
        } catch (e) {
          try { _ttBlocker.style.display = 'block'; } catch (_e) { }
        }
        // default: unpin and hide tooltip
        state.ttPinned = false; tt.classed('pinned', false); clearTooltipColor(); hideLeaderLine(); 
        // Clear stored position and user moved flag so next tooltip appears at default position
        state.ttPos.left = null; state.ttPos.top = null; state.ttUserMoved = false;
        hideTT(); hideTTBlocker();
      });
      return _ttBlocker;
    }
    function showTTBlocker() {
      const b = ensureTTBlocker(); // position it to cover the chart area
      const chartEl = document.getElementById('chart'); if (!chartEl) { b.style.display = 'none'; return; }
      const r = chartEl.getBoundingClientRect(); b.style.left = r.left + 'px'; b.style.top = r.top + 'px'; b.style.width = r.width + 'px'; b.style.height = r.height + 'px'; b.style.display = 'block';
    }
    function hideTTBlocker() { const b = ensureTTBlocker(); b.style.display = 'none'; }
    function scheduleHide(delay = 200) {
      // Don't auto-hide while a bottom sheet is open or when the tooltip is pinned on desktop
      if (prefersSheet() && sheetEl && sheetEl.classList.contains('open')) return;
      if (state.ttPinned && !prefersSheet()) return;
      clearTimeout(hideTimer);
      hideTimer = setTimeout(() => {
        // Respect suppression window: ignore hides right after we pin
        if (Date.now() < (state._suppressHideUntil || 0)) return;
        if (!state.isOverChart && !state.isOverTT) {
          tt.style('display', 'none');
          state.pagerActive = null;
          // clear any active axis highlight when tooltip fully hides
          try { state.activeAxisId = null; updateAxisSelection(); } catch (_) {}
          clearHighlight();
        }
      }, delay);
    }
    function hideTT() {
      // If we're within the suppression window, don't hide
      if (Date.now() < (state._suppressHideUntil || 0)) return;
      tt.style('display', 'none'); hideLeaderLine(); state.pagerActive = null; try { state.activeAxisId = null; updateAxisSelection(); } catch (_) {} clearHighlight(true);
      // Clear anchor so a future pin doesn't draw line from stale point
      try { state.ttAnchor.x = null; state.ttAnchor.y = null; } catch(_) {}
    }
    tt.on('click', () => { /* no-op (pin removed) */ })
      .on('mouseenter', () => { state.isOverTT = true; clearTimeout(hideTimer); }).on('mouseleave', () => {
        state.isOverTT = false;
        // If pinned on desktop, do not auto-hide or clear highlight/pager state when leaving the tooltip
        if (state.ttPinned && !prefersSheet()) return;
        // when leaving the tooltip, schedule hide; also clear pagerActive after the delay so pager behavior reverts
        scheduleHide();
        if (state.pagerActive) {
          setTimeout(() => {
            // respect pinned state even if it changed during the delay
            if (state.ttPinned && !prefersSheet()) return;
            if (!state.isOverTT && !state.isOverChart) { state.pagerActive = null; clearHighlight(); }
          }, 250);
        }
      });

    // ---------- render UI
    function initialize(json) {
      Data = json;
      if (typeof loader !== 'undefined' && loader) loader.style.display = 'none';
      state.selected = new Set(Data.hypotheses.map(h => h.id));
      state.weights = { ...(Data.weights || {}) };
      renderControls();
      render();
    }

    function renderControls() {
      const wrap = d3.select('#hypotheses');
      wrap.attr('role', 'group').attr('aria-label', 'Hypotheses legend and visibility');
      wrap.selectAll('*').remove();
      const C = byId(Data.criteria), Hy = byId(Data.hypotheses);
      const pill = wrap.selectAll('.pill').data(Data.hypotheses).join('label').attr('class', 'pill');
      pill.append('span').attr('class', 'sw').style('background', d => getColorFor(d));
      // Set tabindex for hypothesis controls - will be set correctly by global setup
      pill.append('input').attr('type', 'checkbox').attr('checked', true)
        .attr('tabindex', 0)
        .on('change', (e, d) => { e.target.checked ? state.selected.add(d.id) : state.selected.delete(d.id); render(); })
        .on('keydown', (e, d) => {
          // Support both Space and Enter for checkbox toggling
          if (e.key === ' ' || e.key === 'Enter') {
            e.preventDefault(); // Prevent default space scrolling behavior
            // Toggle the checkbox
            e.target.checked = !e.target.checked;
            // Trigger the change event manually
            const changeEvent = new Event('change', { bubbles: true });
            e.target.dispatchEvent(changeEvent);
          }
        });
      // Keep legend compact: only show the hypothesis name (color shown in the sw square)
      pill.append('span').attr('class', 'txt').text(d => d.label);

      // only bind view switching to buttons that declare a data-view (help button is not a view)
      d3.selectAll('.viewtabs button[data-view]').on('click', (e) => {
        d3.selectAll('.viewtabs button[data-view]').classed('active', false).attr('aria-selected', false);
        d3.select(e.currentTarget).classed('active', true).attr('aria-selected', true);
        state.view = e.currentTarget.dataset.view; render();
      });

      // Store the element that triggered the modal for focus restoration
      let modalTriggerElement = null;
      
      d3.select('#helpBtn').on('click', function() { 
        modalTriggerElement = this;
        d3.select('#helpOverlay').style('display', 'flex'); 
        d3.select('#helpClose').node().focus(); 
      });
      
      const closeHelpModal = () => {
        d3.select('#helpOverlay').style('display', 'none');
        if (modalTriggerElement) {
          modalTriggerElement.focus();
          modalTriggerElement = null;
        }
      };
      
      d3.select('#helpClose').on('click', closeHelpModal);
      d3.select('#helpOverlay').on('click', function (e) { if (e.target === this) closeHelpModal(); });
      // Dims (Criteria) modal with focus restoration
      let dimsModalTrigger = null;
      
      d3.select('#dimsBtn').on('click', function() { 
        dimsModalTrigger = this;
        d3.select('#dimsOverlay').style('display', 'flex'); 
        d3.select('#dimsClose').node().focus(); 
        d3.select('#dimsBtn').attr('aria-expanded', 'true'); 
      });
      
      const closeDimsModal = () => {
        d3.select('#dimsOverlay').style('display', 'none'); 
        d3.select('#dimsBtn').attr('aria-expanded', 'false');
        if (dimsModalTrigger) {
          dimsModalTrigger.focus();
          dimsModalTrigger = null;
        }
      };
      
      d3.select('#dimsClose').on('click', closeDimsModal);
      d3.select('#dimsOverlay').on('click', function (e) { if (e.target === this) closeDimsModal(); });

      // Facts modal with focus restoration
      let factsModalTrigger = null;
      
      d3.select('#factsBtn').on('click', function() { 
        factsModalTrigger = this;
        d3.select('#factsOverlay').style('display', 'flex'); 
        d3.select('#factsClose').node().focus(); 
        d3.select('#factsBtn').attr('aria-expanded', 'true'); 
      });
      
      const closeFactsModal = () => {
        d3.select('#factsOverlay').style('display', 'none'); 
        d3.select('#factsBtn').attr('aria-expanded', 'false');
        if (factsModalTrigger) {
          factsModalTrigger.focus();
          factsModalTrigger = null;
        }
      };
      
      d3.select('#factsClose').on('click', closeFactsModal);
      d3.select('#factsOverlay').on('click', function (e) { if (e.target === this) closeFactsModal(); });

      // Consolidated Escape handling: close overlays and tooltips
      window.addEventListener('keydown', (e) => { 
        if (e.key === 'Escape') { 
          hideTT(); 
          // Close modals with proper focus restoration
          if (d3.select('#helpOverlay').style('display') !== 'none') {
            closeHelpModal();
          }
          if (d3.select('#factsOverlay').style('display') !== 'none') {
            closeFactsModal();
          }
          if (d3.select('#dimsOverlay').style('display') !== 'none') {
            closeDimsModal();
          }
        } 
      });
      window.addEventListener('keydown', (e) => { if (e.key === 'Escape') { closeSheet(); } });
      // Prevent clicks inside the mobile bottom sheet from bubbling to document-level handlers.
      // This preserves the current highlight while interacting with the panel and ensures
      // only the explicit pager/close controls affect selection.
      if (sheetEl) { sheetEl.addEventListener('click', (e) => { e.stopPropagation(); }); }
      document.addEventListener('click', (e) => {
        // ignore clicks immediately after dragging the pinned tooltip
        if (Date.now() < (state._suppressClickUntil || 0)) { e.stopPropagation(); return; }
        const node = tt.node();
        const chartEl = document.getElementById('chart');
        const clickedInsideTooltip = node && node.contains(e.target);
        const clickedInsideChart = chartEl && chartEl.contains(e.target);

        // Always let chart-specific handlers manage chart clicks (vertices, axes, background)
        // This avoids a race on first desktop click where the doc handler would dismiss before pinning.
        if (clickedInsideChart) return;

        // If tooltip is pinned on desktop, only hide it when the click is outside both the tooltip and the chart area.
        if (state.ttPinned && !prefersSheet()) {
          if (!clickedInsideTooltip) { state.pagerActive = null; hideTT(); }
          return;
        }
        // On mobile, if the bottom sheet is open and the user clicks within the sheet,
        // do nothing (preserve selection). Sheet clicks are already stopped above, but keep this guard.
        if (prefersSheet() && sheetEl && sheetEl.classList.contains('open')) {
          if (sheetEl.contains(e.target)) { e.stopPropagation(); return; }
        }
        // default behavior: if click is outside the tooltip, close it (clear pager state)
        if (node && !clickedInsideTooltip) {
          state.pagerActive = null;
          hideTT();
        }
      });
    }

    // Theme handling: toggle and persist theme in localStorage
    const themeKey = 'pv_theme';
    function applyTheme(t) { if (t === 'dark') document.documentElement.setAttribute('data-theme', 'dark'); else document.documentElement.removeAttribute('data-theme'); }
    function initTheme() {
      const stored = localStorage.getItem(themeKey); if (stored) { applyTheme(stored); d3.select('#themeToggle').attr('aria-pressed', stored === 'dark' ? 'true' : 'false'); } else {
        // respect prefers-color-scheme as default
        const prefers = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light'; applyTheme(prefers); d3.select('#themeToggle').attr('aria-pressed', prefers === 'dark' ? 'true' : 'false');
      }
      d3.select('#themeToggle').on('click', () => {
        const cur = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'light';
        const next = cur === 'dark' ? 'light' : 'dark';
        applyTheme(next);
        localStorage.setItem(themeKey, next);
        d3.select('#themeToggle').attr('aria-pressed', next === 'dark' ? 'true' : 'false');
        // If a specific vertex is currently selected, reapply highlight so ring fill tones
        // update according to the new theme (dark-only effect). Otherwise do nothing.
        try {
          if (state && state.activeVertex && state.activeVertex.hypId && state.activeVertex.critId && typeof highlightSeries === 'function') {
            highlightSeries(state.activeVertex.hypId, state.activeVertex.critId);
          } else if (!state.activeVertex) {
            // ensure default look remains (especially when switching from dark->light)
            d3.selectAll('.vertices .vertex-ring').attr('fill', '#fff');
          }
        } catch (e) { /* ignore */ }
      });
    }
    // initialize theme immediately so colors are correct before UI paints
    try { initTheme(); } catch (e) {/* ignore */ }

    // Color palettes for light and dark modes (map by hypothesis id)
    const Palettes = {
      light: {
        resurrection: '#1f77b4',
        hallucination: '#2ca02c',
        theft: '#ff7f0e',
        wrongTomb: '#17becf',
        displaced: '#9467bd',
        swoon: '#d62728',
        legend: '#bcbd22'
      },
      dark: {
        resurrection: '#4fa8f7',
        hallucination: '#58d65b',
        theft: '#ffa64d',
        wrongTomb: '#4dd8e6',
        displaced: '#b085f5',
        swoon: '#ff4d4d',
        legend: '#e6c229'
      }
    };

    function currentPalette() { return document.documentElement.getAttribute('data-theme') === 'dark' ? Palettes.dark : Palettes.light; }
    function getColorFor(h) {
      // prefer explicit mapping in the palette, fall back to hypothesis.color in data
      const pal = currentPalette();
      if (pal && pal[h.id]) return pal[h.id];
      return h.color || '#999';
    }

    function quoteHTML(Hy, hypId, crit) {
      if (state.showQuotes !== true) return '';
      const a = (Hy[hypId].quotes && Hy[hypId].quotes[crit]) || null;
      const q = a && a[0];
      if (!q) return '';
      const safe = (q.t || '').replace(/\"/g, '&quot;');
      const srcHTML = q.url ? `<a href='${q.url}' target='_blank' rel='noopener'>${q.src || ''}</a>` : (q.src || '');
      return `<div class='q'>&ldquo;${safe}&rdquo;</div><div class='src'>— ${srcHTML}</div>`;
    }

    // Highlight a hypothesis series (polygon and pill) by id
    function highlightSeries(hypId, critId = null) {
      // record last active
      state.lastActiveHypothesis = hypId;
      state.activeVertex = critId ? { hypId, critId } : null;
      // cancel any pending clear timer
      if (state._highlightClearTimer) { clearTimeout(state._highlightClearTimer); state._highlightClearTimer = null; }
      // dim all polygons and pills, then highlight the selected
      d3.selectAll('.hyp-polygon').style('opacity', 0.12).style('filter', null);
      d3.selectAll('.pill').style('opacity', 0.5);
      // dim vertices (inner colored dots)
      d3.selectAll('.vertices .vertex-dot').style('opacity', 0.4).attr('r', d => Math.max(2, (d.baseR || 5) / (state.zoomK || 1)));
      // clear any leftover glow filters from previous selections
      d3.selectAll('.vertices .vertex').attr('filter', null);
      // emphasize the selected polygon and move it to the end of its parent so it renders on top of other polygons
      d3.selectAll('.hyp-polygon')
        .filter(function (d) { return d && d.id === hypId; })
        .style('opacity', 1)
        .style('filter', 'drop-shadow(0 6px 18px rgba(0,0,0,0.12))')
        .each(function () {
          try { this.parentNode.appendChild(this); } catch (e) { }
        });
      d3.selectAll('.pill').filter(function (d) { return d && d.id === hypId; }).style('opacity', 1);
      // reset any previous selected class
      d3.selectAll('.vertices .vertex').classed('selected', false);
      // restore normal state (not selected) for vertices of this hypothesis
      d3.selectAll('.vertices .vertex').filter(function (d) { return d && d.h && d.h.id === hypId; }).each(function (d) {
        const k = state.zoomK || 1;
        const baseDot = Math.max(2, (d.baseR || 5) / k);
        const baseRing = Math.max(4, (d.baseRing || 7) / k);
        d3.select(this).select('.vertex-dot').style('opacity', 1).attr('r', baseDot);
        d3.select(this).select('.vertex-ring')
          .attr('stroke', getColorFor(d.h))
          .attr('stroke-width', 2)
          .attr('r', baseRing);
      });
      // shrink non-selected hypotheses to the smallest dot size for clear contrast
      d3.selectAll('.vertices .vertex').filter(function (d) { return d && d.h && d.h.id !== hypId; }).each(function (d) {
        const k = state.zoomK || 1;
        const baseRing = Math.max(4, (d.baseRing || 7) / k);
        d3.select(this).select('.vertex-dot').style('opacity', 0.35).attr('r', 2).attr('fill', getColorFor(d.h));
        d3.select(this).select('.vertex-ring').attr('stroke', getColorFor(d.h)).attr('stroke-width', 2).attr('r', baseRing);
      });
      // In dark mode, when a specific vertex is selected, tone down the white fill of all
      // unselected vertex rings so they don't pop as bright white. Keep the selected one white.
      try {
        const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
        if (isDark) {
          // Tone down all unselected hypotheses; keep all points for the selected hypothesis white.
          d3.selectAll('.vertices .vertex').each(function (d) {
            const ring = d3.select(this).select('.vertex-ring');
            const inSelectedHyp = d && d.h && d.h.id === hypId;
            ring.attr('fill', inSelectedHyp ? '#fff' : 'rgba(255,255,255,0.12)');
          });
        } else {
          // Light mode: keep default white fill everywhere.
          d3.selectAll('.vertices .vertex-ring').attr('fill', '#fff');
        }
      } catch (e) { /* non-fatal */ }
      // emphasize only the selected vertex within the hypothesis, if provided
      if (critId) {
        const k = state.zoomK || 1;
        d3.selectAll('.vertices .vertex').filter(function (d) { return d && d.h && d.c && d.h.id === hypId && d.c.id === critId; }).classed('selected', true).each(function (d) {
          d3.select(this).raise();
          // apply soft glow matching the hypothesis color
          d3.select(this).attr('filter', `url(#glow-${d.h.id})`);
          // enlarge the inner dot and outer ring slightly so the white ring remains visible
          d3.select(this).select('.vertex-dot')
            .style('opacity', 1)
            .attr('r', Math.max(4, Math.max(2, (d.baseR || 5) / k) * SELECTED_DOT_SCALE))
            .attr('fill', getColorFor(d.h));
          d3.select(this).select('.vertex-ring')
            .attr('stroke', getColorFor(d.h))
            .attr('stroke-width', 3)
            .attr('r', Math.max(5, Math.max(4, (d.baseRing || 7) / k) * SELECTED_RING_SCALE));
        });
      }
      // Reorder all vertex groups so the selected hypothesis' vertices render on top
      try {
        d3.selectAll('.vertices .vertex').sort((a, b) => {
          const aa = a && a.h && a.h.id === hypId ? 1 : 0;
          const bb = b && b.h && b.h.id === hypId ? 1 : 0;
          return aa - bb; // selected (1) after non-selected (0) => on top
        });
      } catch (e) { }
    }

    function clearHighlight(immediate = false) {
      // delay returning to default to allow quick move to another vertex of same hypothesis
      if (state._highlightClearTimer) clearTimeout(state._highlightClearTimer);
      const run = () => {
        d3.selectAll('.hyp-polygon').style('opacity', null).style('filter', null);
        d3.selectAll('.pill').style('opacity', null);
        // reset all vertex dots to baseline size, color, and opacity
        d3.selectAll('.vertices .vertex-dot')
          .style('opacity', 1)
          .attr('r', d => Math.max(2, (d.baseR || 5) / (state.zoomK || 1)))
          .attr('fill', d => getColorFor(d.h));
        d3.selectAll('.vertices .vertex').classed('selected', false);
        // restore ring stroke & width for all vertices
        d3.selectAll('.vertices .vertex-ring')
          .attr('stroke', d => getColorFor(d.h))
          .attr('stroke-width', 2)
          // also restore the default white fill so the chart looks unchanged when nothing is selected
          .attr('fill', '#fff');
        // restore ring radius based on current zoom and remove glows
        const k = state.zoomK || 1;
        d3.selectAll('.vertices .vertex-ring').attr('r', d => Math.max(4, (d.baseRing || 7) / k));
        d3.selectAll('.vertices .vertex').attr('filter', null);
        state._highlightClearTimer = null;
        // reset lastActiveHypothesis after clearing
        state.lastActiveHypothesis = null;
        state.activeVertex = null;
      };
      if (immediate) { run(); }
      else { state._highlightClearTimer = setTimeout(run, 450); } // 450ms grace period
    }

    // Show a tooltip with pager controls for overlapping vertices
    function showPagedTooltip(list, startIndex, svgEl, br, sr) {
      let idx = startIndex || 0;
      // If pager is already active for the same list and index, avoid re-rendering
      const key = list.map(i => i.h.id + '@' + i.c.id).join('|');
      if (state.pagerActive && state.pagerActive.key === key && state.pagerActive.idx === idx) return;
      function renderAt(i) {
        const item = list[i];
        const level = ordinalLabel(item.c.id, item.raw, byId(Data.criteria));
        const note = (byId(Data.hypotheses)[item.h.id].notes || {})[item.c.id] || '';
        const qhtml = quoteHTML(byId(Data.hypotheses), item.h.id, item.c.id);
        const sw = `<span style='display:inline-block;width:10px;height:10px;border-radius:3px;background:${getColorFor(item.h)};margin:0 6px -1px 6px'></span>`;
        // pager at top to avoid vertical shift when content changes
        let content = `<div style='position:relative;display:flex;flex-direction:column;gap:8px;min-width:220px'>` +
          `<div style='display:flex;align-items:center;gap:12px'>` +
          `<div style='font-weight:600;flex:1 1 auto'>Hypothesis ${i + 1}/${list.length}</div>` +
          `<div style='display:flex;align-items:center;gap:6px;flex:0 0 auto'>` +
          `<button id='pager-left' aria-label='Previous' style='width:32px;height:32px'>&#9664;</button>` +
          `<button id='pager-right' aria-label='Next' style='width:32px;height:32px'>&#9654;</button>` +
          `</div>` +
          `</div>` +
          `<div id='pager-body' style='min-height:56px'>` +
          `<div style='font-weight:600;display:flex;align-items:center;gap:6px'><span style='display:inline-block;width:10px;height:10px;border-radius:3px;background:${getColorFor(item.h)}'></span><span>${item.h.label}</span></div>` +
          `<div><strong>Criteria:</strong> ${item.c.label}</div>` +
          `<div><strong>Level:</strong> ${level}</div>`;
        if (note) content += `<div style='margin-top:4px;color:var(--muted)'>${note}</div>`;
        content += qhtml;
        content += `</div></div>`;
        
        // If tooltip has been manually moved by user, update content in place
        const ttNode = tt.node();
        const hasMoved = state.ttUserMoved && state.ttPos.left !== null && state.ttPos.top !== null;
        if (hasMoved && ttNode) {
          // Just update the HTML content without repositioning
          tt.html(content);
        } else {
          // Normal positioning for initial show or unpinned tooltips
          showTTAt(content, svgEl, (br.left + br.width / 2) - sr.left, (br.top + br.height / 2) - sr.top, -10);
        }
        
        // Update tooltip color to match current hypothesis
        setTooltipColor(getColorFor(item.h));
        // highlight current series and selected vertex
        highlightSeries(item.h.id, item.c.id);
        // Update leader line to reflect new color
        updateLeaderLine();
        // wire pager buttons (delegated via document since TT content is HTML string)
        setTimeout(() => {
          const left = document.getElementById('pager-left');
          const right = document.getElementById('pager-right');
          if (left) {
            // stop propagation so the document click handler doesn't close the tooltip
            left.addEventListener('click', (ev) => { ev.stopPropagation(); idx = (idx - 1 + list.length) % list.length; renderAt(idx); });
          }
          if (right) {
            right.addEventListener('click', (ev) => { ev.stopPropagation(); idx = (idx + 1) % list.length; renderAt(idx); });
          }

        }, 0);
      }
      renderAt(idx);
      // mark pager as active so hover handlers won't override it
      state.pagerActive = { key, ids: list.map(i => i.h.id), idx };
    }

    function render() {
      const el = document.getElementById('chart'); d3.select(el).selectAll('*').remove();
      const C = byId(Data.criteria), Hy = byId(Data.hypotheses);
      if (state.view === 'radar') renderRadar(el, C, Hy); else renderHeatmap(el, C, Hy);
      // reapply last D3 transform after re-render so pan/zoom (including bumps) persist
      try {
        if (state.lastTransform && state.currentSvg && state.currentZoom) {
          state.currentSvg.call(state.currentZoom.transform, state.lastTransform);
          // clear any leftover inline transform on the chart root so we don't double-apply visual shifts
          try { if (state.chartRoot && state.chartRoot.style) { state.chartRoot.style.transform = ''; state.chartRoot.dataset.shift = ''; } } catch (_e) { }
        }
      } catch (e) { }
      
      // Rebuild tab order after DOM changes
      setTimeout(() => setupTabOrder(), 100);
    }

    // ---------- Radar
    function renderRadar(container, C, Hy) {
      const w = container.clientWidth, h = container.clientHeight;
      // responsive typography: bigger base on desktop, smaller floor on mobile
      const baseTextFont = (w >= 1280) ? 15 : (w >= 1024) ? 14 : (w >= 768) ? 13 : 12; // axis labels
      const baseLevelFont = (w >= 1280) ? 12 : (w >= 1024) ? 11 : (w >= 768) ? 10.5 : 10; // ring labels
  // responsive padding: with wrapped labels we can afford smaller horizontal padding on phones
  // Add a bit more vertical breathing room on desktop so the top-most ring/labels aren't clipped
  // (mobile retains the original spacing to keep the compact layout).
  const padY = 36 + (isMobile() ? 0 : 20);
      // On narrow screens, keep a bit more horizontal padding so there is comfortable edge whitespace
      const padX = (w < 520)
        ? Math.max(32, Math.min(90, Math.round(w * 0.15)))
        : Math.max(40, Math.min(120, Math.round(w * 0.18)));
      const r = Math.min(w / 2 - padX, h / 2 - padY);
      // create an SVG with a viewBox so it scales nicely and we can apply transforms
      const svg = d3.select(container).append('svg')
        .attr('width', w).attr('height', h)
        .attr('viewBox', `0 0 ${w} ${h}`)
        .style('touch-action', 'none');
      // Define soft glow filters (one per hypothesis color)
      const defs = svg.append('defs');
      try {
        (Data && Data.hypotheses ? Data.hypotheses : []).forEach(h => {
          const col = getColorFor(h);
          const f = defs.append('filter')
            .attr('id', `glow-${h.id}`)
            .attr('x', '-60%').attr('y', '-60%')
            .attr('width', '220%').attr('height', '220%');
          f.append('feGaussianBlur').attr('in', 'SourceAlpha').attr('stdDeviation', 2.6).attr('result', 'blur');
          f.append('feFlood').attr('flood-color', col).attr('flood-opacity', 0.55).attr('result', 'flood');
          f.append('feComposite').attr('in', 'flood').attr('in2', 'blur').attr('operator', 'in').attr('result', 'colored');
          const m = f.append('feMerge');
          m.append('feMergeNode').attr('in', 'colored');
          m.append('feMergeNode').attr('in', 'SourceGraphic');
        });
      } catch (e) { /* non-fatal */ }
      // Allow browser pinch zoom globally; only chart D3 gestures use pointer events via touch-action:none on container.
      // track pointer presence over chart to control tooltip auto-hide
      svg.on('mouseenter', () => { state.isOverChart = true; clearTimeout(hideTimer); }).on('mouseleave', () => { state.isOverChart = false; scheduleHide(); });
      // viewport receives the zoom transform; content is centered inside the viewport so zooming is anchored to cursor
      const viewport = svg.append('g');
      // chart content root
      const chartRoot = viewport.append('g');
      state.chartRoot = chartRoot.node();
      const g = chartRoot.append('g').attr('transform', `translate(${w / 2},${h / 2})`);
      // remember chart center and svg size so openSheet can compute exact screen coords from datum
      try { state.chartCenter = { cx: w / 2, cy: h / 2 }; state.svgSize = { w, h }; } catch (_e) { }
      // keep references to the svg and zoom so we can reapply transforms after re-render
      state.currentSvg = svg;
      // state.currentZoom will be set after zoom is created

      // D3 zoom: apply transform to viewport so zoom is centered on pointer location
      // Configure zoom. We'll apply the transform to the viewport group, then inverse-scale
      // certain visual attributes (node radii, text font-sizes) so they remain legible on screen.
      const zoom = d3.zoom().scaleExtent([0.6, 4]).on('zoom', (e) => {
        // Apply viewport zoom transform and update zoomK; do not mutate stored screen-pixel shift here
        viewport.attr('transform', e.transform);
        const k = e.transform.k || 1;
        state.zoomK = k;
        // remember the last applied D3 transform so bumps and re-renders can reapply it
        try { state.lastTransform = e.transform; } catch (err) { }
        // inverse-scale vertex dot radii so dots stay approximately the same screen size
        try {
          g.selectAll('.vertex-dot').attr('r', function (d) {
            // store base radius on datum if not present
            d.baseR = d.baseR || 5;
            // base inverse-scaled radius so dots stay approximately the same screen size
            const base = Math.max(2, d.baseR / k);
            // If a precise vertex is actively highlighted (from tooltip/pager or open mobile sheet),
            // or the DOM group has the 'selected' class, keep it emphasized.
            const active = (state.activeVertex || ((sheetEl && sheetEl.classList.contains('open')) ? state.sheetActiveVertex : null));
            let isActiveVertex = active && active.hypId === d.h.id && active.critId === d.c.id;
            if (!isActiveVertex) {
              try { const v = this.closest && this.closest('.vertex'); if (v && v.classList && v.classList.contains('selected')) isActiveVertex = true; } catch (_e) { }
            }
            // If a hypothesis series is highlighted (but not a single vertex), shrink other hypotheses' dots
            const inActiveSeries = state.lastActiveHypothesis && state.lastActiveHypothesis === d.h.id;
            if (isActiveVertex) {
              return Math.max(4, base * SELECTED_DOT_SCALE);
            }
            if (state.lastActiveHypothesis) {
              // non-highlighted series should be visually de-emphasized
              return inActiveSeries ? base : 2;
            }
            return base;
          });
          // outer ring radius: keep screen size steady, and enlarge if this vertex is the active one
          g.selectAll('.vertex-ring').attr('r', function (d) {
            d.baseRing = d.baseRing || 7;
            const base = Math.max(4, d.baseRing / k);
            const active = (state.activeVertex || ((sheetEl && sheetEl.classList.contains('open')) ? state.sheetActiveVertex : null));
            let isActiveVertex = active && active.hypId === d.h.id && active.critId === d.c.id;
            if (!isActiveVertex) {
              try { const v = this.closest && this.closest('.vertex'); if (v && v.classList && v.classList.contains('selected')) isActiveVertex = true; } catch (_e) { }
            }
            return isActiveVertex ? Math.max(5, (d.baseRing / k) * SELECTED_RING_SCALE) : base;
          });
          // dimension (axis-end) nodes: inverse-scale like hypothesis nodes
          g.selectAll('.axis-dot').attr('r', d => { d.baseAxisR = d.baseAxisR || 5; const base = Math.max(3, d.baseAxisR / k); return (state.activeAxisId && state.activeAxisId === d.id) ? Math.max(4, base * AXIS_SELECTED_SCALE) : base; })
            .attr('stroke-width', d => (state.activeAxisId && state.activeAxisId === d.id) ? 3 : 2);
          // keep larger hit-targets a constant on-screen size for both vertices and axis markers
          g.selectAll('.hit-target').attr('r', d => { d.baseHit = d.baseHit || (prefersSheet() ? 18 : 10); return Math.max(8, d.baseHit / k); });
          g.selectAll('.axis-hit').attr('r', d => { d.baseAxisHit = d.baseAxisHit || (prefersSheet() ? 18 : 10); return Math.max(8, d.baseAxisHit / k); });
          // adjust level/axis label font sizes so they remain readable;
          // on small viewports allow slightly smaller minimums when zooming in so central labels don't overlap
          const minLevelFont = (w < 520) ? 5.5 : 8; // px (smaller floor on phones)
          const minTextFont = (w < 520) ? 7.5 : 10;  // px
          g.selectAll('.level-label').style('font-size', d => (k > 1 ? Math.max(minLevelFont, baseLevelFont / k) : baseLevelFont) + 'px');
          g.selectAll('g > text').filter(function () { return d3.select(this).classed('level-label') ? false : true; })
            .style('font-size', d => (k > 1 ? Math.max(minTextFont, baseTextFont / k) : baseTextFont) + 'px');
          // Force-apply selected sizing and glow to the active vertex so pan/zoom can't reduce it
          const active = (state.activeVertex || ((sheetEl && sheetEl.classList.contains('open')) ? state.sheetActiveVertex : null));
          if (active) {
            const selV = g.selectAll('.vertex').filter(d => d && d.h && d.c && d.h.id === active.hypId && d.c.id === active.critId);
            selV.each(function (d) {
              try { d3.select(this).raise(); } catch (e) { }
              d3.select(this).attr('filter', `url(#glow-${d.h.id})`);
              d3.select(this).select('.vertex-dot').attr('r', Math.max(4, Math.max(2, (d.baseR || 5) / k) * SELECTED_DOT_SCALE));
              d3.select(this).select('.vertex-ring').attr('r', Math.max(5, Math.max(4, (d.baseRing || 7) / k) * SELECTED_RING_SCALE)).attr('stroke-width', 3).attr('stroke', getColorFor(d.h)).attr('fill', '#fff');
            });
          }
        } catch (err) { /* ignore minor runtime adjustments */ }
      });
      // remember zoom instance so other code can programmatically change the transform
      state.currentZoom = zoom;
      // on zoom end ensure lastTransform is current (helps when programmatically animating transforms)
      zoom.on('end', (e) => { try { state.lastTransform = e.transform; } catch (err) { } });
      // Only enable zoom when interacting with the SVG background (not when interacting with interactive elements)
      svg.call(zoom.filter(function (event) {
        const t = event.target;
        // Disable zoom when interacting with interactive overlays: vertices, legend pills,
        // and the axis-end hit targets so tooltips/bottom sheets are not interfered with.
        const insideVertices = t.closest && t.closest('.vertices');
        const insidePills = t.closest && t.closest('.pill');
        const onAxisHit = t.closest && t.closest('.axis-hit');
        if (insideVertices || insidePills || onAxisHit) return false;
        return t === svg.node() || t.tagName === 'svg' || (t.closest && !t.closest('.vertices') && !t.closest('.pill'));
      }));
      // double-click to reset zoom
      svg.on('dblclick', () => { svg.transition().duration(350).call(zoom.transform, d3.zoomIdentity); });
      // single click on empty chart area should clear current highlight (mobile/desktop)
      svg.on('click.background-clear', (e) => {
        const tgt = e.target;
        try {
          if (tgt && tgt.closest && (tgt.closest('.vertex') || tgt.closest('#tt'))) return;
        } catch (err) { }
        // On mobile: if the bottom sheet is open and the user taps empty chart space,
        // dismiss the sheet and clear the highlight.
        if (prefersSheet() && sheetEl && sheetEl.classList.contains('open')) {
          closeSheet();
          hideTT();
          clearHighlight(true);
          e.stopPropagation();
          return;
        }
        // Desktop or when no sheet is open: clear as before
        hideTT();
        clearHighlight(true);
        // prevent document-level handlers from double-processing this background click
        try { e.stopPropagation(); } catch (_e) { }
      });
      // Auto-close controls on first chart interaction (pointerdown/zoom) when mobile
      function maybeCloseControls() { if (isMobile() && topbar && topbar.dataset.state === 'expanded') { setControls(false); } }
      svg.on('pointerdown.closecontrols', maybeCloseControls);
      svg.on('wheel.closecontrols', maybeCloseControls, { passive: true });
      svg.on('touchstart.closecontrols', maybeCloseControls);
      // hide tooltip when pointer leaves the active hypothesis polygon
      svg.on('mousemove.pointercheck', (event) => {
        // On mobile when the bottom sheet is open, keep the highlight even if the pointer moves outside
        // the polygon as the user pans/zooms; otherwise we create a confusing third state.
        if (prefersSheet() && sheetEl && sheetEl.classList.contains('open')) return;
        if (!state.lastActiveHypothesis) return;
        const poly = state.currentPolygons && state.currentPolygons[state.lastActiveHypothesis];
        if (!poly) return;
        // if pointer is over a vertex or the tooltip, don't hide (prevents races)
        const el = document.elementFromPoint(event.clientX, event.clientY);
        try {
          if (el && el.closest && (el.closest('.vertices') || el.closest('#tt'))) { return; }
        } catch (e) { }
        const rect = svg.node().getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;
        if (!pointInPoly(x, y, poly)) {
          // schedule an immediate hide that ignores isOverChart but respects if pointer moved into tooltip
          // If tooltip is pinned on desktop, do not auto-hide here.
          if (state.ttPinned && !prefersSheet()) return;
          // If on mobile and a bottom sheet is open, keep the highlight.
          if (prefersSheet() && sheetEl && sheetEl.classList.contains('open')) return;
          setTimeout(() => {
            // If tooltip was pinned in the meantime (e.g., from a click), don't hide
            if (state.ttPinned && !prefersSheet()) return;
            const el2 = document.elementFromPoint(event.clientX, event.clientY);
            if (!(el2 && el2.closest && el2.closest('#tt'))) { state.pagerActive = null; hideTT(); }
          }, 40);
        }
      });
      const axes = Data.criteria.map((d, i) => { const ang = (Math.PI * 2 * i) / Data.criteria.length - Math.PI / 2; return { ...d, idx: i, angle: ang, x: Math.cos(ang), y: Math.sin(ang) }; });
      const rScale = d3.scaleLinear().domain([0, 1]).range([0, r]);

      // grid + axes (no pointer capture)
      const grid = g.append('g').style('pointer-events', 'none');
      grid.selectAll('circle').data([0.25, 0.5, 0.75]).join('circle').attr('r', d => rScale(d)).attr('fill', 'none').style('stroke', 'var(--line)');
      // level labels along each axis using the criterion anchors (Low/Medium/High)
      const levels = [0.25, 0.5, 0.75];
      const levelLabels = axes.flatMap(a => levels.map((lv, i) => ({ axis: a, lv, i })));
      const labelOffset = 12; // pixels inward from the ring intersection
      grid.selectAll('.level-label').data(levelLabels).join('text')
        .attr('class', 'level-label')
        .attr('x', d => d.axis.x * (rScale(d.lv) - labelOffset))
        .attr('y', d => d.axis.y * (rScale(d.lv) - labelOffset))
        .attr('font-size', baseLevelFont)
        .style('fill', 'var(--muted)')
        .attr('text-anchor', 'middle')
        .attr('dominant-baseline', 'central')
        .text(d => (d.axis.anchors && d.axis.anchors[d.i]) ? d.axis.anchors[d.i] : '');
      const ax = g.append('g').selectAll('g').data(axes).join('g').style('pointer-events', 'none');
      ax.append('line').attr('x1', 0).attr('y1', 0).attr('x2', d => d.x * r).attr('y2', d => d.y * r).style('stroke', 'var(--line)');
      // helper to wrap axis labels into multiple lines within a max width and vertically center them
      function wrapAxisLabels(sel, maxWidthPx, lineHeightEm = 1.1) {
        sel.each(function () {
          const text = d3.select(this);
          const full = (text.text() || '').trim();
          if (!full) return;
          const words = full.split(/\s+/).filter(Boolean);
          const x = text.attr('x');
          const y = text.attr('y');
          // clear and rebuild with tspans
          text.text(null);
          let tspan = text.append('tspan').attr('x', x).attr('y', y);
          const tspans = [];
          let line = [];
          for (let i = 0; i < words.length; i++) {
            const wds = line.concat([words[i]]);
            tspan.text(wds.join(' '));
            const len = tspan.node() && tspan.node().getComputedTextLength ? tspan.node().getComputedTextLength() : 0;
            if (len > maxWidthPx && line.length) {
              // commit previous line and start a new one with current word
              tspan.text(line.join(' '));
              tspans.push(tspan);
              line = [words[i]];
              tspan = text.append('tspan').attr('x', x).attr('y', y).text(words[i]);
            } else {
              line = wds;
            }
          }
          tspans.push(tspan);
          // center lines vertically around the anchor point
          const n = tspans.length;
          for (let i = 0; i < n; i++) {
            const dy = (i - (n - 1) / 2) * lineHeightEm;
            tspans[i].attr('dy', dy + 'em');
          }
        });
      }
      // axis labels with word-wrap; use a smaller max width on phones
      const maxLabelWidth = (w < 520) ? 78 : 120; // pixels
      ax.append('text')
        .attr('x', d => {
          // push specific axis labels slightly further out so they don't collide with the axis-end markers
          const extra = (d.idx === 0 || d.idx === 4) ? 24 : 14;
          return d.x * (r + extra);
        })
        .attr('y', d => {
          const extra = (d.idx === 0 || d.idx === 4) ? 24 : 14;
          return d.y * (r + extra);
        })
        .attr('text-anchor', d => Math.abs(d.x) < 0.3 ? 'middle' : (d.x > 0 ? 'start' : 'end'))
        .attr('dominant-baseline', 'central').attr('font-size', baseTextFont)
        .text(d => d.short)
        .call(wrapAxisLabels, maxLabelWidth);

      const sel = Data.hypotheses.filter(h => state.selected.has(h.id));
      const pointsFor = (h) => axes.map(a => { const vv = quantize(Hy[h.id].scores[a.id]); const rr = rScale(vv); return [a.x * rr, a.y * rr]; });

      // polygons (no tooltip) -- record polygon points for pointer-in-polygon checks
      state.currentPolygons = {};
      g.append('g').selectAll('path').data(sel, d => d.id).join('path')
        .attr('class', 'hyp-polygon')
        .attr('d', d => d3.line().curve(d3.curveLinearClosed)(pointsFor(d)))
        .attr('fill', d => d3.color(getColorFor(d)).copy({ opacity: 0.15 }))
        .attr('stroke', d => getColorFor(d)).attr('stroke-width', 2)
        .each(function (d) {
          const pts = pointsFor(d).map(p => [p[0] + w / 2, p[1] + h / 2]);
          state.currentPolygons[d.id] = pts;
        });

      // axis-end info dots
      const helpG = g.append('g');
      // Larger invisible hit area for axis-end markers (improves touch usability)
      const axisHits = helpG.selectAll('circle.axis-hit').data(axes).join('circle')
        .attr('class', 'axis-hit')
        .attr('cx', d => d.x * r).attr('cy', d => d.y * r)
        .attr('r', () => (prefersSheet() ? 18 : 10))
        .style('fill', 'transparent')
        .style('stroke', 'none')
        .style('pointer-events', 'all')
        .attr('role', 'button')
        .attr('aria-label', d => `Criteria ${d.label}. Press Enter to open details.`)
        .on('mouseenter mousemove', (e, d) => {
          if (prefersSheet()) return; // ignore hover on mobile; tap opens
          // visually emphasize the axis-end while hovered
          try { state.activeAxisId = d.id; updateAxisSelection(); } catch (_) {}
          // Clear any lingering series highlight so the background pointer-in-polygon
          // check doesn’t auto-hide this axis tooltip.
          try { state.lastActiveHypothesis = null; state.activeVertex = null; clearHighlight(true); } catch (_) {}
          const html = `<div><strong>${d.label}</strong></div>` +
            `<div style='color:var(--muted)'>${d.desc || ''}</div>` +
            `<div style='margin-top:4px'>Levels: <strong>${d.anchors.join(' • ')}</strong></div>`;
          const svgEl = svg.node(); const br = getScreenRectForAnchor(e.currentTarget, svgEl) || e.currentTarget.getBoundingClientRect(); const sr = svgEl.getBoundingClientRect();
          showTTAt(html, svgEl, (br.left + br.width / 2) - sr.left, (br.top + br.height / 2) - sr.top, -10);
        })
        .on('mouseleave', (e) => {
          // If tooltip is pinned on desktop, keep it and the highlight
          if (state.ttPinned && !prefersSheet()) return;
          // Small delay; if the pointer moved into the tooltip itself, don't hide
          setTimeout(() => {
            const el2 = document.elementFromPoint(e.clientX, e.clientY);
            const overTT = el2 && el2.closest && el2.closest('#tt');
            if (!overTT) {
              try { state.activeAxisId = null; updateAxisSelection(); } catch (_) {}
              hideTT();
            }
          }, 40);
        })
        .on('focus', (e, d) => { 
          // Emphasize and open on focus just like a click/tap
          try { state.activeAxisId = d.id; updateAxisSelection(); } catch (_) {}
          try {
            const evt = new MouseEvent('click', { bubbles: true, cancelable: true, view: window });
            e.currentTarget.dispatchEvent(evt);
          } catch (_) {}
        })
  .on('blur', () => { try { state.activeAxisId = null; updateAxisSelection(); } catch (_) {} })
        .on('click', (e, d) => {
          // Ensure any pending hide from hover/mouseleave is cancelled before pinning
          try { clearTimeout(hideTimer); } catch(_) {}
          // Prevent the background SVG click handler from immediately closing the sheet/tooltip
          try { e.stopPropagation(); } catch (_) {}
          // Also clear any prior series highlight to avoid conflicting states
          try { state.lastActiveHypothesis = null; state.activeVertex = null; clearHighlight(true); } catch (_) {}
          // Mobile: open bottom-sheet as before
          if (prefersSheet()) {
            const html = `<h3>${d.label}</h3><div class='sheet-meta'>Axis</div><p style='margin-top:6px'>${d.desc || ''}</p><p style='margin-top:8px'><strong>Levels</strong>: ${d.anchors.join(' • ')}</p>`;
            const anchorEl = e.currentTarget;
            openSheet(html, null, anchorEl);
            try { state.activeAxisId = d.id; updateAxisSelection(); } catch (_) {}
            return;
          }
          // Desktop: show tooltip and pin it (clicking the marker should pin the axis tooltip)
          const html = `<div><strong>${d.label}</strong></div>` +
            `<div style='color:var(--muted)'>${d.desc || ''}</div>` +
            `<div style='margin-top:4px'>Levels: <strong>${d.anchors.join(' • ')}</strong></div>`;
          const svgEl = svg.node();
          const br = getScreenRectForAnchor(e.currentTarget, svgEl) || e.currentTarget.getBoundingClientRect();
          const sr = svgEl.getBoundingClientRect();
          
          // Check if there's a stored tooltip position from a previous user drag
          const hasMoved = state.ttUserMoved && state.ttPos.left !== null && state.ttPos.top !== null;
          if (hasMoved) {
            // Use the stored position and just update content
            tt.html(html).style('display', 'block');
            const ttNode = tt.node();
            if (ttNode) {
              ttNode.style.left = state.ttPos.left + 'px';
              ttNode.style.top = state.ttPos.top + 'px';
            }
          } else {
            // Normal positioning for first show
            showTTAt(html, svgEl, (br.left + br.width / 2) - sr.left, (br.top + br.height / 2) - sr.top, -10);
          }
          
          try { state.activeAxisId = d.id; updateAxisSelection(); } catch (_) {}
          // Pin the tooltip and show the blocker (no color for axis tooltips, use default)
          clearTooltipColor();
          // Set anchor to the center of the axis marker
          state.ttAnchor.x = br.left + br.width / 2;
          state.ttAnchor.y = br.top + br.height / 2;
          state.ttPinned = true; tt.classed('pinned', true); showTTBlocker(); clearTimeout(hideTimer);
          // Suppress late document clicks and hides briefly after first pin
          try { const t = Date.now() + 250; state._suppressClickUntil = t; state._suppressHideUntil = t; } catch(_) {}
          updateLeaderLine();
        })
        .on('keydown', (e, d) => {
          // Keyboard access for axis endpoints
          if (e.key === 'Enter' || e.key === ' ') {
            e.preventDefault();
            const evt = new MouseEvent('click', { bubbles: true, cancelable: true, view: window });
            e.currentTarget.dispatchEvent(evt);
          }
          // Up/Down navigate to previous/next axis (criterion)
          if (e.key === 'ArrowUp' || e.key === 'ArrowLeft' || e.key === 'ArrowDown' || e.key === 'ArrowRight') {
            e.preventDefault();
            const dir = (e.key === 'ArrowUp' || e.key === 'ArrowLeft') ? -1 : 1;
            const curIdx = (typeof d.idx === 'number') ? d.idx : axes.findIndex(a => a.id === d.id);
            const next = axes[(curIdx + dir + axes.length) % axes.length];
            // move DOM focus to next axis hit target
            try {
              const node = d3.select('#chart svg').selectAll('.axis-hit').filter(x => x && x.id === next.id).node();
              if (node && node.focus) node.focus();
            } catch (_) {}
          }
        });
      // Draw the visual axis-end dots as a separate selection so we don't overwrite
      // the interactive hit targets above (which would remove their pointer events).
      helpG.selectAll('circle.axis-dot').data(axes).join('circle')
        .attr('class', 'axis-dot')
        .each(function(d){ d.baseAxisR = d.baseAxisR || 5; })
        .attr('cx', d => d.x * r).attr('cy', d => d.y * r).attr('r', 5)
        .style('fill', 'var(--panel-bg)').style('stroke', 'var(--muted)').attr('stroke-width', 2)
        .style('pointer-events', 'none');
      // apply initial axis selection sizing, if any
      try { updateAxisSelection(); } catch (_) {}

      // vertex dots
  const vertexData = sel.flatMap(hh => axes.map(a => { const raw = Hy[hh.id].scores[a.id]; const vv = quantize(raw); const rr = rScale(vv); return { h: hh, c: a, raw, x: a.x * rr, y: a.y * rr }; }));
      const vwrap = g.append('g').attr('class', 'vertices').selectAll('g.vertex').data(vertexData).join('g').attr('class', 'vertex')
        .attr('transform', d => `translate(${d.x},${d.y})`)
        .style('cursor', 'pointer')
        .attr('role', 'button')
        .attr('aria-label', d => `Hypothesis ${d.h.label}, criteria ${d.c.label}. Press Enter to open details, Left/Right to switch hypothesis, Up/Down to change criteria.`)
        .on('focus', function(e, d) {
          // Open on focus (keyboard tab) just like a click; this pins on desktop and opens sheet on mobile
          try {
            const evt = new MouseEvent('click', { bubbles: true, cancelable: true, view: window });
            this.dispatchEvent(evt);
          } catch (_) {}
        })
        .on('mouseenter mousemove', (e, d) => {
          if (prefersSheet()) return; // disable hover tooltips on mobile; use tap
          const svgEl = svg.node(); const br = getScreenRectForAnchor(e.currentTarget, svgEl) || e.currentTarget.getBoundingClientRect(); const sr = svgEl.getBoundingClientRect();
          // find overlapping vertices (tolerance in local coords, inverse-scaled by zoom)
          const tol = (prefersSheet() ? 10 : 3.5) / (state.zoomK || 1); // wider tolerance for touch
          const overlapping = vertexData.filter(v => Math.hypot(v.x - d.x, v.y - d.y) <= tol);
          // If a pager is active for this group, don't let normal hover override it
          if (state.pagerActive) { const key = overlapping.map(i => i.h.id + '@' + i.c.id).join('|'); if (state.pagerActive.key === key) return; }
          if (overlapping.length > 1) {
            // prefer lastActiveHypothesis when choosing start index
            let startIdx = overlapping.findIndex(v => v.h.id === d.h.id && v.c.id === d.c.id);
            if (state.lastActiveHypothesis) { const pref = overlapping.findIndex(v => v.h.id === state.lastActiveHypothesis); if (pref >= 0) startIdx = pref; }
            // show pager on hover (don't pin)
            showPagedTooltip(overlapping, startIdx, svgEl, br, sr);
            return;
          }
          const level = ordinalLabel(d.c.id, d.raw, byId(Data.criteria));
          const note = (byId(Data.hypotheses)[d.h.id].notes || {})[d.c.id] || '';
          const qhtml = quoteHTML(byId(Data.hypotheses), d.h.id, d.c.id);
          const html = `<div style='font-weight:600;display:flex;align-items:center;gap:6px'><span style='display:inline-block;width:10px;height:10px;border-radius:3px;background:${getColorFor(d.h)}'></span><span>${d.h.label}</span></div>` +
            `<div><strong>Criteria:</strong> ${d.c.label}</div>` +
            `<div><strong>Level:</strong> ${level}</div>` +
            (note ? `<div style='margin-top:4px;color:var(--muted)'>${note}</div>` : '') + qhtml;
          showTTAt(html, svgEl, (br.left + br.width / 2) - sr.left, (br.top + br.height / 2) - sr.top, -10);
          highlightSeries(d.h.id, d.c.id);
        })
        .on('mouseleave', () => { if (!prefersSheet()) scheduleHide(); })
        // tap/click (mobile) opens bottom sheet
        .on('click', (e, d) => {
          // Cancel any pending tooltip auto-hide before we pin
          try { clearTimeout(hideTimer); } catch(_) {}
          e.stopPropagation();
          const tol = (prefersSheet() ? 10 : 3.5) / (state.zoomK || 1);
          const overlapping = vertexData.filter(v => Math.hypot(v.x - d.x, v.y - d.y) <= tol);
          const C = byId(Data.criteria);
          const svgEl = state.currentSvg && state.currentSvg.node() ? state.currentSvg.node() : document.querySelector('#chart svg');
          const br = getScreenRectForAnchor(e.currentTarget, svgEl) || e.currentTarget.getBoundingClientRect();
          const sr = svgEl ? svgEl.getBoundingClientRect() : document.body.getBoundingClientRect();
          // On desktop, clear any stale pager session; when switching from a single pinned tooltip
          // back to a paged overlap group (or vice versa), a leftover pagerActive can short-circuit
          // rendering. The paged tooltip will set a fresh pagerActive as needed below.
          if (!prefersSheet()) { state.pagerActive = null; }
          if (prefersSheet()) {
            // mobile: existing bottom-sheet behavior
            if (overlapping.length > 1) {
              let idx = overlapping.findIndex(v => v.h.id === d.h.id && v.c.id === d.c.id);
              if (idx < 0) idx = 0;
              function sheetContent(i) {
                const it = overlapping[i];
                const level = ordinalLabel(it.c.id, it.raw, C);
                const note = (byId(Data.hypotheses)[it.h.id].notes || {})[it.c.id] || '';
                const qhtml = quoteHTML(byId(Data.hypotheses), it.h.id, it.c.id);
                return `<div class='with-pager'>` +
                  `<div class='hdr'><div class='hdr-left'><div class='pager-info'>Hypothesis ${i + 1}/${overlapping.length}</div><div class='pager'><button type='button' class='pg-left' aria-label='Previous'>&#9664;</button><button type='button' class='pg-right' aria-label='Next'>&#9654;</button></div></div><button type='button' class='hdr-close' aria-label='Close'>×</button></div>` +
                  `<h3 style='margin:0 0 4px 0;display:flex;align-items:center;gap:8px'><span style='display:inline-block;width:12px;height:12px;border-radius:3px;background:${getColorFor(it.h)}'></span><span>${it.h.label}</span></h3>` +
                  `<div><strong>Criteria:</strong> ${it.c.label}</div>` +
                  `<div><strong>Level:</strong> ${level}</div>` +
                  (note ? `<div style='margin-top:6px;color:var(--muted)'>${note}</div>` : '') + qhtml + `</div>`;
              }
              if (sheetEl) sheetEl.classList.add('has-inline-close');
              const anchorEl = e.currentTarget;
              openSheet(sheetContent(idx), { hypId: overlapping[idx].h.id, critId: overlapping[idx].c.id }, anchorEl);
              function wirePager() {
                if (!sheetInner) return; const l = sheetInner.querySelector('.pg-left'); const r = sheetInner.querySelector('.pg-right');
                if (l) l.onclick = ev => { ev.stopPropagation(); idx = (idx - 1 + overlapping.length) % overlapping.length; sheetInner.innerHTML = sheetContent(idx); wirePager(); highlightSeries(overlapping[idx].h.id, overlapping[idx].c.id); state.sheetActiveVertex = { hypId: overlapping[idx].h.id, critId: overlapping[idx].c.id }; };
                if (r) r.onclick = ev => { ev.stopPropagation(); idx = (idx + 1) % overlapping.length; sheetInner.innerHTML = sheetContent(idx); wirePager(); highlightSeries(overlapping[idx].h.id, overlapping[idx].c.id); state.sheetActiveVertex = { hypId: overlapping[idx].h.id, critId: overlapping[idx].c.id }; };
                const x = sheetInner.querySelector('.hdr-close'); if (x) x.onclick = (ev) => { ev.stopPropagation(); closeSheet(); };
              }
              wirePager();
              // swipe gestures
              let startX = null; const area = sheetInner; if (area) {
                area.ontouchstart = ev => { if (ev.touches.length === 1) startX = ev.touches[0].clientX; };
                area.ontouchend = ev => { if (startX == null) return; const dx = (ev.changedTouches[0].clientX - startX); if (Math.abs(dx) > 50) { idx = (idx + (dx < 0 ? 1 : -1) + overlapping.length) % overlapping.length; sheetInner.innerHTML = sheetContent(idx); wirePager(); highlightSeries(overlapping[idx].h.id, overlapping[idx].c.id); } startX = null; };
              }
            } else {
              const level = ordinalLabel(d.c.id, d.raw, C);
              const note = (byId(Data.hypotheses)[d.h.id].notes || {})[d.c.id] || '';
              const qhtml = quoteHTML(byId(Data.hypotheses), d.h.id, d.c.id);
              const html = `<h3 style='display:flex;align-items:center;gap:8px'><span style='display:inline-block;width:12px;height:12px;border-radius:3px;background:${getColorFor(d.h)}'></span><span>${d.h.label}</span></h3>` +
                `<div><strong>Criteria:</strong> ${d.c.label}</div>` +
                `<div><strong>Level:</strong> ${level}</div>` + (note ? `<div style='margin-top:6px;color:var(--muted)'>${note}</div>` : '') + qhtml;
              if (sheetEl) sheetEl.classList.remove('has-inline-close');
              const anchorEl = e.currentTarget;
              openSheet(html, { hypId: d.h.id, critId: d.c.id }, anchorEl);
              state.sheetActiveVertex = { hypId: d.h.id, critId: d.c.id };
            }
          } else {
            // Desktop: clicking a marker pins the tooltip. Show the same content as hover/pager and pin it.
            if (overlapping.length > 1) {
              // show the paged tooltip and pin it
              let startIdx = overlapping.findIndex(v => v.h.id === d.h.id && v.c.id === d.c.id);
              if (startIdx < 0) startIdx = 0;
              showPagedTooltip(overlapping, startIdx, svgEl, br, sr);
              // pin with color of the currently shown hypothesis
              const currentHyp = overlapping[startIdx].h;
              setTooltipColor(getColorFor(currentHyp));
              // Set anchor to the center of the vertex marker (not tooltip position)
              state.ttAnchor.x = br.left + br.width / 2;
              state.ttAnchor.y = br.top + br.height / 2;
              state.ttPinned = true; tt.classed('pinned', true); showTTBlocker(); clearTimeout(hideTimer);
              // Suppress late document clicks and hides briefly after first pin
              try { const t = Date.now() + 250; state._suppressClickUntil = t; state._suppressHideUntil = t; } catch(_) {}
              updateLeaderLine();
            } else {
              const level = ordinalLabel(d.c.id, d.raw, C);
              const note = (byId(Data.hypotheses)[d.h.id].notes || {})[d.c.id] || '';
              const qhtml = quoteHTML(byId(Data.hypotheses), d.h.id, d.c.id);
              const html = `<div style='font-weight:600;display:flex;align-items:center;gap:6px'><span style='display:inline-block;width:10px;height:10px;border-radius:3px;background:${getColorFor(d.h)}'></span><span>${d.h.label}</span></div>` +
                `<div><strong>Criteria:</strong> ${d.c.label}</div>` +
                `<div><strong>Level:</strong> ${level}</div>` +
                (note ? `<div style='margin-top:4px;color:var(--muted)'>${note}</div>` : '') + qhtml;
              
              // Check if there's a stored tooltip position from a previous user drag
              const hasMoved = state.ttUserMoved && state.ttPos.left !== null && state.ttPos.top !== null;
              if (hasMoved) {
                // Use the stored position and just update content
                tt.html(html).style('display', 'block');
                const ttNode = tt.node();
                if (ttNode) {
                  ttNode.style.left = state.ttPos.left + 'px';
                  ttNode.style.top = state.ttPos.top + 'px';
                }
              } else {
                // Normal positioning for first show
                showTTAt(html, svgEl, (br.left + br.width / 2) - sr.left, (br.top + br.height / 2) - sr.top, -10);
              }
              
              highlightSeries(d.h.id, d.c.id);
              // pin with hypothesis color
              setTooltipColor(getColorFor(d.h));
              // Set anchor to the center of the vertex marker (not tooltip position)
              state.ttAnchor.x = br.left + br.width / 2;
              state.ttAnchor.y = br.top + br.height / 2;
              state.ttPinned = true; tt.classed('pinned', true); showTTBlocker(); clearTimeout(hideTimer);
              try { const t = Date.now() + 250; state._suppressClickUntil = t; state._suppressHideUntil = t; } catch(_) {}
              updateLeaderLine();
            }
          }
        });

      // Keyboard handlers for vertices: Enter/Space open tooltip/sheet; arrows navigate pager & criteria
      vwrap.on('keydown', function (e, d) {
        const svgEl = state.currentSvg && state.currentSvg.node ? state.currentSvg.node() : document.querySelector('#chart svg');
        if (!svgEl) return;
        const tol = (prefersSheet() ? 10 : 3.5) / (state.zoomK || 1);
        const overlapping = vertexData.filter(v => Math.hypot(v.x - d.x, v.y - d.y) <= tol);
        const sr = svgEl.getBoundingClientRect();
        const el = this; // current vertex group
        const br = getScreenRectForAnchor(el, svgEl) || (el.getBoundingClientRect ? el.getBoundingClientRect() : sr);

        // Helper to open/refresh a paged tooltip at index i
        const openPagerAt = (i) => {
          if (prefersSheet()) {
            // Mirror mobile behavior in sheet
            let idx = i;
            const Cmap = byId(Data.criteria);
            function sheetContent(ii) {
              const it = overlapping[ii];
              const level = ordinalLabel(it.c.id, it.raw, Cmap);
              const note = (byId(Data.hypotheses)[it.h.id].notes || {})[it.c.id] || '';
              const qhtml = quoteHTML(byId(Data.hypotheses), it.h.id, it.c.id);
              return `<div class='with-pager'>` +
                `<div class='hdr'><div class='hdr-left'><div class='pager-info'>Hypothesis ${ii + 1}/${overlapping.length}</div><div class='pager'><button type='button' class='pg-left' aria-label='Previous'>&#9664;</button><button type='button' class='pg-right' aria-label='Next'>&#9654;</button></div></div><button type='button' class='hdr-close' aria-label='Close'>×</button></div>` +
                `<h3 style='margin:0 0 4px 0;display:flex;align-items:center;gap:8px'><span style='display:inline-block;width:12px;height:12px;border-radius:3px;background:${getColorFor(it.h)}'></span><span>${it.h.label}</span></h3>` +
                `<div><strong>Criteria:</strong> ${it.c.label}</div>` +
                `<div><strong>Level:</strong> ${level}</div>` +
                (note ? `<div style='margin-top:6px;color:var(--muted)'>${note}</div>` : '') + qhtml + `</div>`;
            }
            if (sheetEl) sheetEl.classList.add('has-inline-close');
            openSheet(sheetContent(idx), { hypId: overlapping[idx].h.id, critId: overlapping[idx].c.id }, el);
            const wire = () => {
              if (!sheetInner) return;
              const L = sheetInner.querySelector('.pg-left');
              const R = sheetInner.querySelector('.pg-right');
              const X = sheetInner.querySelector('.hdr-close');
              if (L) L.onclick = ev => { ev.stopPropagation(); idx = (idx - 1 + overlapping.length) % overlapping.length; sheetInner.innerHTML = sheetContent(idx); wire(); highlightSeries(overlapping[idx].h.id, overlapping[idx].c.id); state.sheetActiveVertex = { hypId: overlapping[idx].h.id, critId: overlapping[idx].c.id }; };
              if (R) R.onclick = ev => { ev.stopPropagation(); idx = (idx + 1) % overlapping.length; sheetInner.innerHTML = sheetContent(idx); wire(); highlightSeries(overlapping[idx].h.id, overlapping[idx].c.id); state.sheetActiveVertex = { hypId: overlapping[idx].h.id, critId: overlapping[idx].c.id }; };
              if (X) X.onclick = ev => { ev.stopPropagation(); closeSheet(); };
            };
            wire();
            return;
          }
          // Desktop: use existing showPagedTooltip and pin
          showPagedTooltip(overlapping, i, svgEl, br, sr);
          const currentHyp = overlapping[i].h;
          setTooltipColor(getColorFor(currentHyp));
          state.ttAnchor.x = br.left + br.width / 2;
          state.ttAnchor.y = br.top + br.height / 2;
          state.ttPinned = true; tt.classed('pinned', true); showTTBlocker(); clearTimeout(hideTimer);
          try { const t = Date.now() + 250; state._suppressClickUntil = t; state._suppressHideUntil = t; } catch(_) {}
          updateLeaderLine();
        };

        // Activation
        if (e.key === 'Enter' || e.key === ' ') {
          e.preventDefault();
          if (overlapping.length > 1) {
            const startIdx = overlapping.findIndex(v => v.h.id === d.h.id && v.c.id === d.c.id);
            openPagerAt(startIdx >= 0 ? startIdx : 0);
          } else {
            // Single vertex -> open tooltip/sheet and pin on desktop
            const Cmap = byId(Data.criteria);
            const level = ordinalLabel(d.c.id, d.raw, Cmap);
            const note = (byId(Data.hypotheses)[d.h.id].notes || {})[d.c.id] || '';
            const qhtml = quoteHTML(byId(Data.hypotheses), d.h.id, d.c.id);
            const html = `<div style='font-weight:600;display:flex;align-items:center;gap:6px'><span style='display:inline-block;width:10px;height:10px;border-radius:3px;background:${getColorFor(d.h)}'></span><span>${d.h.label}</span></div>` +
              `<div><strong>Criteria:</strong> ${d.c.label}</div>` +
              `<div><strong>Level:</strong> ${level}</div>` + (note ? `<div style='margin-top:4px;color:var(--muted)'>${note}</div>` : '') + qhtml;
            if (prefersSheet()) {
              if (sheetEl) sheetEl.classList.remove('has-inline-close');
              openSheet(html, { hypId: d.h.id, critId: d.c.id }, el);
              state.sheetActiveVertex = { hypId: d.h.id, critId: d.c.id };
            } else {
              showTTAt(html, svgEl, (br.left + br.width / 2) - sr.left, (br.top + br.height / 2) - sr.top, -10);
              highlightSeries(d.h.id, d.c.id);
              setTooltipColor(getColorFor(d.h));
              state.ttAnchor.x = br.left + br.width / 2; state.ttAnchor.y = br.top + br.height / 2;
              state.ttPinned = true; tt.classed('pinned', true); showTTBlocker(); clearTimeout(hideTimer); 
              // Suppress late doc clicks briefly after pin
              try { state._suppressClickUntil = Date.now() + 250; } catch(_) {}
              updateLeaderLine();
            }
          }
          return;
        }

        // Pager Left/Right across hypotheses at the same criterion (keyboard)
        if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
          e.preventDefault();
          // Build list of vertices for the same criterion across all currently selected hypotheses
          const sameCrit = vertexData.filter(v => v.c.id === d.c.id);
          // Order by the global hypothesis order in Data.hypotheses for predictability
          const order = Data.hypotheses.map(h => h.id);
          sameCrit.sort((a, b) => order.indexOf(a.h.id) - order.indexOf(b.h.id));
          let idx = sameCrit.findIndex(v => v.h.id === d.h.id);
          if (idx < 0) idx = 0;
          const nextIdx = (idx + (e.key === 'ArrowLeft' ? -1 : 1) + sameCrit.length) % sameCrit.length;
          // Show a paged tooltip over the same-criterion list, pinned; avoid reposition while pinned
          try { state.ttUserMoved = true; } catch(_) {}
          showPagedTooltip(sameCrit, nextIdx, svgEl, br, sr);
          // Update anchor to the newly selected hypothesis' vertex location for accurate leader line
          try {
            const targetNode = g.selectAll('.vertex').filter(v => v && v.h && v.c && v.h.id === sameCrit[nextIdx].h.id && v.c.id === sameCrit[nextIdx].c.id).node();
            const br2 = getScreenRectForAnchor(targetNode, svgEl) || (targetNode && targetNode.getBoundingClientRect ? targetNode.getBoundingClientRect() : br);
            state.ttAnchor.x = br2.left + br2.width / 2; state.ttAnchor.y = br2.top + br2.height / 2; updateLeaderLine();
          } catch(_) {}
          return;
        }

        // Up/Down move to previous/next criterion for the same hypothesis id (or nearest vertex)
        if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
          e.preventDefault();
          const dir = e.key === 'ArrowUp' ? -1 : 1;
          const critOrder = axes.map(a => a.id);
          const curIdx = critOrder.indexOf(d.c.id);
          const nextCritId = critOrder[(curIdx + dir + critOrder.length) % critOrder.length];
          const target = vertexData.find(v => v.h.id === d.h.id && v.c.id === nextCritId);
          if (target) {
            // Move DOM focus to the target vertex group
            try {
              const node = g.selectAll('.vertex').filter(v => v && v.h && v.c && v.h.id === target.h.id && v.c.id === target.c.id).node();
              if (node && node.focus) node.focus();
              // Also open its tooltip for continuity
              const fakeEvt = new KeyboardEvent('keydown', { key: 'Enter', bubbles: true });
              if (node) node.dispatchEvent(fakeEvt);
            } catch (_) {}
          }
        }
      });

      // Set tabindex for proper tab order: criterion -> its hypotheses -> next criterion
      let tabIndex = 20;  // Start after controls (1-5) and hypothesis checkboxes (6-12)
      
      // Set basic tabindex - will be corrected by global setup
      axisHits.attr('tabindex', 0);
      vwrap.attr('tabindex', 0);

      // draw a larger invisible hit-target first (improves touch precision), then ring + dot
      vwrap.append('circle')
        .attr('class', 'hit-target')
        .each(function (d) { d.baseHit = d.baseHit || (prefersSheet() ? 18 : 10); })
        .attr('r', d => d.baseHit)
        .attr('fill', 'transparent')
        .style('stroke', 'none')
        .style('pointer-events', 'all');
      // draw ring + dot inside each vertex group; store base sizes on the datum for zoom math
      vwrap.append('circle').attr('class', 'vertex-ring').each(function (d) { d.baseRing = d.baseRing || 7; }).attr('r', d => d.baseRing).attr('fill', '#fff').attr('stroke', d => getColorFor(d.h)).attr('stroke-width', 2).style('stroke-opacity', 0.95);
      vwrap.append('circle').attr('class', 'vertex-dot').each(function (d) { d.baseR = d.baseR || 5; }).attr('r', d => d.baseR).attr('fill', d => getColorFor(d.h)).attr('stroke', 'none');
  // ensure vertex groups render on top of polygons; keep axis group earlier in DOM order
  // so that keyboard tab order visits criteria (axis endpoints) before hypothesis vertices.
  try { vwrap.raise(); } catch (e) { }
    }
    // Helper to apply active styling to axis-end markers based on state.activeAxisId
    function updateAxisSelection() {
      try {
        const k = state.zoomK || 1;
        d3.select('#chart svg').selectAll('.axis-dot')
          .attr('r', function (d) {
            d.baseAxisR = d.baseAxisR || 5;
            const base = Math.max(3, d.baseAxisR / k);
            return (state.activeAxisId && state.activeAxisId === d.id) ? Math.max(4, base * AXIS_SELECTED_SCALE) : base;
          })
          .attr('stroke-width', d => (state.activeAxisId && state.activeAxisId === d.id) ? 3 : 2);
      } catch (_) { }
    }

    // Custom tab navigation system  
    let currentTabIndex = -1;
    let tabOrder = [];
    let tabEventListenersSetup = false;

    function setupTabOrder() {
      // Build ordered list of focusable elements in the desired sequence
      tabOrder = [];
      
      // 1. Add controls
      ['controlsToggle', 'factsBtn', 'dimsBtn', 'helpBtn', 'themeToggle'].forEach(id => {
        const el = document.getElementById(id);
        if (el) {
          tabOrder.push(el);
        }
      });
      
      // 2. Add hypothesis checkboxes
      const hypothesisInputs = document.querySelectorAll('#hypotheses input[type="checkbox"]');
      hypothesisInputs.forEach((input, i) => {
        tabOrder.push(input);
      });
      
      // 3. Add radar elements in criterion->hypothesis order
      const criteria = document.querySelectorAll('.axis-hit');
      const vertices = document.querySelectorAll('.vertex');
      
      // For each criterion, find vertices that are geometrically closest to it
      criteria.forEach((criterionEl, critIndex) => {
        tabOrder.push(criterionEl);
        
        // Get criterion position
        const criterionRect = criterionEl.getBoundingClientRect();
        const criterionCenter = {
          x: criterionRect.left + criterionRect.width / 2,
          y: criterionRect.top + criterionRect.height / 2
        };
        
        // Find all vertices and their distances to this criterion
        const vertexDistances = [];
        vertices.forEach((vertex, vertexIndex) => {
          const vertexRect = vertex.getBoundingClientRect();
          const vertexCenter = {
            x: vertexRect.left + vertexRect.width / 2,
            y: vertexRect.top + vertexRect.height / 2
          };
          
          // Calculate distance
          const distance = Math.sqrt(
            Math.pow(criterionCenter.x - vertexCenter.x, 2) + 
            Math.pow(criterionCenter.y - vertexCenter.y, 2)
          );
          
          vertexDistances.push({ vertex, distance, vertexIndex });
        });
        
        // Sort by distance and take the closest 7 (one per hypothesis)
        vertexDistances.sort((a, b) => a.distance - b.distance);
        const closestVertices = vertexDistances.slice(0, 7);
        
        // Add the closest vertices to this criterion
        closestVertices.forEach(({ vertex }) => {
          tabOrder.push(vertex);
        });
      });
      
      // Remove all existing tabindex attributes
      document.querySelectorAll('[tabindex]').forEach(el => {
        el.removeAttribute('tabindex');
      });
      
      // Set tabindex -1 for all radar elements to remove them from natural tab order
      [...criteria, ...vertices].forEach(el => {
        el.setAttribute('tabindex', '-1');
      });
      
      // Restore focus sentinel to remove it from tab order
      const focusSentinel = document.getElementById('focusSentinel');
      if (focusSentinel) {
        focusSentinel.setAttribute('tabindex', '-1');
      }
      
      // Set sequential tabindex for our ordered elements  
      tabOrder.forEach((el, index) => {
        el.setAttribute('tabindex', index + 1);
      });
      
      // Setup global event listeners only once
      if (!tabEventListenersSetup) {
        // Global keydown handler for Tab navigation
        document.addEventListener('keydown', (e) => {
          if (e.key === 'Tab') {
            e.preventDefault();
            
            const direction = e.shiftKey ? -1 : 1;
            let newIndex = currentTabIndex + direction;
            
            // Wrap around
            if (newIndex >= tabOrder.length) {
              newIndex = 0;
            } else if (newIndex < 0) {
              newIndex = tabOrder.length - 1;
            }
            
            focusElementAtIndex(newIndex);
          }
        });
        
        tabEventListenersSetup = true;
      }
      
      // Remove old focus listeners and add new ones
      tabOrder.forEach((el, index) => {
        // Remove any existing focus listeners first
        el.removeEventListener('focus', el._tabFocusHandler);
        
        // Create new focus handler
        el._tabFocusHandler = () => {
          currentTabIndex = index;
        };
        
        el.addEventListener('focus', el._tabFocusHandler);
      });
    }
    
    const focusElementAtIndex = (index) => {
      if (index >= 0 && index < tabOrder.length) {
        currentTabIndex = index;
        tabOrder[index].focus();
        return true;
      }
      return false;
    };

    // ---------- Heatmap
    function renderHeatmap(container, C, Hy) {
      const pad = { t: 30, r: 10, b: 30, l: 180 }; const w = container.clientWidth, h = container.clientHeight; const svg = d3.select(container).append('svg');
      // create a chartRoot group so we can translate the SVG content upward without moving the page
      const chartRoot = svg.append('g').attr('class', 'chart-root');
      state.chartRoot = chartRoot.node();
      const hySel = Data.hypotheses.filter(h => state.selected.has(h.id));
      const x = d3.scaleBand().domain(hySel.map(d => d.id)).range([pad.l, w - pad.r]).padding(0.08);
      const y = d3.scaleBand().domain(Data.criteria.map(d => d.id)).range([pad.t, h - pad.b]).padding(0.08);
      const cellFill = v => v < 1 / 3 ? 'var(--line)' : (v < 2 / 3 ? 'var(--cell-mid)' : 'var(--cell-high)');

      chartRoot.append('g').selectAll('text').data(Data.criteria).join('text')
        .attr('x', pad.l - 8).attr('y', d => y(d.id) + y.bandwidth() / 2)
        .attr('text-anchor', 'end').attr('dominant-baseline', 'middle').style('fill', 'var(--muted)').text(d => d.short).append('title').text(d => d.anchors.join(' / '));
      chartRoot.append('g').selectAll('text').data(hySel).join('text')
        .attr('x', d => x(d.id) + x.bandwidth() / 2).attr('y', pad.t - 10)
        .attr('text-anchor', 'middle').attr('fill', d => currentPalette()[d.id] || d.color).text(d => d.label);

      chartRoot.append('g').selectAll('rect').data(Data.criteria.flatMap(c => hySel.map(h => ({ c, h }))))
        .join('rect').attr('x', d => x(d.h.id)).attr('y', d => y(d.c.id)).attr('width', x.bandwidth()).attr('height', y.bandwidth()).attr('rx', 4)
        .attr('fill', d => cellFill(Hy[d.h.id].scores[d.c.id])).attr('stroke', d => currentPalette()[d.h.id] || Hy[d.h.id].color)
        .on('mousemove', (e, d) => {
          if (prefersSheet()) return; // no hover on mobile
          const raw = Hy[d.h.id].scores[d.c.id]; const level = ordinalLabel(d.c.id, raw, C); const note = (Hy[d.h.id].notes || {})[d.c.id] || ''; const qhtml = quoteHTML(Hy, d.h.id, d.c.id);
          const html = `<div style='font-weight:600'>${d.h.label}</div><div>${C[d.c.id].label}</div><div>Level: <strong>${level}</strong></div>` + (note ? `<div style='margin-top:4px;color:var(--muted)'>${note}</div>` : '') + qhtml;
          tt.html(html).style('left', (e.clientX + 12) + 'px').style('top', (e.clientY - 12) + 'px').style('display', 'block');
        })
        .on('mouseleave', () => { if (!prefersSheet()) scheduleHide(); })
        .on('click', (e, d) => {
          if (!prefersSheet()) return; // desktop click does nothing extra
          const raw = Hy[d.h.id].scores[d.c.id]; const level = ordinalLabel(d.c.id, raw, C); const note = (Hy[d.h.id].notes || {})[d.c.id] || ''; const qhtml = quoteHTML(Hy, d.h.id, d.c.id);
          const html = `<h3>${d.h.label}</h3><div class='sheet-meta'>${C[d.c.id].label}</div><div><strong>Level:</strong> ${level}</div>` + (note ? `<div style='margin-top:6px;color:var(--muted)'>${note}</div>` : '') + qhtml;
          if (sheetEl) sheetEl.classList.remove('has-inline-close');
          const anchorEl = e.currentTarget;
          openSheet(html, { hypId: d.h.id, critId: d.c.id }, anchorEl);
        });
    }

    // try to auto-load the local data file; fall back to a brief instruction if fetch fails
    (async function () {
      try {
        const resp = await fetch('data/resurrection-data.json');
        if (!resp.ok) throw new Error(resp.status + ' ' + resp.statusText);
        const txt = await resp.text();
        loadFromText(txt);
        if (loader) loader.style.display = 'none';
      } catch (err) {
        const exampleHint = document.createElement('div');
        exampleHint.className = 'small';
        exampleHint.style.padding = '10px 14px';
        exampleHint.innerHTML = 'Failed to load <code>data/resurrection-data.json</code>. Use <b>Load JSON file</b> or paste a URL into the input.';
        document.getElementById('main').prepend(exampleHint);
        if (loader) loader.style.display = 'none';
        console.warn('Auto-load failed:', err);
      }
    })();

    // Recenter / re-render the chart when the window is resized (debounced)
    let _resizeTimer = null;
    window.addEventListener('resize', () => {
      clearTimeout(_resizeTimer);
      _resizeTimer = setTimeout(() => { if (Data) render(); }, 150);
    });
    // Mobile viewport fix: set a CSS variable --vh to the actual viewport height
    // This prevents issues on iOS/Chrome where 100vh includes browser chrome and can push content off-screen.
    (function () {
      function setVh() {
        const h = (window.visualViewport && window.visualViewport.height) ? window.visualViewport.height : window.innerHeight;
        document.documentElement.style.setProperty('--vh', (h * 0.01) + 'px');
        // re-render to respect the new height
        if (Data) render();
      }
      // initial
      setVh();
      // update on relevant events
      if (window.visualViewport) {
        window.visualViewport.addEventListener('resize', setVh);
        window.visualViewport.addEventListener('scroll', setVh);
      }
      window.addEventListener('orientationchange', setVh);
      window.addEventListener('resize', setVh);
    })();


    
    // Initialize tab navigation system after initial render
    setTimeout(() => {
      setupTabOrder();
      // Start at first element
      focusElementAtIndex(0);
    }, 2000);
  </script>
</body>

</html>