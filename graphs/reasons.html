<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Historical Hypotheses — Radar & Heatmap (JSON loader)</title>
<style>
:root{ --bg:#ffffff; --ink:#1f2937; --muted:#6b7280; --line:#e5e7eb; --accent:#334155; --primary:#0b5fff; --primary-600:#084fd6; --panel-bg:#ffffff; --modal-shadow:0 20px 60px rgba(0,0,0,.2); --cell-mid:#9ca3af; --cell-high:#374151; --control-accent:#111 }
html,body{height:100%}
/* Reserve scrollbar gutter to avoid layout shifts when scrollbars appear/disappear */
html{ scrollbar-gutter: stable; }
body{margin:0; font:14px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Inter,sans-serif; color:var(--ink); background:var(--bg)}
#topbar{position:sticky; top:0; z-index:10; background:var(--bg); border-bottom:1px solid var(--line); padding:10px 14px; display:flex; gap:16px; align-items:center; flex-wrap:wrap; min-height:56px}
#topbar h1{font-size:16px; margin:0 8px 0 0; font-weight:600; color:var(--accent)}
#loaders{display:flex; gap:8px; align-items:center; flex-wrap:wrap}
/* base button */
button, .btn{border:1px solid var(--line); background:var(--panel-bg); padding:6px 10px; border-radius:8px; cursor:pointer; font-size:14px}
input[type="text"]{border:1px solid var(--line); border-radius:8px; padding:6px 10px; min-width:280px}
#hypotheses{
  display:flex;
  gap:10px;
  /* keep legend on a single row and center it in the topbar */
  flex-wrap:nowrap;
  margin-left:0;
  flex:1 1 auto;
  justify-content:center;
  /* fixed-height single-line scroller so it cannot grow and push the chart down */
  height:44px;
  line-height:44px;
  overflow-x:auto;
  overflow-y:hidden;
  -webkit-overflow-scrolling:touch;
  padding:6px 8px 0 8px;
}
.pill{display:inline-flex; align-items:center; gap:8px; border:1px solid var(--line); padding:6px 10px; border-radius:999px; flex:0 0 auto}
/* prevent pill contents from wrapping and increasing vertical size */
.pill{white-space:nowrap}

/* Prevent the horizontal scroller from showing a large scrollbar in most browsers while keeping it usable on touch devices */
#hypotheses::-webkit-scrollbar{ height:8px }
#hypotheses::-webkit-scrollbar-thumb{ background: rgba(0,0,0,0.12); border-radius:6px }

@media (max-width:520px){
  /* Slightly reduce pill padding on small screens so more fit before scrolling */
  .pill{ padding:6px 8px; font-size:13px }
}
.pill .sw{width:12px; height:12px; border-radius:3px}
.pill input{accent-color:var(--control-accent)}
.viewtabs{display:flex; gap:6px}
.viewtabs button.active{background:var(--control-accent); color:var(--panel-bg)}
#main{display:grid; grid-template-rows:auto 1fr auto; gap:10px}
#chart{width:100%; /* use a CSS variable for mobile-safe viewport height (see JS below) */ height:calc(var(--vh, 1vh) * 100 - 92px); min-height:380px; padding-top:14px; box-sizing:border-box}
#chart svg{display:block; width:100%; height:100%}
.help{margin-left:8px}
.legend{display:none}
.tooltip{position:fixed; pointer-events:auto; z-index:9999; background:var(--panel-bg); border:1px solid var(--line); padding:8px 10px; border-radius:8px; box-shadow:0 6px 20px rgba(0,0,0,.12); max-width:360px; font-size:12px; contain:paint; will-change:transform; max-height:calc(100vh - 96px); overflow:auto}
.tooltip .q{margin-top:6px; font-style:italic}
.tooltip .src{color:var(--muted)}
/* Pager buttons inside the tooltip (left/right) - ensure visibility in dark mode */
.tooltip button{ background:transparent; border:1px solid var(--line); color:var(--ink); width:36px; height:36px; border-radius:8px; display:inline-flex; align-items:center; justify-content:center; font-size:16px; line-height:1 }
.tooltip button:focus{ outline:3px solid rgba(0,0,0,0.08); outline-offset:2px }
.modalOverlay{position:fixed; inset:0; background:rgba(0,0,0,.35); display:none; align-items:center; justify-content:center; z-index:9998}
.modal{background:var(--panel-bg); border:1px solid var(--line); border-radius:12px; padding:16px 18px; width:min(720px, calc(100% - 40px)); max-height:80vh; overflow:auto; box-shadow:var(--modal-shadow)}
.modalHeader{display:flex; justify-content:space-between; align-items:center; gap:10px; margin-bottom:8px}
.modalHeader h2{font-size:16px; margin:0}
.modalHeader button{border:1px solid var(--line); background:var(--panel-bg); border-radius:8px; padding:4px 8px; cursor:pointer}
.modalBody p{margin:8px 0}
#drop{border:1px dashed var(--line); border-radius:10px; padding:8px 10px}
.small{font-size:12px; color:var(--muted)}

/* Prominent action styles for Help / Facts buttons */
.btn.primary{background:var(--primary); border-color:var(--primary); color:#fff; padding:10px 14px; border-radius:12px; font-weight:600; box-shadow:0 8px 20px rgba(11,95,255,0.14); transition:transform .12s ease, box-shadow .12s ease, background-color .12s ease}
.btn.primary:hover{background:var(--primary-600); transform:translateY(-1px); box-shadow:0 12px 30px rgba(11,79,255,0.18)}
.btn.primary:active{transform:translateY(0); box-shadow:0 6px 14px rgba(11,79,255,0.12)}

/* Help button is positioned right but styled as a clear primary-outline */
#helpBtn{padding:8px 12px; border-radius:12px; font-weight:600; font-size:14px; color:var(--primary); border:2px solid var(--primary); background:transparent; box-shadow:none; transition:background .12s ease, color .12s ease, transform .12s ease}
#themeToggle{color:var(--muted)}
#helpBtn:hover{background:var(--primary); color:#fff; transform:translateY(-1px); box-shadow:0 10px 28px rgba(11,95,255,0.10)}
#helpBtn:active{transform:translateY(0)}
#helpBtn:focus, .btn.primary:focus{outline:3px solid rgba(11,95,255,0.16); outline-offset:2px}

/* Slightly larger click targets for accessibility */
button, .btn, #helpBtn{min-height:40px}

/* smooth color transitions when switching themes */
body, #topbar, .modal, .tooltip, button, .btn, .pill { transition: background-color .18s ease, color .18s ease, border-color .18s ease, box-shadow .18s ease; }

/* Theme toggle icon visibility */
#icon-moon{display:inline-block; vertical-align:middle}
#icon-sun{display:none; vertical-align:middle}
:root[data-theme="dark"] #icon-moon{display:none}
:root[data-theme="dark"] #icon-sun{display:inline-block}

/* Dark-theme overrides */
:root[data-theme="dark"]{
  --bg:#071022;
  --ink:#e6eef8;
  /* brighter muted color so labels are legible on dark backgrounds */
  --muted:#cbd6e1;
  /* stronger grid/axis stroke for contrast in dark mode */
  --line:rgba(255,255,255,0.14);
  --accent:#93c5fd;
  --primary:#3b82f6;
  --primary-600:#2563eb;
  --panel-bg:#0f1724;
  --modal-shadow:0 20px 60px rgba(0,0,0,.6);
  --cell-mid:#7b8794;
  --cell-high:#a3b0c0;
  --control-accent:#cbd6e1;
}

/* Make links inside floating UI readable; use primary color by default and a lighter tint in dark mode */
.tooltip a, .modal a { color: var(--primary); text-decoration: underline; }
:root[data-theme="dark"] .tooltip a, :root[data-theme="dark"] .modal a { color: #9ec6ff; }

/* Header/title color adjustments for dark mode:
  - Keep the non-link title text high-contrast (var(--ink)).
  - Make the linked part of the title use the lighter tint used for tooltip links so the link stands out. */
:root[data-theme="dark"] #topbar h1 { color: var(--ink); }
:root[data-theme="dark"] #topbar h1 a, :root[data-theme="dark"] #topbar h1 a:visited { color: #9ec6ff; text-decoration: underline; }

/* Make chart axis labels and grid lines use the theme variables so they remain visible in dark mode.
  IMPORTANT: avoid overriding vertex marker strokes (they live inside the .vertices group). */
:root[data-theme="dark"] #chart svg text { fill: var(--muted); font-size:12px; }
:root[data-theme="dark"] #chart svg line { stroke: var(--line); }
/* Target only circles that are not inside the .vertices group (grid/axis dots) */
:root[data-theme="dark"] #chart svg g:not(.vertices) circle { stroke: var(--line); }
:root[data-theme="dark"] #chart svg path { stroke-opacity: 0.9; }

/* Tooltip pinned visual state */
.tooltip.pinned { border-color: var(--primary); box-shadow: 0 14px 40px rgba(11,95,255,0.18); border-width:2px; }
:root[data-theme="dark"] .tooltip.pinned { border-color: #fff; box-shadow: 0 14px 40px rgba(0,0,0,0.6); }

/* Pinned vertex state: make the outer ring stand out when pinned */
.vertex.pinned .vertex-ring { stroke: #fff !important; stroke-width: 3px !important; filter: drop-shadow(0 8px 20px rgba(0,0,0,0.28)); }
.vertex.pinned .vertex-dot { r: 5; }
/* close button inside tooltip */
.tooltip .tt-close { position:absolute; top:8px; right:8px; z-index:2; display:block; background:transparent; border:1px solid var(--line); border-radius:8px; width:34px; height:34px; display:flex; align-items:center; justify-content:center; font-size:16px; }
.tooltip.pinned .tt-close { /* visually emphasized when pinned */ border-color: var(--primary); box-shadow: 0 8px 20px rgba(0,0,0,0.12); }
/* cursor hint when tooltip is pinned and draggable */
.tooltip.pinned { cursor: grab; }
.tooltip.pinned:active { cursor: grabbing; }

</style>
</head>
<body>
  <div id="topbar">
  <h1>Compare Historical Hypotheses (<a href="https://www.amazon.com/Justifying-Historical-Descriptions-Cambridge-Philosophy/dp/0521318300" target="_blank" rel="noopener">C. Behan McCullagh</a>)</h1>
  <button id="factsBtn" class="btn primary" aria-expanded="false" aria-controls="factsOverlay">Facts</button>
  <button id="dimsBtn" class="btn primary" aria-expanded="false" aria-haspopup="dialog" aria-controls="dimsOverlay" title="About the seven dimensions">Dimensions</button>
  <button id="helpBtn" role="button" aria-haspopup="dialog" aria-controls="helpOverlay" class="help">? Help</button>
  <button id="themeToggle" class="btn" aria-pressed="false" title="Toggle dark mode" style="margin-left:8px">
    <span id="icon-moon" aria-hidden="true"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"></path></svg></span>
    <span id="icon-sun" aria-hidden="true"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="4"></circle><path d="M12 2v2M12 20v2M4.93 4.93l1.41 1.41M17.66 17.66l1.41 1.41M2 12h2M20 12h2M4.93 19.07l1.41-1.41M17.66 6.34l1.41-1.41"/></svg></span>
  </button>
  <div id="loaders">
  </div>
    <div id="hypotheses"></div>
  </div>

  <div id="main">
    <div id="chart" aria-live="polite">
      <div id="loader" class="small">Loading data from <code>data/resurrection-data.json</code>…</div>
    </div>
    <!-- Facts modal overlay (opened by Facts button) -->
    <div id="factsOverlay" class="modalOverlay" role="dialog" aria-modal="true" aria-labelledby="factsTitle" style="display:none">
      <div class="modal">
        <div class="modalHeader">
          <h2 id="factsTitle">Key facts and supporting reasons</h2>
          <button id="factsClose" aria-label="Close facts">×</button>
        </div>
        <div class="modalBody">
          <p><strong>Source</strong>: <a href="https://www.reasonablefaith.org/" target="_blank" rel="noopener">reasonablefaith.org</a></p>

          <h4>Burial of Jesus by Joseph of Arimathea</h4>
          <p>After the crucifixion, Jesus was buried in a tomb by Joseph of Arimathea.</p>
          <ul>
            <li>Paul’s early tradition (1 Corinthians 15:3-5) mentions that Jesus “was buried.”</li>
            <li>The burial account is part of the early source material used by Mark.</li>
            <li>Joseph of Arimathea was on the Jewish council that condemned Jesus, so inventing him as someone who gives Jesus a proper burial would be unlikely.</li>
            <li>There is no competing burial story.</li>
          </ul>

          <h4>The Empty Tomb</h4>
          <p>On the Sunday following the Crucifixion, the tomb of Jesus was found empty by a group of women followers.</p>
          <ul>
            <li>The empty tomb story is part of the old passion tradition in Mark.</li>
            <li>Paul’s tradition implies a vacant tomb (buried then raised).</li>
            <li>The story is relatively simple and lacks legendary embellishment compared to apocryphal stories.</li>
            <li>Women as the discoverers is significant, because women’s testimony was less valued in that culture — a detail harder to invent.</li>
            <li>Early opponents of Christianity admitted the tomb was empty and claimed disciples stole the body.</li>
          </ul>

          <h4>Post-Mortem Appearances</h4>
          <p>On multiple occasions, different individuals and groups experienced appearances of Jesus alive after his death.</p>
          <ul>
            <li>Paul’s list of witnesses in 1 Corinthians 15 mentions appearances to Peter, the Twelve, 500 brethren, James, etc.</li>
            <li>Gospel tradition gives multiple, independent attestations of appearances.</li>
            <li>The transformation of people who had been skeptical (e.g. Jesus’ family—James) after having seen him.</li>
          </ul>

          <h4>The Origin of the Disciples’ Belief in the Resurrection</h4>
          <p>The original disciples came to believe that Jesus rose from the dead, even though they had strong reasons to the contrary.</p>
          <ul>
            <li>Their leader was dead; Jewish expectations did not include a suffering Messiah who dies.</li>
            <li>The crucifixion made them look like they were following a heretic.</li>
            <li>Jewish belief in resurrection was of a future general resurrection, not an individual resurrection to glory before the end of the world.</li>
          </ul>
          <p>Yet, despite these strong obstacles, they were willing to suffer (and in many cases die) for their belief.</p>
        </div>
      </div>
    </div>
  </div>

  <!-- Help Modal -->
  <div id="helpOverlay" class="modalOverlay" role="dialog" aria-modal="true" aria-labelledby="helpTitle">
    <div class="modal">
      <div class="modalHeader">
        <h2 id="helpTitle">How to read this chart</h2>
        <button id="helpClose" aria-label="Close help">×</button>
      </div>
      <div class="modalBody">
  <p><strong>Purpose</strong><br>Compare hypotheses using C. Behan McCullagh’s criteria as <em>ordinal bands</em> (Low · Medium · High). Scores here are shown relative to a set of reference assessments used by the author for orientation — specifically, assessments published by William Lane Craig, a contemporary philosopher and scholar whose work addresses historical methods and early Christian history. See <a href="https://www.amazon.com/Justifying-Historical-Descriptions-Cambridge-Philosophy/dp/0521318300" target="_blank" rel="noopener">McCullagh, Justifying Historical Descriptions (1984)</a> for the original formulation of the seven conditions for the best explanation.</p>
        <p><strong>Rings & levels</strong><br>The three rings mark midpoints of bands: Low (0.25), Medium (0.50), High (0.75). Scores snap to these bands.</p>
  <p><strong>Axes</strong> (each shows its anchors): 1. Observable Implications; 2. Scope; 3. Power; 4. Plausibility; 5. Fewer assumptions; 6. Fewer conflicts; 7. Overall vs. rivals.</p>
        <p><strong>Colors</strong><br>Colors distinguish hypotheses (not values). Heatmap uses grayscale fill with colored borders.</p>
  <p><strong>Tooltips</strong><br>Hover a dot (vertex) → Level + short note + source quote w/ link. Tooltips appear while hovering; press Esc or click outside to close.</p>
      </div>
    </div>
  </div>

  <!-- Dimensions Modal -->
  <div id="dimsOverlay" class="modalOverlay" role="dialog" aria-modal="true" aria-labelledby="dimsTitle" style="display:none">
    <div class="modal">
      <div class="modalHeader">
        <h2 id="dimsTitle">The seven dimensions (framework consistency)</h2>
        <button id="dimsClose" aria-label="Close dimensions">×</button>
      </div>
      <div class="modalBody">
        <p>This visualization uses C. Behan McCullagh’s seven criteria (as applied by comparative historians) to assess hypotheses about historical events. The seven dimensions are used consistently as ordinal bands (Low · Medium · High) across hypotheses so relative strengths and trade-offs are comparable.</p>
        <ol>
          <li><strong>Observable Implications</strong> — How directly does the hypothesis produce observable consequences in the primary material?</li>
          <li><strong>Scope</strong> — How wide an explanatory reach does the hypothesis have?</li>
          <li><strong>Power</strong> — How well does it account for the specific facts under consideration?</li>
          <li><strong>Plausibility</strong> — Consistency with background knowledge and auxiliary hypotheses.</li>
          <li><strong>Fewer assumptions</strong> — Simplicity and fewer ad-hoc auxiliaries.</li>
          <li><strong>Fewer conflicts</strong> — Compatibility with other accepted facts.</li>
          <li><strong>Overall vs. rivals</strong> — Comparative explanatory superiority.</li>
        </ol>
        <p>The chart snaps scores to three ordinal bands so comparisons emphasize consistent, repeatable judgments rather than fine-grained numeric precision.</p>
      </div>
    </div>
  </div>

  <!-- Tooltip -->
  <div id="tt" class="tooltip" style="display:none"></div>

  <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
  <script>
  let Data = null; // loaded JSON
  const state = {
    view:'radar',
    selected:new Set(),
    showQuotes:true,
    applyWeights:false,
    showAxisTicks:true,
  pinned:null,
  pagerActive:null,
  lastActiveHypothesis:null,
  _highlightClearTimer:null
  };
  // flags to track pointer location for auto-hide logic
  state.isOverChart = false;
  state.isOverTT = false;

  // ---------- UI: loading
  const loader = document.getElementById('loader');
  // drag/drop removed; page will attempt to auto-load `data/resurrection-data.json` on load

  function loadFromText(txt){
    try{
      const json = JSON.parse(txt);
      validate(json);
      initialize(json);
    }catch(err){ alert('Invalid JSON: '+err.message); }
  }

  function validate(j){
    if(!j.criteria || !Array.isArray(j.criteria)) throw new Error('Missing criteria[]');
    if(!j.hypotheses || !Array.isArray(j.hypotheses)) throw new Error('Missing hypotheses[]');
    j.criteria.forEach(c=>{ if(!c.id||!c.label||!c.short||!c.anchors) throw new Error('Each criterion needs id,label,short,anchors'); });
  }

  // ---------- helpers
  const byId = arr=>Object.fromEntries(arr.map(d=>[d.id,d]));
  const clamp01 = x=> Math.max(0, Math.min(1, x));
  const avg = a=> d3.mean(a);
  const ordinalLabel = (crit,val,Criteria)=>{ const a=Criteria[crit].anchors; if(val<1/3) return a[0]; if(val<2/3) return a[1]; return a[2]; };
  function quantize(v){ if(v<1/3) return 0.25; if(v<2/3) return 0.5; return 0.75; }
  // point-in-polygon (ray-casting)
  function pointInPoly(x, y, vs){
    let inside = false;
    for(let i=0, j=vs.length-1; i<vs.length; j=i++){
      const xi = vs[i][0], yi = vs[i][1];
      const xj = vs[j][0], yj = vs[j][1];
      const intersect = ((yi>y) !== (yj>y)) && (x < (xj - xi) * (y - yi) / (yj - yi + 0.0) + xi);
      if(intersect) inside = !inside;
    }
    return inside;
  }

  // ---------- tooltip plumbing
  const tt = d3.select('#tt'); let hideTimer=null;
  // flag to suppress the next tooltip click if it immediately follows a drag
  let _suppressTTClick = false;
  // timestamp of last drag end used to ignore synthetic click events
  let _lastDragTime = 0;
  // create a single close button inside the tooltip; shown only when tooltip has .pinned
  try{
    const closeBtn = document.createElement('button');
    closeBtn.className = 'tt-close';
    // helper to update button text/label depending on pinned state
    const updateCloseBtn = (btn)=>{
      try{
        if(state.pinned){ btn.innerText = '×'; btn.setAttribute('aria-label','Close'); }
        else { btn.innerText = '📌'; btn.setAttribute('aria-label','Pin'); }
      }catch(e){}
    };
    updateCloseBtn(closeBtn);
    closeBtn.addEventListener('click', (ev)=>{
      ev.stopPropagation();
      // Toggle pinned state: if pinned -> close; if not pinned -> pin
      if(state.pinned){
        state.pinned = null; state.pagerActive = null; tt.classed('pinned', false);
        try{ d3.selectAll('.vertex.pinned').classed('pinned', false); }catch(e){}
        hideTT();
        return;
      }
      state.pinned = { key: 'tooltip' };
      tt.classed('pinned', true);
      updateCloseBtn(closeBtn);
    });
    // keep button state in sync when other code pins/unpins the tooltip
    const ttNode = tt.node(); if(ttNode) ttNode.appendChild(closeBtn);
  }catch(e){}

  // Dragging for pinned tooltip
  (function(){
    let dragging = false; let startX=0, startY=0, origLeft=0, origTop=0; let dragMoved = false;
    const ttNode = tt.node();
    if(!ttNode) return;
    ttNode.addEventListener('pointerdown', (ev)=>{
      // only start drag when tooltip is pinned and left mouse or primary pointer
      // but do not start drag when the pointerdown is on interactive controls
      // (buttons, links, inputs, the pin/close control, or pager buttons).
      if(!state.pinned) return;
      if(ev.button !== 0) return;
      try{
        const tgt = ev.target;
        if(tgt && tgt.closest && tgt.closest('button, a, input, .tt-close, #pager-left, #pager-right')){
          // let the control handle the pointer event; don't preventDefault or capture
          return;
        }
      }catch(e){}
      dragging = true;
      startX = ev.clientX; startY = ev.clientY;
      // read current computed left/top
      const rect = ttNode.getBoundingClientRect();
      origLeft = rect.left; origTop = rect.top;
      ttNode.setPointerCapture && ttNode.setPointerCapture(ev.pointerId);
      ev.preventDefault();
    });
    window.addEventListener('pointermove', (ev)=>{
      if(!dragging) return;
      const dx = ev.clientX - startX; const dy = ev.clientY - startY;
      if(Math.hypot(dx, dy) > 3) dragMoved = true;
      let left = origLeft + dx; let top = origTop + dy;
      // clamp to viewport
      const pad = 8; const vw = window.innerWidth, vh = window.innerHeight;
      const tr = tt.node().getBoundingClientRect();
      if(left < pad) left = pad; if(left + tr.width + pad > vw) left = Math.max(pad, vw - tr.width - pad);
      if(top < pad) top = pad; if(top + tr.height + pad > vh) top = Math.max(pad, vh - tr.height - pad);
      tt.style('left', left + 'px').style('top', top + 'px').style('transform','translateZ(0)');
    });
    window.addEventListener('pointerup', (ev)=>{
      if(!dragging) return; dragging = false;
      try{ tt.node().releasePointerCapture && tt.node().releasePointerCapture(ev.pointerId); }catch(e){}
  if(dragMoved){ _suppressTTClick = true; _lastDragTime = Date.now(); }
      if(dragMoved){ 
        setTimeout(()=>{ _suppressTTClick = false; }, 300);
        // swallow the next click event (capturing) to avoid synthetic clicks from unpinning
        const suppressOnce = function(ev2){ ev2.stopPropagation(); ev2.preventDefault(); document.removeEventListener('click', suppressOnce, true); };
        document.addEventListener('click', suppressOnce, true);
      }
  dragMoved = false;
    });
    // cancel drag on Escape/unpin
    window.addEventListener('keydown', (e)=>{ if(e.key==='Escape'){ dragging=false; } });
  })();
  function showTTAt(html, svgEl, sx, sy, dy=-10){
    clearTimeout(hideTimer);
    // Save scroll position to avoid any reflow caused by inserting tooltip content
    const scrollTop = document.documentElement.scrollTop || document.body.scrollTop;
    const scrollLeft = document.documentElement.scrollLeft || document.body.scrollLeft;
    const r = svgEl.getBoundingClientRect();
    // Use transform for compositing where possible to avoid layout jumps
    tt.html(html).style('display','block').style('left', (r.left+sx)+'px').style('top', (r.top+sy+dy)+'px').style('transform','translateZ(0)');
    // ensure the tooltip has a close button (show/hide handled by CSS .tooltip.pinned)
    try{
      const ttNode = tt.node();
      if(ttNode && !ttNode.querySelector('.tt-close')){
        const cb = document.createElement('button');
        cb.className = 'tt-close';
        const updateCB = (btn)=>{ if(state.pinned){ btn.innerText='×'; btn.setAttribute('aria-label','Close'); } else { btn.innerText='📌'; btn.setAttribute('aria-label','Pin'); } };
        updateCB(cb);
        cb.addEventListener('click', (ev)=>{
          ev.stopPropagation();
          if(state.pinned){ state.pinned = null; state.pagerActive = null; tt.classed('pinned', false); try{ d3.selectAll('.vertex.pinned').classed('pinned', false); }catch(e){}; hideTT(); return; }
          state.pinned = { key: 'tooltip' }; tt.classed('pinned', true); updateCB(cb);
        });
        ttNode.appendChild(cb);
      }
    }catch(e){}
    // clamp tooltip so it doesn't force scrollbars on small viewports
    const ttNode = tt.node();
    if(ttNode){
      const ttr = ttNode.getBoundingClientRect();
      let left = parseFloat(tt.style('left')) || ttr.left;
      let top = parseFloat(tt.style('top')) || ttr.top;
      const pad = 8;
      const vw = window.innerWidth, vh = window.innerHeight;
      // shift horizontally if overflowing
      if(left + ttr.width + pad > vw) left = Math.max(pad, vw - ttr.width - pad);
      if(left < pad) left = pad;
      // shift vertically if overflowing
      if(top + ttr.height + pad > vh) top = Math.max(pad, vh - ttr.height - pad);
      if(top < pad) top = pad;
      tt.style('left', left + 'px').style('top', top + 'px');
    }
    // restore scroll position in case browser adjusted it
    window.scrollTo(scrollLeft, scrollTop);
  }
  function scheduleHide(delay=200){ clearTimeout(hideTimer); hideTimer=setTimeout(()=>{ // hide only if not pinned and pointer is not over chart or tooltip
      if(!state.pinned && !state.isOverChart && !state.isOverTT){ tt.style('display','none'); state.pagerActive = null; clearHighlight(); }
    }, delay); }
  function hideTT(){ tt.style('display','none'); state.pinned = null; state.pagerActive = null; clearHighlight(); try{ tt.classed('pinned', false); d3.selectAll('.vertex.pinned').classed('pinned', false); }catch(e){} }
  // tooltip clicks are no-ops; pinning/unpinning is handled only by the pin/close control
  tt.on('click', (event)=>{
    // ignore click fired immediately after a drag (pointerup generates a click)
    if(_suppressTTClick){ _suppressTTClick = false; return; }
    // also ignore clicks that happen within a short window after drag end (timestamp-based)
    if(_lastDragTime && (Date.now() - _lastDragTime) < 300){ _lastDragTime = 0; return; }
    // do nothing here — pin/unpin is performed by the pin/close button only
    return;
  }).on('mouseenter', ()=>{ state.isOverTT = true; clearTimeout(hideTimer); }).on('mouseleave', ()=>{
    state.isOverTT = false;
    // when leaving the tooltip, schedule hide; also clear pagerActive after the delay so pager behavior reverts
    scheduleHide();
    if(state.pagerActive){
      setTimeout(()=>{ if(!state.isOverTT && !state.isOverChart){ state.pagerActive = null; clearHighlight(); } }, 250);
    }
  });

  // ---------- render UI
  function initialize(json){
    Data = json;
  if(typeof loader !== 'undefined' && loader) loader.style.display = 'none';
    state.selected = new Set(Data.hypotheses.map(h=>h.id));
    state.weights = {...(Data.weights||{})};
    renderControls();
    render();
  }

  function renderControls(){
    const wrap = d3.select('#hypotheses');
    wrap.selectAll('*').remove();
    const C = byId(Data.criteria), Hy = byId(Data.hypotheses);
    const pill = wrap.selectAll('.pill').data(Data.hypotheses).join('label').attr('class','pill');
    pill.append('span').attr('class','sw').style('background', d=>d.color);
    pill.append('input').attr('type','checkbox').attr('checked', true)
      .on('change', (e,d)=>{ e.target.checked? state.selected.add(d.id) : state.selected.delete(d.id); render(); });
    pill.append('span').attr('class','txt').text(d=>{
      const rawAvg = avg(Object.keys(C).map(k=>Hy[d.id].scores[k]));
      const lvl = rawAvg < 0.4 ? 'Low' : (rawAvg < 0.7 ? 'Medium' : 'High');
      return `${d.label} — Overall: ${lvl}`;
    });

    // only bind view switching to buttons that declare a data-view (help button is not a view)
    d3.selectAll('.viewtabs button[data-view]').on('click', (e)=>{
      d3.selectAll('.viewtabs button[data-view]').classed('active', false).attr('aria-selected', false);
      d3.select(e.currentTarget).classed('active', true).attr('aria-selected', true);
      state.view = e.currentTarget.dataset.view; render();
    });

    d3.select('#helpBtn').on('click', ()=>{ d3.select('#helpOverlay').style('display','flex'); d3.select('#helpClose').node().focus();});
    d3.select('#helpClose').on('click', ()=> d3.select('#helpOverlay').style('display','none'));
    d3.select('#helpOverlay').on('click', function(e){ if(e.target===this) d3.select('#helpOverlay').style('display','none'); });
  d3.select('#dimsBtn').on('click', ()=>{ d3.select('#dimsOverlay').style('display','flex'); d3.select('#dimsClose').node().focus(); d3.select('#dimsBtn').attr('aria-expanded','true'); });
  d3.select('#dimsClose').on('click', ()=>{ d3.select('#dimsOverlay').style('display','none'); d3.select('#dimsBtn').attr('aria-expanded','false'); });
  d3.select('#dimsOverlay').on('click', function(e){ if(e.target===this){ d3.select('#dimsOverlay').style('display','none'); d3.select('#dimsBtn').attr('aria-expanded','false'); } });
  d3.select('#factsBtn').on('click', ()=>{ d3.select('#factsOverlay').style('display','flex'); d3.select('#factsClose').node().focus(); d3.select('#factsBtn').attr('aria-expanded', 'true'); });
  d3.select('#factsClose').on('click', ()=>{ d3.select('#factsOverlay').style('display','none'); d3.select('#factsBtn').attr('aria-expanded','false'); });
  d3.select('#factsOverlay').on('click', function(e){ if(e.target===this){ d3.select('#factsOverlay').style('display','none'); d3.select('#factsBtn').attr('aria-expanded','false'); } });

  // Consolidated Escape handling: close overlays and tooltips
  window.addEventListener('keydown', (e)=>{ if(e.key==='Escape'){ state.pinned=null; hideTT(); d3.select('#helpOverlay').style('display','none'); d3.select('#factsOverlay').style('display','none'); d3.select('#dimsOverlay').style('display','none'); d3.select('#factsBtn').attr('aria-expanded','false'); d3.select('#dimsBtn').attr('aria-expanded','false'); } });
    document.addEventListener('click', (e)=>{
      const node = tt.node();
      // If tooltip is pinned, do not close it via outside clicks; user must press Escape or click tooltip to unpin
      if(state.pinned){
        const clickedVertex = e.target && e.target.closest && e.target.closest('.vertex');
        if(clickedVertex) return; // let vertex click handlers run
        // clicking outside when pinned should do nothing
        return;
      }
      // if click is outside the tooltip, close it (clear pager state)
      if(node && !node.contains(e.target)){
        state.pagerActive = null;
        hideTT();
      }
    });
  }

  // Theme handling: toggle and persist theme in localStorage
  const themeKey = 'pv_theme';
  function applyTheme(t){ if(t==='dark') document.documentElement.setAttribute('data-theme','dark'); else document.documentElement.removeAttribute('data-theme'); }
  function initTheme(){ const stored = localStorage.getItem(themeKey); if(stored){ applyTheme(stored); d3.select('#themeToggle').attr('aria-pressed', stored==='dark'?'true':'false'); } else {
      // respect prefers-color-scheme as default
      const prefers = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light'; applyTheme(prefers); d3.select('#themeToggle').attr('aria-pressed', prefers==='dark'?'true':'false'); }
    d3.select('#themeToggle').on('click', ()=>{ const cur = document.documentElement.getAttribute('data-theme')==='dark' ? 'dark' : 'light'; const next = cur==='dark' ? 'light' : 'dark'; applyTheme(next); localStorage.setItem(themeKey, next); d3.select('#themeToggle').attr('aria-pressed', next==='dark'?'true':'false'); });
  }
  // initialize theme immediately so colors are correct before UI paints
  try{ initTheme(); }catch(e){/* ignore */}

  function quoteHTML(Hy, hypId, crit){
    if(state.showQuotes!==true) return '';
    const a = (Hy[hypId].quotes && Hy[hypId].quotes[crit]) || null;
    const q = a && a[0];
    if(!q) return '';
    const safe = (q.t||'').replace(/\"/g,'&quot;');
    const srcHTML = q.url ? `<a href='${q.url}' target='_blank' rel='noopener'>${q.src||''}</a>` : (q.src||'');
    return `<div class='q'>&ldquo;${safe}&rdquo;</div><div class='src'>— ${srcHTML}</div>`;
  }

  // Highlight a hypothesis series (polygon and pill) by id
  function highlightSeries(hypId){
    // record last active
    state.lastActiveHypothesis = hypId;
    // cancel any pending clear timer
    if(state._highlightClearTimer){ clearTimeout(state._highlightClearTimer); state._highlightClearTimer = null; }
    // dim all polygons and pills, then highlight the selected
  d3.selectAll('.hyp-polygon').style('opacity', 0.12).style('filter', null);
  d3.selectAll('.pill').style('opacity', 0.5);
  // dim vertices (inner colored dots)
  d3.selectAll('.vertices .vertex-dot').style('opacity', 0.4).attr('r',5);
    d3.selectAll('.hyp-polygon').filter(function(d){ return d && d.id===hypId; }).style('opacity', 1).style('filter', 'drop-shadow(0 6px 18px rgba(0,0,0,0.12))');
  d3.selectAll('.pill').filter(function(d){ return d && d.id===hypId; }).style('opacity', 1);
  // highlight vertices for this hypothesis (inner dot larger)
  d3.selectAll('.vertices .vertex-dot').filter(function(d){ return d && d.h && d.h.id===hypId; }).style('opacity', 1).attr('r',6).each(function(d){
    try{ this.parentNode && this.parentNode.parentNode && d3.select(this.parentNode).raise(); }catch(e){}
    // ensure inner fill and outer ring stroke match hypothesis color
    d3.select(this).attr('fill', d.h.color);
    d3.select(this.parentNode).select('.vertex-ring').attr('stroke', d.h.color);
  });
  }

  function clearHighlight(){
    // delay returning to default to allow quick move to another vertex of same hypothesis
    if(state._highlightClearTimer) clearTimeout(state._highlightClearTimer);
    state._highlightClearTimer = setTimeout(()=>{
      d3.selectAll('.hyp-polygon').style('opacity', null).style('filter', null);
      d3.selectAll('.pill').style('opacity', null);
  d3.selectAll('.vertices .vertex-dot').style('opacity', null).attr('r',5);
      state._highlightClearTimer = null;
      // reset lastActiveHypothesis after clearing
      state.lastActiveHypothesis = null;
    }, 450); // 450ms grace period
  }

  // Show a tooltip with pager controls for overlapping vertices
  function showPagedTooltip(list, startIndex, svgEl, br, sr){
    let idx = startIndex || 0;
  // If pager is already active for the same list and index, avoid re-rendering
  const key = list.map(i=>i.h.id+'@'+i.c.id).join('|');
  if(state.pagerActive && state.pagerActive.key === key && state.pagerActive.idx === idx) return;
    function renderAt(i){
      const item = list[i];
      const level = ordinalLabel(item.c.id, item.raw, byId(Data.criteria));
      const note = (byId(Data.hypotheses)[item.h.id].notes||{})[item.c.id]||'';
      const qhtml = quoteHTML(byId(Data.hypotheses), item.h.id, item.c.id);
      // pager at top to avoid vertical shift when content changes
  let content = `<div style='position:relative;display:flex;flex-direction:column;gap:8px;min-width:220px;padding-right:48px'>`+
        `<div style='display:flex;align-items:center;justify-content:space-between'>`+
          `<div style='font-weight:600'>Hypothesis ${i+1}/${list.length}</div>`+
          `<div style='display:flex;align-items:center;gap:6px'>`+
            `<button id='pager-left' aria-label='Previous' style='width:32px;height:32px;margin-left:6px'>&#9664;</button>`+
            `<button id='pager-right' aria-label='Next' style='width:32px;height:32px;margin-left:6px'>&#9654;</button>`+
          `</div>`+
        `</div>`+
        `<div id='pager-body' style='min-height:56px'>`+
          `<div style='font-weight:600'>${item.h.label}</div><div>${item.c.label}</div><div>Level: <strong>${level}</strong></div>`;
      if(note) content += `<div style='margin-top:4px;color:var(--muted)'>${note}</div>`;
      content += qhtml;
      content += `</div></div>`;
      showTTAt(content, svgEl, (br.left+br.width/2)-sr.left, (br.top+br.height/2)-sr.top, -10);
      // highlight current series
      highlightSeries(item.h.id);
      // wire pager buttons (delegated via document since TT content is HTML string)
      setTimeout(()=>{
        const left = document.getElementById('pager-left');
        const right = document.getElementById('pager-right');
  if(left) {
          // stop propagation so the document click handler doesn't close the tooltip
          left.addEventListener('click', (ev)=>{ ev.stopPropagation(); idx = (idx - 1 + list.length) % list.length; renderAt(idx); });
        }
        if(right) {
          right.addEventListener('click', (ev)=>{ ev.stopPropagation(); idx = (idx + 1) % list.length; renderAt(idx); });
        }
        
      }, 0);
    }
    renderAt(idx);
  // mark pager as active so hover handlers won't override it
  state.pagerActive = { key, ids: list.map(i=>i.h.id), idx };
  }

  function render(){
    const el = document.getElementById('chart'); d3.select(el).selectAll('*').remove();
    const C = byId(Data.criteria), Hy = byId(Data.hypotheses);
    if(state.view==='radar') renderRadar(el, C, Hy); else renderHeatmap(el, C, Hy);
  }

  // ---------- Radar
  function renderRadar(container, C, Hy){
  const w = container.clientWidth, h = container.clientHeight;
  // responsive padding: give more horizontal padding on narrow viewports so outer axis labels don't get clipped
  const padY = 36;
  // padX scales with width; ensure a reasonable min/max so labels have room
  const padX = Math.max(40, Math.min(140, Math.round(w * 0.25)));
  const r = Math.min(w/2 - padX, h/2 - padY);
  const svg=d3.select(container).append('svg').attr('width', w).attr('height', h);
  // track pointer presence over chart to control tooltip auto-hide
  svg.on('mouseenter', ()=>{ state.isOverChart = true; clearTimeout(hideTimer); }).on('mouseleave', ()=>{ state.isOverChart = false; scheduleHide(); });
    // viewport receives the zoom transform; content is centered inside the viewport so zooming is anchored to cursor
    const viewport = svg.append('g');
    const g = viewport.append('g').attr('transform', `translate(${w/2},${h/2})`);

    // D3 zoom: apply transform to viewport so zoom is centered on pointer location
    const zoom = d3.zoom().scaleExtent([0.6, 4]).on('zoom', (e)=>{
      viewport.attr('transform', e.transform);
    });
    // Only enable zoom when interacting with the SVG background (not when interacting with interactive elements)
    svg.call(zoom.filter(function(event){
      const t = event.target;
      return t === svg.node() || t.tagName === 'svg' || (t.closest && !t.closest('.vertices') && !t.closest('.pill'));
    }));
    // double-click to reset zoom
    svg.on('dblclick', ()=>{ svg.transition().duration(350).call(zoom.transform, d3.zoomIdentity); });
    // hide tooltip when pointer leaves the active hypothesis polygon
    svg.on('mousemove.pointercheck', (event)=>{
      if(!state.lastActiveHypothesis) return;
      const poly = state.currentPolygons && state.currentPolygons[state.lastActiveHypothesis];
      if(!poly) return;
      // if pointer is over a vertex or the tooltip, don't hide (prevents races)
      const el = document.elementFromPoint(event.clientX, event.clientY);
      try{
        if(el && el.closest && (el.closest('.vertices') || el.closest('#tt'))){ return; }
      }catch(e){}
      const rect = svg.node().getBoundingClientRect();
      const x = event.clientX - rect.left;
      const y = event.clientY - rect.top;
      if(!pointInPoly(x, y, poly)){
        // if a tooltip is pinned, don't hide it when leaving the polygon
        if(state.pinned) return;
        // schedule an immediate hide that ignores isOverChart but respects if pointer moved into tooltip
        setTimeout(()=>{
          const el2 = document.elementFromPoint(event.clientX, event.clientY);
          if(!(el2 && el2.closest && el2.closest('#tt'))){ state.pagerActive = null; hideTT(); }
        }, 40);
      }
    });
    const axes=Data.criteria.map((d,i)=>{ const ang=(Math.PI*2*i)/Data.criteria.length - Math.PI/2; return {...d, angle:ang, x:Math.cos(ang), y:Math.sin(ang)}; });
    const rScale=d3.scaleLinear().domain([0,1]).range([0,r]);

    // grid + axes (no pointer capture)
  const grid=g.append('g').style('pointer-events','none');
  grid.selectAll('circle').data([0.25,0.5,0.75]).join('circle').attr('r',d=>rScale(d)).attr('fill','none').style('stroke','var(--line)');
    // level labels along each axis using the criterion anchors (Low/Medium/High)
    const levels = [0.25, 0.5, 0.75];
    const levelLabels = axes.flatMap(a => levels.map((lv, i) => ({axis: a, lv, i})));
    const labelOffset = 12; // pixels inward from the ring intersection
    grid.selectAll('.level-label').data(levelLabels).join('text')
      .attr('class','level-label')
      .attr('x', d=> d.axis.x * (rScale(d.lv) - labelOffset))
      .attr('y', d=> d.axis.y * (rScale(d.lv) - labelOffset))
      .attr('font-size', 10)
      .style('fill', 'var(--muted)')
      .attr('text-anchor', 'middle')
      .attr('dominant-baseline', 'central')
      .text(d=> (d.axis.anchors && d.axis.anchors[d.i]) ? d.axis.anchors[d.i] : '');
  const ax=g.append('g').selectAll('g').data(axes).join('g').style('pointer-events','none');
  ax.append('line').attr('x1',0).attr('y1',0).attr('x2',d=>d.x*r).attr('y2',d=>d.y*r).style('stroke','var(--line)');
    ax.append('text').attr('x',d=>d.x*(r+14)).attr('y',d=>d.y*(r+14))
      .attr('text-anchor',d=> Math.abs(d.x)<0.3 ? 'middle' : (d.x>0?'start':'end'))
      .attr('dominant-baseline','central').attr('font-size',12)
      .text(d=>d.short);

    const sel = Data.hypotheses.filter(h=>state.selected.has(h.id));
    const pointsFor = (h)=> axes.map(a=>{ const vv=quantize(Hy[h.id].scores[a.id]); const rr=rScale(vv); return [a.x*rr, a.y*rr]; });

    // polygons (no tooltip) -- record polygon points for pointer-in-polygon checks
    state.currentPolygons = {};
    g.append('g').selectAll('path').data(sel, d=>d.id).join('path')
      .attr('class','hyp-polygon')
      .attr('d', d=> d3.line().curve(d3.curveLinearClosed)(pointsFor(d)))
      .attr('fill', d=> d3.color(d.color).copy({opacity:0.15}))
      .attr('stroke', d=> d.color).attr('stroke-width',2)
      .each(function(d){
        const pts = pointsFor(d).map(p=>[p[0] + w/2, p[1] + h/2]);
        state.currentPolygons[d.id] = pts;
      });

    // axis-end info dots
    const helpG=g.append('g');
    helpG.selectAll('circle').data(axes).join('circle')
      .attr('cx', d=>d.x*r).attr('cy', d=>d.y*r).attr('r',5)
      .style('fill','var(--panel-bg)').style('stroke','var(--muted)').attr('stroke-width',2)
      .on('mouseenter mousemove', (e,d)=>{
        // don't show hover tooltips when a tooltip is pinned
        if(state.pinned) return;
        const html = `<div><strong>${d.label}</strong></div>`+
          `<div style='color:var(--muted)'>${d.desc||''}</div>`+
          `<div style='margin-top:4px'>Levels: <strong>${d.anchors.join(' • ')}</strong></div>`;
        const svgEl = svg.node(); const br=e.currentTarget.getBoundingClientRect(); const sr=svgEl.getBoundingClientRect();
        showTTAt(html, svgEl, (br.left+br.width/2)-sr.left, (br.top+br.height/2)-sr.top, -10);
      }).on('mouseleave', ()=> scheduleHide())
  .on('click', (e,d)=>{ 
    e.stopPropagation();
    // toggle pin for axis tooltip
    const key = 'axis|'+d.id;
    if(state.pinned && state.pinned.key === key){
      state.pinned = null; tt.classed('pinned', false); hideTT(); return;
    }
    state.pinned={key};
    // ensure any vertex pinned visuals are cleared
    try{ d3.selectAll('.vertex.pinned').classed('pinned', false); }catch(e){}
    const svgEl=svg.node(); const br=e.currentTarget.getBoundingClientRect(); const sr=svgEl.getBoundingClientRect();
    showTTAt(`<div><strong>${d.label}</strong></div><div style='color:var(--muted)'>${d.desc||''}</div><div style='margin-top:4px'>Levels: <strong>${d.anchors.join(' • ')}</strong></div>`, svgEl, (br.left+br.width/2)-sr.left, (br.top+br.height/2)-sr.top, -10);
    tt.classed('pinned', true);
  });

    // vertex dots
    const vertexData = sel.flatMap(hh => axes.map(a=>{ const raw=Hy[hh.id].scores[a.id]; const vv=quantize(raw); const rr=rScale(vv); return {h:hh, c:a, raw, x:a.x*rr, y:a.y*rr}; }));
    const vwrap = g.append('g').attr('class','vertices').selectAll('g.vertex').data(vertexData).join('g').attr('class','vertex')
      .attr('transform', d=>`translate(${d.x},${d.y})`)
      .on('mouseenter mousemove', (e,d)=>{
        // don't override a pinned tooltip with hover
        if(state.pinned) return;
        const svgEl=svg.node(); const br=e.currentTarget.getBoundingClientRect(); const sr=svgEl.getBoundingClientRect();
        // find overlapping vertices
        const tol = 2.5; // pixels (more permissive for touch)
        const overlapping = vertexData.filter(v => Math.hypot(v.x - d.x, v.y - d.y) <= tol);
        // If a pager is active for this group, don't let normal hover override it
        if(state.pagerActive){ const key = overlapping.map(i=>i.h.id+'@'+i.c.id).join('|'); if(state.pagerActive.key === key) return; }
        if(overlapping.length>1){
          // prefer lastActiveHypothesis when choosing start index
          let startIdx = overlapping.findIndex(v => v.h.id === d.h.id && v.c.id === d.c.id);
          if(state.lastActiveHypothesis){ const pref = overlapping.findIndex(v => v.h.id === state.lastActiveHypothesis); if(pref>=0) startIdx = pref; }
          // show pager on hover (don't pin)
          if(!state.pinned) showPagedTooltip(overlapping, startIdx, svgEl, br, sr);
          return;
        }
        const level=ordinalLabel(d.c.id, d.raw, byId(Data.criteria));
        const note=(byId(Data.hypotheses)[d.h.id].notes||{})[d.c.id]||'';
        const qhtml=quoteHTML(byId(Data.hypotheses), d.h.id, d.c.id);
        const html=`<div><strong>${d.h.label}</strong></div><div>${d.c.label}</div><div>Level: <strong>${level}</strong></div>`+(note?`<div style='margin-top:4px;color:var(--muted)'>${note}</div>`:'')+qhtml;
  showTTAt(html, svgEl, (br.left+br.width/2)-sr.left, (br.top+br.height/2)-sr.top, -10);
        highlightSeries(d.h.id);
      })
      .on('mouseleave', ()=> scheduleHide())
      .on('click', (e,d)=>{
        e.stopPropagation();
        const svgEl = svg.node();
        const br = e.currentTarget.getBoundingClientRect();
        const sr = svgEl.getBoundingClientRect();
        // find nearby vertices (same position within a small tolerance)
        const tol = 2.5; // pixels
        const overlapping = vertexData.filter(v => Math.hypot(v.x - d.x, v.y - d.y) <= tol);
        if(overlapping.length > 1){
          // prefer lastActiveHypothesis when selecting the initial index
          let startIdx = overlapping.findIndex(v => v.h.id === d.h.id && v.c.id === d.c.id);
          if(state.lastActiveHypothesis){ const pref = overlapping.findIndex(v => v.h.id === state.lastActiveHypothesis); if(pref>=0) startIdx = pref; }
          // pin the tooltip for the selected overlapping item and show pager
          try{ d3.selectAll('.vertex.pinned').classed('pinned', false); }catch(e){}
          const selItem = overlapping[startIdx] || overlapping[0];
          const listKey = overlapping.map(i=>i.h.id+'@'+i.c.id).join('|');
          state.pinned = { key: listKey };
          // add pinned class to the chosen vertex group so it visually indicates pin
          try{
            d3.selectAll('.vertex').filter(function(dd){ return dd && dd.h && dd.c && dd.h.id===selItem.h.id && dd.c.id===selItem.c.id; }).classed('pinned', true);
          }catch(e){}
          tt.classed('pinned', true);
          // show paged tooltip
          showPagedTooltip(overlapping, startIdx, svgEl, br, sr);
        }else{
          // single vertex: toggle pin on click
          const group = d3.select(e.currentTarget);
          const myKey = d.h.id+'|'+d.c.id;
          const alreadyPinned = state.pinned && state.pinned.key === myKey;
          if(alreadyPinned){
            state.pinned = null;
            group.classed('pinned', false);
            tt.classed('pinned', false);
            hideTT();
            return;
          }
          // pin this vertex
          state.pinned = {key: myKey};
          // clear other pinned visuals and apply to this group
          try{ d3.selectAll('.vertex.pinned').classed('pinned', false); }catch(e){}
          group.classed('pinned', true);
          const level = ordinalLabel(d.c.id, d.raw, byId(Data.criteria));
          const note = (byId(Data.hypotheses)[d.h.id].notes||{})[d.c.id]||'';
          const qhtml = quoteHTML(byId(Data.hypotheses), d.h.id, d.c.id);
          const html = `<div><strong>${d.h.label}</strong></div><div>${d.c.label}</div><div>Level: <strong>${level}</strong></div>` + (note?`<div style='margin-top:4px;color:var(--muted)'>${note}</div>`:'') + qhtml;
          showTTAt(html, svgEl, (br.left+br.width/2)-sr.left, (br.top+br.height/2)-sr.top, -10);
          highlightSeries(d.h.id);
          tt.classed('pinned', true);
        }
      });

  // draw ring + dot inside each vertex group
  vwrap.append('circle').attr('class','vertex-ring').attr('r',7).attr('fill','#fff').attr('stroke', d=>d.h.color).attr('stroke-width',2).style('stroke-opacity',0.95);
  vwrap.append('circle').attr('class','vertex-dot').attr('r',5).attr('fill', d=>d.h.color).attr('stroke','none');
  // ensure vertex groups render on top of polygons/axes
  try{ vwrap.raise(); }catch(e){}
  }

  // ---------- Heatmap
  function renderHeatmap(container, C, Hy){
    const pad={t:30,r:10,b:30,l:180}; const w=container.clientWidth, h=container.clientHeight; const svg=d3.select(container).append('svg');
    const hySel=Data.hypotheses.filter(h=>state.selected.has(h.id));
    const x=d3.scaleBand().domain(hySel.map(d=>d.id)).range([pad.l,w-pad.r]).padding(0.08);
    const y=d3.scaleBand().domain(Data.criteria.map(d=>d.id)).range([pad.t,h-pad.b]).padding(0.08);
  const cellFill=v=> v<1/3?'var(--line)':(v<2/3?'var(--cell-mid)':'var(--cell-high)');

    svg.append('g').selectAll('text').data(Data.criteria).join('text')
      .attr('x', pad.l-8).attr('y', d=> y(d.id)+y.bandwidth()/2)
      .attr('text-anchor','end').attr('dominant-baseline','middle').style('fill','var(--muted)').text(d=>d.short).append('title').text(d=>d.anchors.join(' / '));
    svg.append('g').selectAll('text').data(hySel).join('text')
      .attr('x', d=> x(d.id)+x.bandwidth()/2).attr('y', pad.t-10)
      .attr('text-anchor','middle').attr('fill', d=>d.color).text(d=>d.label);

    svg.append('g').selectAll('rect').data(Data.criteria.flatMap(c=>hySel.map(h=>({c,h}))))
      .join('rect').attr('x', d=>x(d.h.id)).attr('y', d=>y(d.c.id)).attr('width', x.bandwidth()).attr('height', y.bandwidth()).attr('rx',4)
      .attr('fill', d=> cellFill(Hy[d.h.id].scores[d.c.id])).attr('stroke', d=>Hy[d.h.id].color)
  .on('mousemove', (e,d)=>{
    if(state.pinned) return; // don't override a pinned tooltip
    const raw=Hy[d.h.id].scores[d.c.id]; const level=ordinalLabel(d.c.id, raw, C); const note=(Hy[d.h.id].notes||{})[d.c.id]||''; const qhtml=quoteHTML(Hy, d.h.id, d.c.id);
  const html=`<div style='font-weight:600'>${d.h.label}</div><div>${C[d.c.id].label}</div><div>Level: <strong>${level}</strong></div>`+(note?`<div style='margin-top:4px;color:var(--muted)'>${note}</div>`:'')+qhtml;
    tt.html(html).style('left', (e.clientX+12)+'px').style('top', (e.clientY-12)+'px').style('display','block');
  })
      .on('mouseleave', ()=> scheduleHide());
  }

  // try to auto-load the local data file; fall back to a brief instruction if fetch fails
  (async function(){
    try{
      const resp = await fetch('data/resurrection-data.json');
      if(!resp.ok) throw new Error(resp.status + ' ' + resp.statusText);
      const txt = await resp.text();
      loadFromText(txt);
  if(loader) loader.style.display = 'none';
    }catch(err){
      const exampleHint = document.createElement('div');
      exampleHint.className='small';
      exampleHint.style.padding='10px 14px';
      exampleHint.innerHTML = 'Failed to load <code>data/resurrection-data.json</code>. Use <b>Load JSON file</b> or paste a URL into the input.';
      document.getElementById('main').prepend(exampleHint);
      if(loader) loader.style.display = 'none';
      console.warn('Auto-load failed:', err);
    }
  })();

  // Recenter / re-render the chart when the window is resized (debounced)
  let _resizeTimer = null;
  window.addEventListener('resize', ()=>{
    clearTimeout(_resizeTimer);
    _resizeTimer = setTimeout(()=>{ if(Data) render(); }, 150);
  });
  // Mobile viewport fix: set a CSS variable --vh to the actual viewport height
  // This prevents issues on iOS/Chrome where 100vh includes browser chrome and can push content off-screen.
  (function(){
    function setVh(){
      const h = (window.visualViewport && window.visualViewport.height) ? window.visualViewport.height : window.innerHeight;
      document.documentElement.style.setProperty('--vh', (h * 0.01) + 'px');
      // re-render to respect the new height
      if(Data) render();
    }
    // initial
    setVh();
    // update on relevant events
    if(window.visualViewport){
      window.visualViewport.addEventListener('resize', setVh);
      window.visualViewport.addEventListener('scroll', setVh);
    }
    window.addEventListener('orientationchange', setVh);
    window.addEventListener('resize', setVh);
  })();
  </script>
</body>
</html>