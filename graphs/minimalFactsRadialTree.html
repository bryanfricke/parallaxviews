<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <title>Tidy Tree</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
        #topbar {
            display: flex;
            align-items: center;
            gap: 16px;
            padding: 8px 24px;
            background: var(--bg-light);
            border-bottom: 1px solid #e0e0e0;
            min-height: 48px;
        }
        body.dark-mode #topbar {
            background: var(--bg-dark);
            border-bottom: 1px solid var(--link-dark);
        }
        #topbar label, #topbar button {
            margin: 0 4px;
        }
        #topbar label {
            font-weight: 500;
            color: inherit;
            display: flex;
            align-items: center;
            gap: 4px;
        }
        #topbar button {
            background: linear-gradient(90deg, #00BFAE 0%, #0074d9 100%);
            color: #fff;
            border: none;
            border-radius: 6px;
            padding: 6px 16px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0,0,0,0.06);
            transition: background 0.2s, box-shadow 0.2s, color 0.2s;
        }
        #topbar button:hover, #topbar button:focus {
            background: linear-gradient(90deg, #00E6B2 0%, #005fa3 100%);
            color: #fff;
            box-shadow: 0 4px 16px rgba(0,0,0,0.10);
        }
        body.dark-mode #topbar button {
            background: linear-gradient(90deg, var(--accent-dark) 0%, #005fa3 100%);
            color: var(--text-dark);
        }
        body.dark-mode #topbar button:hover, body.dark-mode #topbar button:focus {
            background: linear-gradient(90deg, var(--node-hover-stroke-dark) 0%, #003d5c 100%);
            color: var(--text-dark);
        }
        #topbar input[type="checkbox"] {
            accent-color: #00BFAE;
            width: 16px;
            height: 16px;
            margin-right: 4px;
        }
        body.dark-mode #topbar input[type="checkbox"] {
            accent-color: var(--accent-dark);
        }
        #topbar > * {
            margin-right: 8px;
        }
        #topbar > *:last-child {
            margin-right: 0;
        }
        :root {
            --bg-light: #fff;
            --bg-dark: #181A20;
            --panel-dark: #23272F;
            --node-fill-dark: #263238;
            --node-stroke-dark: #00BFAE;
            --node-hover-fill-dark: #374151;
            --node-hover-stroke-dark: #00E6B2;
            --link-dark: #3B4252;
            --text-dark: #E0E7EF;
            --text-secondary-dark: #A0AEC0;
            --accent-dark: #00BFAE;
            --tooltip-bg-dark: #23272F;
            --tooltip-border-dark: #00BFAE;
        }

        body {
            margin: 0;
            font: 14px/1.4 system-ui, sans-serif;
            overflow: hidden;
            background: var(--bg-light);
            color: #222;
            transition: background 0.3s, color 0.3s;
        }

        body.dark-mode {
            background: var(--bg-dark);
            color: var(--text-dark);
        }

        body.dark-mode #topbar {
            background: var(--bg-dark);
            border-bottom: 1px solid var(--link-dark);
            color: var(--text-dark);
        }

        #chart {
            width: 100vw;
            height: calc(100vh - 48px);
            overflow: hidden;
            background: var(--bg-light);
        }

        body.dark-mode #chart {
            background: var(--bg-dark);
        }

        svg {
            width: 100%;
            height: 100%;
            display: block;
            background: transparent;
        }

        .link {
            fill: none;
            stroke: #ccc;
            stroke-width: 1.5px;
        }

        body.dark-mode .link {
            stroke: var(--link-dark);
        }

        .node circle {
            r: 5;
            cursor: pointer;
            stroke: #333;
            stroke-width: 1px;
            fill: #fff;
            transition: fill 0.2s, stroke 0.2s;
        }

        .node circle {
            fill: #e0f7fa;
            stroke: #00796b;
        }

        body.dark-mode .node circle {
            fill: var(--node-fill-dark);
            stroke: var(--node-stroke-dark);
        }

        .node:hover circle {
            fill: #b2ebf2;
            stroke: #004d40;
        }

        body.dark-mode .node:hover circle {
            fill: var(--node-hover-fill-dark);
            stroke: var(--node-hover-stroke-dark);
        }

        .node text {
            font-size: 12px;
            dominant-baseline: middle;
            paint-order: stroke;
            stroke: #fff;
            stroke-width: 4px;
            stroke-linejoin: round;
        }

        .node text tspan {
            paint-order: stroke;
            stroke: #fff;
            stroke-width: 4px;
            stroke-linejoin: round;
        }

        .node text .label {
            fill: #222;
            stroke: none;
        }

        body.dark-mode .node text {
            fill: var(--text-dark) !important;
            stroke: var(--bg-dark) !important;
        }

        body.dark-mode .node text .label {
            fill: var(--text-dark) !important;
            stroke: none !important;
        }

        .tooltip {
            position: fixed;
            pointer-events: auto;
            background: #fff;
            border: 1px solid #ddd;
            padding: 8px 10px;
            border-radius: 6px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, .08);
            max-width: 320px;
            font-size: 13px;
            z-index: 1000;
        }

        .popup-help {
            position: fixed;
            pointer-events: auto;
            background: #fff;
            border: 1px solid #ddd;
            padding: 8px 10px;
            border-radius: 6px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, .08);
            max-width: 320px;
            font-size: 13px;
            z-index: 1001;
        }

        body.dark-mode .tooltip,
        body.dark-mode .popup-help {
            background: var(--tooltip-bg-dark) !important;
            border: 1px solid var(--tooltip-border-dark) !important;
            color: var(--text-dark) !important;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.32) !important;
        }

        body.dark-mode .tooltip a,
        body.dark-mode .popup-help a {
            color: var(--accent-dark) !important;
            text-decoration: underline;
        }

        body.dark-mode .tooltip a:hover,
        body.dark-mode .popup-help a:hover {
            color: var(--node-hover-stroke-dark) !important;
        }

        .node.clickable text {
            fill: #0074d9;
            cursor: pointer;
            text-decoration: none;
        }

        .node.clickable:hover text {
            fill: #005fa3;
            text-decoration: none;
        }
    </style>
</head>

<body class="dark-mode">
    <div id="topbar">
        <strong style="font-size:18px; letter-spacing:0.5px; margin-right:16px;">Tidy Tree</strong>
        <label style="display:none;"><input type="checkbox" id="wrap"> Wrap labels</label>
    <label><input type="checkbox" id="clusterToggle"> Cluster layout</label>
    <label><input type="checkbox" id="radialToggle"> Radial layout</label>
        <label style="display:none;">Node size: <input type="range" id="nodesize" min="10" max="100" value="20"></label>
        <label style="display:none;">Vertical spacing: <input type="range" id="nodesizeY" min="10" max="150" value="60"></label>
        <label style="display:none;">Horizontal spacing: <input type="range" id="nodesizeX" min="10" max="300" value="180"></label>
        <button id="collapseAll">Collapse All</button>
        <button id="expandAll">Expand All</button>
        <button id="collapseOneLevel">Collapse One Level</button>
        <button id="expandOneLevel">Expand One Level</button>
        <label style="margin-left:auto;"><input type="checkbox" id="darkModeToggle"> Dark mode</label>
    </div>
    <div id="chart"></div>

    <!-- D3 v7 -->
    <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
    <script>
        async function init() {
            let response = await fetch('data/ResurrectionDisciplesBelievedItActs01.json');
            let data = await response.json();

            // === 2) Basic settings ===
            const container = document.getElementById('chart');
            const width = container.clientWidth;
            const height = container.clientHeight;

            const svg = d3.select("#chart").append("svg")
                .attr("width", width).attr("height", height);

            // Create a main group for zoom/pan
            const g = svg.append("g");
            // Create links and nodes groups in correct order
            const linkGroup = g.append("g").attr("class", "links");
            const nodeGroup = g.append("g").attr("class", "nodes");

            const zoom = d3.zoom().scaleExtent([0.4, 2.5]).on("zoom", (event) => {
                g.attr("transform", event.transform);
                updatePopupHelpPosition();
            });
            svg.call(zoom);

            const tooltip = d3.select("body").append("div")
                .attr("class", "tooltip").style("opacity", 0);
            // Add a separate popup help element
            const popupHelp = d3.select("body").append("div")
                .attr("class", "popup-help").style("opacity", 0).style("position", "fixed");

            // Minimal robust popup help tracking
            let popupHelpNode = null;

            function updatePopupHelpPosition() {
                if (!popupHelpNode) return;
                // Use tree layout coordinates
                let x = popupHelpNode.x;
                let y = popupHelpNode.y;
                // Get current transform
                const transform = d3.zoomTransform(svg.node());
                // Apply D3 transform to node coordinates
                const transformed = transform.apply([y, x]);
                // Convert SVG coordinates to screen coordinates
                const point = svg.node().createSVGPoint();
                point.x = transformed[0];
                point.y = transformed[1];
                const ctm = svg.node().getScreenCTM();
                if (ctm) {
                    const screenPoint = point.matrixTransform(ctm);
                    popupHelp.style("left", (screenPoint.x + 24) + "px")
                        .style("top", (screenPoint.y + 24) + "px");
                }
            }

            // Collapsible tree helpers
            function collapse(d) {
                if (d.children) { d._children = d.children; d._children.forEach(collapse); d.children = null; }
            }
            function expand(d) {
                if (d._children) { d.children = d._children; d._children = null; }
            }

            const root = d3.hierarchy(data);
            root.x0 = height / 2;
            root.y0 = 0;
            root.children && root.children.forEach(collapse); // start collapsed


            // Default to cluster layout
            let treeLayout = d3.cluster();
            treeLayout.nodeSize([20, 200]); // vertical spacing, horizontal spacing
            let isRadial = false;

            // Controls
            const nodeSizeYInput = document.getElementById('nodesizeY');
            const nodeSizeXInput = document.getElementById('nodesizeX');
            nodeSizeYInput.addEventListener('input', updateNodeSize);
            nodeSizeXInput.addEventListener('input', updateNodeSize);
            function updateNodeSize() {
                const y = +nodeSizeYInput.value;
                const x = +nodeSizeXInput.value;
                treeLayout.nodeSize([y, x]);
                update(root);
            }
            // const tree = d3.tree().nodeSize([120, 200]); // vertical spacing, horizontal spacing

            const nodeSizeInput = document.getElementById('nodesize');
            nodeSizeInput.addEventListener('input', () => {
                const v = +nodeSizeInput.value;
                treeLayout.nodeSize([v, v + 80]);
                update(root);
            });
            const wrapToggle = document.getElementById('wrap');

            // Word wrap helper
            function wrapText(selection, width = 160) {
                selection.each(function (d) {
                    const text = d3.select(this);
                    const words = (text.text() || "").split(/\s+/).reverse();
                    let line = [], lineNumber = 0;
                    // Set x based on node type
                    const x = (d.children || d._children) ? -10 : 10;
                    let tspan = text.text(null).append("tspan").attr("x", x).attr("dy", "0em");
                    let word, lineHeight = 1.1;
                    while (word = words.pop()) {
                        line.push(word);
                        tspan.text(line.join(" "));
                        if (tspan.node().getComputedTextLength() > width) {
                            line.pop();
                            tspan.text(line.join(" "));
                            line = [word];
                            tspan = text.append("tspan")
                                .attr("x", x)
                                .attr("dy", ++lineNumber * lineHeight + "em")
                                .text(word);
                        }
                    }
                });
            }

            // Color per node (inherit from ancestors if not set)
            function nodeColor(d) {
                let x = d;
                while (x) {
                    if (x.data && x.data.color) return x.data.color;
                    x = x.parent;
                }
                return "#6c6c6c";
            }


            // Layout toggles
            const clusterToggle = document.getElementById('clusterToggle');
            const radialToggle = document.getElementById('radialToggle');
            // Default cluster toggle to checked, radial to unchecked
            clusterToggle.checked = true;
            radialToggle.checked = false;
            clusterToggle.addEventListener('change', function () {
                if (clusterToggle.checked) {
                    treeLayout = d3.cluster();
                    isRadial = false;
                } else {
                    treeLayout = d3.tree();
                    isRadial = false;
                }
                // Uncheck radial if cluster/tree is selected
                radialToggle.checked = false;
                // Keep node size settings
                const y = +nodeSizeYInput.value;
                const x = +nodeSizeXInput.value;
                treeLayout.nodeSize([y, x]);
                update(root);
            });
            radialToggle.addEventListener('change', function () {
                if (radialToggle.checked) {
                    isRadial = true;
                    clusterToggle.checked = false;
                } else {
                    isRadial = false;
                    clusterToggle.checked = true;
                }
                update(root);
            });

            function projectRadial(x, y) {
                const angle = (x - 90) / 180 * Math.PI;
                return [y * Math.cos(angle), y * Math.sin(angle)];
            }

            function update(source) {
                if (isRadial) {
                    // Use cluster layout for radial, but interpret as polar
                    treeLayout = d3.cluster();
                    treeLayout.size([360, Math.min(width, height) / 2 - 80]);
                    treeLayout(root);
                } else {
                    // Use nodeSize for cluster/tree
                    const y = +nodeSizeYInput.value;
                    const x = +nodeSizeXInput.value;
                    treeLayout.nodeSize([y, x]);
                    treeLayout(root);
                }
                const nodes = root.descendants();
                const links = root.links();

                // nodes.forEach(d => d.y = d.depth * 180); // horizontal spacing per depth

                // LINKS (drawn first, behind nodes)
                const link = linkGroup.selectAll("path.link").data(links, d => d.target.id || (d.target.id = crypto.randomUUID()));
                if (isRadial) {
                    link.enter().append("path")
                        .attr("class", "link")
                        .attr("d", d => {
                            const s = projectRadial(d.source.x, d.source.y);
                            const t = projectRadial(d.target.x, d.target.y);
                            return `M${s[0]},${s[1]}C${(s[0]+t[0])/2},${(s[1]+t[1])/2} ${(s[0]+t[0])/2},${(s[1]+t[1])/2} ${t[0]},${t[1]}`;
                        })
                        .merge(link)
                        .transition().duration(350)
                        .attr("d", d => {
                            const s = projectRadial(d.source.x, d.source.y);
                            const t = projectRadial(d.target.x, d.target.y);
                            return `M${s[0]},${s[1]}C${(s[0]+t[0])/2},${(s[1]+t[1])/2} ${(s[0]+t[0])/2},${(s[1]+t[1])/2} ${t[0]},${t[1]}`;
                        });
                    link.exit().transition().duration(250)
                        .attr("d", d => {
                            const s = projectRadial(d.source.x, d.source.y);
                            const t = projectRadial(d.target.x, d.target.y);
                            return `M${s[0]},${s[1]}C${(s[0]+t[0])/2},${(s[1]+t[1])/2} ${(s[0]+t[0])/2},${(s[1]+t[1])/2} ${t[0]},${t[1]}`;
                        })
                        .remove();
                } else {
                    link.enter().append("path")
                        .attr("class", "link")
                        .attr("d", d3.linkHorizontal().x(d => source.y0).y(d => source.x0))
                        .merge(link)
                        .transition().duration(350)
                        .attr("d", d3.linkHorizontal().x(d => d.y).y(d => d.x));
                    link.exit().transition().duration(250)
                        .attr("d", d3.linkHorizontal().x(d => source.y).y(d => source.x))
                        .remove();
                }

                // NODES (drawn above links)
                const node = nodeGroup.selectAll("g.node").data(nodes, d => d.id || (d.id = crypto.randomUUID()));

                const nodeEnter = node.enter().append("g")
                    .attr("class", d => {
                        if (!d.children && !d._children && d.data.source && d.data.source.url) {
                            return "node clickable";
                        }
                        return "node";
                    })
                    .attr("transform", d => {
                        if (isRadial) {
                            const [x, y] = projectRadial(source.x0, source.y0);
                            return `translate(${x},${y})`;
                        } else {
                            return `translate(${source.y0},${source.x0})`;
                        }
                    })
                    .on("click", (event, d) => {
                        if (!d.children && !d._children && d.data.source && d.data.source.url) {
                            let html = `<strong>${d.data.name}</strong>`;
                            if (d.data.date) html += `<div style='margin-top:4px; font-weight:bold;'>${d.data.date}</div>`;
                            if (d.data.details) html += `<div style='margin-top:6px;'>${d.data.details}</div>`;
                            html += `<div style='margin-top:10px;'><a href='${d.data.source.url}' target='_blank' style='color:blue;text-decoration:underline;'>${d.data.source.title || "View Source"}</a></div>`;
                            popupHelp.html(html)
                                .style("opacity", 1)
                                .style("pointer-events", "auto");
                            popupHelpNode = d;
                            updatePopupHelpPosition();
                            setTimeout(() => {
                                document.addEventListener('mousedown', popupHelpOutsideClickHandler, true);
                            }, 0);
                        } else {
                            if (!d.children && d._children) {
                                expand(d);
                                if (d.children) d.children.forEach(expandAllRecursive);
                            } else {
                                collapse(d);
                            }
                            update(d);
                            popupHelp.style("opacity", 0)
                                .style("pointer-events", "none");
                            document.removeEventListener('mousedown', popupHelpOutsideClickHandler, true);
                            popupHelpNode = null;
                        }
                    })
                    .on("mouseenter", (event, d) => {
                        const txt = d.data.subtitle || "";
                        if (!txt) return;
                        tooltip.html(txt)
                            .style("opacity", 1)
                            .style("pointer-events", "none")
                            .style("left", (event.clientX + 24) + "px")
                            .style("top", (event.clientY + 24) + "px");
                    })
                    .on("mousemove", (event) => {
                        tooltip.style("left", (event.clientX + 24) + "px")
                            .style("top", (event.clientY + 24) + "px");
                    })
                    .on("mouseleave", () => {
                        tooltip.style("opacity", 0);
                    });
                // Remove mouseleave handler so tooltip doesn't disappear immediately

                // Helper to hide popup help only when clicking outside
                function popupHelpOutsideClickHandler(e) {
                    const popupEl = popupHelp.node();
                    if (popupHelp.style("opacity") === "1" && (!popupEl || (e.target !== popupEl && !popupEl.contains(e.target)))) {
                        popupHelp.style("opacity", 0)
                            .style("pointer-events", "none");
                        document.removeEventListener('mousedown', popupHelpOutsideClickHandler, true);
                        // Quickfix: dispatch mouseleave to node under popup
                        if (popupHelpNode) {
                            // Find the corresponding SVG node group
                            const nodeGroup = d3.selectAll('g.node').filter(d => d === popupHelpNode);
                            nodeGroup.select('text').each(function () {
                                const evt = new MouseEvent('mouseleave', { bubbles: true });
                                this.dispatchEvent(evt);
                            });
                        }
                        popupHelpNode = null;
                    }
                }

                nodeEnter.append("circle")
                    .attr("r", 1e-6)
                    .attr("fill", d => (d._children ? nodeColor(d) : "#fff"))
                    .attr("stroke", d => nodeColor(d));

                const labels = nodeEnter.append("text")
                    .attr("dy", "0em")
                    .attr("x", d => {
                        if (isRadial) {
                            return d.children || d._children ? -10 : 10;
                        } else {
                            return (d.children || d._children) ? -10 : 10;
                        }
                    })
                    .attr("text-anchor", d => {
                        if (isRadial) {
                            return d.x < 180 ? "start" : "end";
                        } else {
                            return (d.children || d._children) ? "end" : "start";
                        }
                    })
                    .attr("transform", d => {
                        if (isRadial) {
                            let angle = d.x;
                            let y = d.y;
                            let rotate = angle < 180 ? angle - 90 : angle + 90;
                            return `rotate(${rotate})`;
                        } else {
                            return null;
                        }
                    })
                    .html(d => d.data.link
                        ? `<a href="${d.data.link}" target="_blank" style="fill:blue;text-decoration:underline">${d.data.name}</a>`
                        : d.data.name);

                function applyLabelWrapping() {
                    g.selectAll("g.node text").each(function (d) {
                        const text = d3.select(this);
                        text.text(d.data.name);
                        if (wrapToggle.checked) wrapText(text, 160);
                    });
                }
                applyLabelWrapping();
                wrapToggle.onchange = applyLabelWrapping;

                // UPDATE + TRANSITIONS
                const nodeUpdate = nodeEnter.merge(node);
                nodeUpdate.transition().duration(350)
                    .attr("transform", d => {
                        if (isRadial) {
                            const [x, y] = projectRadial(d.x, d.y);
                            return `translate(${x},${y})`;
                        } else {
                            return `translate(${d.y},${d.x})`;
                        }
                    })
                    .on("end", () => { updatePopupHelpPosition(); });
                nodeUpdate.select("circle").transition().duration(350)
                    .attr("r", 6)
                    .attr("fill", d => (d._children ? nodeColor(d) : "#fff"))
                    .attr("stroke", d => nodeColor(d));
                nodeUpdate.select("text").transition().duration(350)
                    .attr("x", d => {
                        if (isRadial) {
                            return d.children || d._children ? -10 : 10;
                        } else {
                            return (d.children || d._children) ? -10 : 10;
                        }
                    })
                    .attr("text-anchor", d => {
                        if (isRadial) {
                            return d.x < 180 ? "start" : "end";
                        } else {
                            return (d.children || d._children) ? "end" : "start";
                        }
                    })
                    .attr("transform", d => {
                        if (isRadial) {
                            let angle = d.x;
                            let y = d.y;
                            let rotate = angle < 180 ? angle - 90 : angle + 90;
                            return `rotate(${rotate})`;
                        } else {
                            return null;
                        }
                    });

                const nodeExit = node.exit().transition().duration(250)
                    .attr("transform", d => {
                        if (isRadial) {
                            const [x, y] = projectRadial(source.x, source.y);
                            return `translate(${x},${y})`;
                        } else {
                            return `translate(${source.y},${source.x})`;
                        }
                    })
                    .remove();
                nodeExit.select("circle").attr("r", 1e-6);

                // Stash positions for smooth transitions next time
                nodes.forEach(d => { d.x0 = d.x; d.y0 = d.y; });
            }


            update(root);

            // Center root nicely
            if (isRadial) {
                svg.call(zoom.transform, d3.zoomIdentity.translate(width/2, height/2).scale(1));
            } else {
                svg.call(zoom.transform, d3.zoomIdentity.translate(60, height / 2).scale(1));
            }

            // Collapse or expand all nodes
            function collapseAll(d) {
                if (d.children) {
                    d.children.forEach(collapseAll);
                    collapse(d);
                }
            }
            function expandAll(d) {
                if (d._children) {
                    expand(d);
                    d.children.forEach(expandAll);
                } else if (d.children) {
                    d.children.forEach(expandAll);
                }
            }

            document.getElementById('collapseAll').onclick = () => {
                root.children && root.children.forEach(collapseAll);
                update(root);
            };
            document.getElementById('expandAll').onclick = () => {
                root.children && root.children.forEach(expandAll);
                update(root);
            };

            let lastCollapsed = new Set();

            // Utilities (standard D3 tree togglers)
            function collapse(d) {
                if (d.children) {
                    d._children = d.children;
                    d.children = null;
                }
            }
            function expand(d) {
                if (d._children) {
                    d.children = d._children;
                    d._children = null;
                }
            }

            // Helper to get a stable id for a node (adjust to your data)
            function nodeKey(d) {
                // Prefer a stable id if you have one:
                return d.id ?? d.data?.id ?? d.data?.name ?? d; // fallback to object ref
            }

            // COLLAPSE ONE LEVEL (same behavior as yours, but records which nodes it collapses)
            document.getElementById('collapseOneLevel').onclick = () => {
                lastCollapsed.clear();

                const candidates = root.descendants().filter(d => d.children && d.children.length > 0);
                candidates.forEach(d => {
                    const allChildrenAreLeavesOrCollapsed = d.children.every(
                        c => !c.children || c.children.length === 0
                    );
                    if (allChildrenAreLeavesOrCollapsed) {
                        collapse(d);
                        lastCollapsed.add(nodeKey(d));   // remember this exact node
                    }
                });

                update(root);
            };


            // // Collapse only visible nodes with children whose children are all leaves or collapsed
            // document.getElementById('collapseOneLevel').onclick = () => {
            //     // Find all visible nodes with children
            //     const candidates = root.descendants().filter(d => d.children && d.children.length > 0);
            //     // Only collapse those whose children are all leaves or already collapsed
            //     candidates.forEach(d => {
            //         const allChildrenAreLeavesOrCollapsed = d.children.every(
            //             c => !c.children || c.children.length === 0
            //         );
            //         if (allChildrenAreLeavesOrCollapsed) {
            //             collapse(d);
            //         }
            //     });
            //     update(root);
            // };

            // // Expand only hidden (collapsed) nodes whose hidden children are all leaves or collapsed
            // document.getElementById('expandOneLevel').onclick = () => {
            //     // Find all nodes that are currently collapsed (have _children)
            //     // const candidates = root.descendants().filter(d => d._children && d._children.length > 0);

            //     // Only expand those whose hidden children are all leaves or already collapsed
            //     candidates.forEach(d => {
            //         const allHiddenChildrenAreLeavesOrCollapsed = d._children.every(
            //             c => !c.children || c.children.length === 0
            //         );
            //         if (allHiddenChildrenAreLeavesOrCollapsed) {
            //             expand(d);  // assumes your expand(d) does: d.children = d._children; d._children = null;
            //         }
            //     });

            //     update(root);
            // };

            document.getElementById('expandOneLevel').onclick = () => {
                if (lastCollapsed.size > 0) {
                    root.descendants().forEach(d => {
                        if (d._children && lastCollapsed.has(nodeKey(d))) expand(d);
                    });
                    lastCollapsed.clear();
                } else {
                    // Fallback: expand nodes that are currently collapsed and whose hidden children are all leaves/collapsed
                    root.descendants()
                        .filter(d => d._children && d._children.length > 0)
                        .forEach(d => {
                            const ok = d._children.every(c => !c.children || c.children.length === 0);
                            if (ok) expand(d);
                        });
                }
                update(root);
            };

            // By default, expand all nodes
            root.children && root.children.forEach(function expandAll(d) {
                if (d._children) {
                    expand(d);
                    d.children.forEach(expandAll);
                } else if (d.children) {
                    d.children.forEach(expandAll);
                }
            });
            update(root);
        }

        // Place helper at top-level scope so it's available everywhere
        // Ensure expand is defined at top-level scope before expandAllRecursive
        function collapse(d) {
            if (d.children) { d._children = d.children; d._children.forEach(collapse); d.children = null; }
        }
        function expand(d) {
            if (d._children) { d.children = d._children; d._children = null; }
        }
        function expandAllRecursive(d) {
            if (d._children) {
                expand(d);
                if (d.children) d.children.forEach(expandAllRecursive);
            } else if (d.children) {
                d.children.forEach(expandAllRecursive);
            }
        }

        init();

        // Dark mode toggle
        const darkModeToggle = document.getElementById('darkModeToggle');
        darkModeToggle.checked = true;
        document.body.classList.add('dark-mode');
        darkModeToggle.addEventListener('change', function () {
            document.body.classList.toggle('dark-mode', darkModeToggle.checked);
        });
    </script>
</body>

</html>