<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Theistic Arguments and Divine Attributes</title>
  <!-- Favicons: SVG primary with PNG fallbacks and webmanifest -->
  <!-- Use relative paths so files resolve correctly when hosted under a repo subpath (e.g. /parallaxviews) -->
  <link rel="icon" href="../assets/icons/favicon.svg" type="image/svg+xml">
  <link rel="icon" href="../assets/icons/favicon-32.png" sizes="32x32" type="image/png">
  <link rel="icon" href="../assets/icons/favicon-16.png" sizes="16x16" type="image/png">
  <link rel="apple-touch-icon" href="../assets/icons/apple-touch-icon.png" sizes="180x180">
  <link rel="manifest" href="../site.webmanifest">
  <link rel="mask-icon" href="../assets/icons/safari-pinned-tab.svg" color="#00BFAE">
  <meta name="theme-color" content="#071022">
  <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
  <script src="https://cdn.jsdelivr.net/npm/d3-sankey@0.12.3/dist/d3-sankey.min.js"></script>
  <style>
    /* Visually-hidden helpers for screen readers */
    .sr-only {
      position: absolute !important;
      width: 1px !important;
      height: 1px !important;
      padding: 0 !important;
      margin: -1px !important;
      overflow: hidden !important;
      clip: rect(0, 0, 0, 0) !important;
      white-space: nowrap !important;
      border: 0 !important;
    }
    /* When the sr-only element receives focus, make it visible so keyboard users can read it */
    .sr-only.sr-focusable:active, .sr-only.sr-focusable:focus {
      position: static !important;
      width: auto !important;
      height: auto !important;
      margin: 0 !important;
      overflow: visible !important;
      clip: auto !important;
      white-space: normal !important;
    }

    :root {
      --bg: #ffffff;
      --fg: #0f172a;
      --muted: #475569;
      --muted-dark: #374151;
      --accent: #2563eb;
      --chip-bg: #e2e8f0;
      --attr-fill: #94a3b8;
      --text-glow-color: rgba(255, 255, 255, 0.9);
      --node-selection-color: rgba(255, 255, 255, 0.6);
      
      /* Light mode argument colors (ColorBrewer Set1) - default */
      --kalam-color: #1B9E77;
      --leibniz-color: #D95F02;
      --teleological-color: #7570B3;
      --moral-color: #E7298A;
      --ontological-color: #66A61E;
      
      /* Light mode attribute colors - default */
      --timeless-color: #1F78B4;
      --personal-color: #FDBF6F;
      --necessary-color: #CAB2D6;
      --designer-color: #E31A1C;
      --good-color: #6A3D9A;
      --max-great-color: #FF7F00;
    }
    @media (prefers-color-scheme: dark) {
      :root {
        --bg: #0b0f1a;
        --fg: #e5e7eb;
        --muted: #9ca3af;
        --muted-dark: #94a3b8;
        --accent: #60a5fa;
        --chip-bg: #111827;
        --attr-fill: #64748b;
        --text-glow-color: rgba(248, 250, 252, 0.8);
        --node-selection-color: rgba(248, 250, 252, 0.6);
        
        /* Dark mode argument colors (ColorBrewer Set2) */
        --kalam-color: #66C2A5;
        --leibniz-color: #FC8D62;
        --teleological-color: #8DA0CB;
        --moral-color: #E78AC3;
        --ontological-color: #A6D854;
        
        /* Dark mode attribute colors (ColorBrewer Set3) */
        --timeless-color: #8DD3C7;
        --personal-color: #FFFFB3;
        --necessary-color: #BEBADA;
        --designer-color: #FB8072;
        --good-color: #80B1D3;
        --max-great-color: #FDB462;
      }
    }
    /* explicit dark-mode override when user toggles theme via data-theme attribute */
    :root[data-theme="dark"]{
      --bg: #071022;
      --fg: #e6eef8;
      --muted: #cbd6e1;
      --muted-dark: #94a3b8;
      --accent: #93c5fd;
      --chip-bg: #0f1724;
      --attr-fill: #7b8794;
      --text-glow-color: rgba(248, 250, 252, 0.8);
      --node-selection-color: rgba(248, 250, 252, 0.6);
      
      /* Dark mode argument colors (existing ColorBrewer Set2) */
      --kalam-color: #66C2A5;
      --leibniz-color: #FC8D62;
      --teleological-color: #8DA0CB;
      --moral-color: #E78AC3;
      --ontological-color: #A6D854;
      
      /* Dark mode attribute colors (existing ColorBrewer Set3) */
      --timeless-color: #8DD3C7;
      --personal-color: #FFFFB3;
      --necessary-color: #BEBADA;
      --designer-color: #FB8072;
      --good-color: #80B1D3;
      --max-great-color: #FDB462;
    }
    /* explicit light-mode override so user choice wins over prefers-color-scheme */
    :root[data-theme="light"]{
      --bg: #ffffff;
      --fg: #0f172a;
      --muted: #475569;
      --muted-dark: #374151;
      --accent: #2563eb;
      --chip-bg: #e2e8f0;
      --attr-fill: #94a3b8;
      --text-glow-color: rgba(255, 255, 255, 0.9);
      --node-selection-color: rgba(255, 255, 255, 0.6);
      
      /* Light mode argument colors (ColorBrewer Set1) */
      --kalam-color: #1B9E77;
      --leibniz-color: #D95F02;
      --teleological-color: #7570B3;
      --moral-color: #E7298A;
      --ontological-color: #66A61E;
      
      /* Light mode attribute colors */
      --timeless-color: #1F78B4;
      --personal-color: #FDBF6F;
      --necessary-color: #CAB2D6;
      --designer-color: #E31A1C;
      --good-color: #6A3D9A;
      --max-great-color: #FF7F00;
    }
    html, body { height: 100%; margin: 0; background: var(--bg); color: var(--fg); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica Neue, Arial; }
  /* Remove vertical margins to prevent cumulative height overflow and use padding instead. */
  /* Respect safe-area insets on iOS (adds no-op 0px fallback for other browsers). */
  .wrap { max-width: 1100px; margin: 0 auto; padding: 20px calc(16px + env(safe-area-inset-right, 0px)) 20px calc(16px + env(safe-area-inset-left, 0px)); box-sizing: border-box; }
  .page-header{ display:flex; align-items:center; justify-content:space-between; gap:12px; flex-wrap:nowrap; padding:12px 0 8px 0; }
    h1 { font-size: 20px; line-height: 1.1; margin: 0; font-weight: 700; flex: 1 1 auto; min-width: 0; }

  /* Small viewport adjustments: keep header inline and reduce sizes so button doesn't wrap */
  @media (max-width:520px){
    .page-header{ gap:10px; }
    .page-header h1{ font-size:16px; }
    .theme-btn{ height:32px; width:32px }
  }
    p.subtitle { margin: 0 0 12px 0; color: var(--muted); font-size: 14px; }

    .legend { display: flex; gap: 10px; align-items: center; font-size: 12px; color: var(--muted); margin: 8px 0 10px 0; flex-wrap: wrap; }
    .legend .chip { display:inline-flex; align-items:center; gap:8px; background: var(--chip-bg); color: var(--fg); border: 1px solid rgba(148,163,184,.35); padding: 6px 10px; border-radius: 999px; font-size: 12px; user-select:none; }
    .legend .swatch { width:12px; height:12px; border-radius:2px; display:inline-block; }

    /* Desktop baseline height (will be overridden by a dynamic var if available). */
    svg { width:100%; height: calc(100vh - 80px); display:block; border-radius:16px; overflow: visible; }
    @media (min-width:601px){
      /* Use dynamic header + top spacing variable if JS sets --header-total. Provide fallback (120px). */
      svg#chart { height: calc(100dvh - var(--header-total, 120px)); }
      body.no-extra-scroll { overflow:hidden; }
    }

  /* Smaller chart height on narrow viewports so it fits mobile screens more comfortably */
  @media (max-width: 600px) {
    /* Use the smaller of a vh-based height or the dynamic viewport minus an offset
       so the chart reliably fits on phones (accounts for browser UI chrome). */
    svg { height: min(80vh, calc(100dvh - 50px)); }
  }

  /* Node rectangles: keep fully opaque so links underneath don't show through (prevents two-tone artifact). */
  .node rect { fill-opacity: 1; shape-rendering: crispEdges; }
  /* Invisible enlarged hit targets (added for coarse pointers) must stay transparent and not receive fill updates */
  .node rect.hit-target { fill: transparent !important; stroke: none !important; }
  /* Make the node bars and labels visibly interactive */
  .node rect, .node .label { cursor: pointer; }
  
  /* Mobile-only interactive highlighting (click/tap feedback) */
  @media (max-width: 600px) {
    .node.hover rect, .node.active rect, .node.focused rect { filter: brightness(1.08); }
    .node.focused rect, .node.active rect { stroke: var(--node-selection-color); stroke-width: 2px; stroke-opacity: 1; }
    .node.hover .label, .node.active .label, .node.focused .label { filter: url(#textGlow); }
  }
  
  /* Desktop: hover highlighting similar to mobile */
  @media (min-width: 601px) {
    .node:focus { outline: none; }
    .node.hover rect { filter: brightness(1.08); }
    .node.hover rect { stroke: var(--node-selection-color); stroke-width: 2px; stroke-opacity: 1; }
    .node.hover .label { filter: url(#textGlow); }
    /* Keyboard (true focus) highlighting distinct from mere mouse click focus */
    .node.focused rect { filter: brightness(1.08); stroke: var(--node-selection-color); stroke-width: 2px; stroke-opacity: 1; }
    .node.focused .label { filter: url(#textGlow); }
  }
  
  .node.focused text, .node.focused .label { outline: none; }

    .label { font-size: 16px; font-weight: 600; alignment-baseline: middle; fill: var(--fg); paint-order: stroke; stroke: var(--bg); stroke-width: 3px; stroke-opacity: .95; }

   /* Base (dark or unspecified theme): hover/focus should make link look lighter/brighter
     We achieve this by increasing stroke-opacity on dark backgrounds. */
   .link { fill: none; stroke-opacity: .7; transition: stroke-opacity 120ms ease, filter 140ms ease; }
   .link:hover { stroke-opacity: .95; }
  /* Keyboard / programmatic focus highlight for links (connectors) */
  .link:focus { outline: none; }
    /* Focus/active link highlight: lighten rather than darken */
    /* Active / keyboard focus highlight: mimic the HOVER state (lighter) and add subtle glow */
    .link.kb-focus, .link.active-link {
      stroke-opacity: .95 !important; /* same as hover for dark mode */
      filter: drop-shadow(0 0 4px rgba(255,255,255,0.55));
      transition: filter 120ms ease, stroke-opacity 120ms ease;
    }
    :root[data-theme="light"] .link.kb-focus, :root[data-theme="light"] .link.active-link {
      /* In light theme, lighter appearance = LOWER opacity (makes stroke blend toward white) */
      stroke-opacity: .7 !important; /* match light-mode hover below */
      filter: drop-shadow(0 0 4px rgba(0,0,0,0.25));
    }
    
  /* Light mode: invert the opacity logic so hover/active appears lighter (reduced opacity) */
  :root[data-theme="light"] .link { stroke-opacity: .95; }
  :root[data-theme="light"] .link:hover { stroke-opacity: .7; }
    
    /* Also apply to default light mode (no data-theme attribute) */
    @media (prefers-color-scheme: light) {
  /* If user hasn't explicitly chosen a theme and system prefers light, apply light-mode inversion */
  :root:not([data-theme]) .link { stroke-opacity: .95; }
  :root:not([data-theme]) .link:hover { stroke-opacity: .7; }
    }

  .tooltip { position: absolute; pointer-events: none; background: var(--bg); color: var(--fg); border: 1px solid rgba(148,163,184,.4); padding: 8px 10px; border-radius: 8px; font-size: 12px; box-shadow: 0 8px 24px rgba(0,0,0,0.25); opacity: 0; transition: opacity 80ms ease; max-width: 200px; white-space: pre-wrap; overflow-wrap: break-word; word-break: break-word; }
  /* Wider tooltips progressively on larger desktop widths to reduce unnecessary vertical scrolling */
  @media (min-width: 700px){ .tooltip { max-width: 280px; } }
  @media (min-width: 1000px){ .tooltip { max-width: 340px; } }

  /* theme toggle button */
  .theme-btn{ border:1px solid rgba(148,163,184,.35); background: var(--chip-bg); color: var(--fg); padding:0; border-radius:8px; cursor:pointer; font-size:14px; display:inline-flex; align-items:center; justify-content:center; height:36px; width:36px; box-sizing:border-box; line-height:1; z-index:11; overflow:hidden; appearance:none }
  .theme-btn svg, .theme-btn span.icon { display:inline-block; width:16px; height:16px }
  /* Slightly enlarge the about (question mark) icon so its visual weight matches sun/moon */
  #aboutBtn .icon svg { width:18px; height:18px; }
  :root[data-theme="dark"] .theme-btn { background: var(--chip-bg); color: var(--fg); border-color: rgba(255,255,255,0.08); }
  :root[data-theme="dark"] #icon-moon{ display:none }
  :root[data-theme="dark"] #icon-sun{ display:inline }
  #icon-sun{ display:none }
  </style>
</head>
<body>
  <a href="#chart" class="sr-only sr-focusable" id="skip-to-chart">Skip to chart</a>
  <!-- Live region for screen reader announcements (tooltip / focus updates) -->
  <div id="a11y-live" class="sr-only" aria-live="polite" aria-atomic="true"></div>
  <div class="wrap">
  <div class="page-header">
    <h1>Theistic Arguments and Divine Attributes</h1>
    <div style="display:inline-flex; gap:8px; align-items:center">
      <button id="aboutBtn" class="theme-btn" aria-expanded="false" title="About this visualization" aria-label="About this visualization" style="padding:8px 10px; min-width:40px; height:36px;">
        <span aria-hidden="true" class="icon" style="display:inline-flex; align-items:center; justify-content:center; width:16px; height:16px;">
          <!-- Bolder question mark icon (no faint outer ring) -->
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
            <path d="M9.09 9a3 3 0 1 1 5.82 1c0 2-3 2.5-3 4" />
            <circle cx="12" cy="17" r="1.2" fill="currentColor" stroke="none" />
          </svg>
        </span>
      </button>
      <button id="themeToggle" class="theme-btn" aria-pressed="false" title="Toggle dark mode">
      <span id="icon-moon" aria-hidden="true"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"></path></svg></span>
      <span id="icon-sun" aria-hidden="true"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="4"></circle><path d="M12 2v2M12 20v2M4.93 4.93l1.41 1.41M17.66 17.66l1.41 1.41M2 12h2M20 12h2M4.93 19.07l1.41-1.41M17.66 6.34l1.41-1.41"/></svg></span>
    </button>
    </div>
  </div>

    <div id="chart-title" class="sr-only">Theistic arguments mapped to divine attributes</div>
    <div id="chart-desc" class="sr-only">Interactive sankey-style mapping where arguments (left) connect to attributes (right). Use Tab to move between items and press Enter or Space to activate a node. Use the About button for more details.</div>
    <svg id="chart" role="img" aria-labelledby="chart-title chart-desc"></svg>
    <div id="tooltip" class="tooltip"></div>
    <!-- About modal (hidden by default) -->
    <div id="aboutModal" role="dialog" aria-modal="true" aria-labelledby="aboutTitle" style="display:none; position:fixed; inset:0; z-index:40;">
      <div id="aboutBackdrop" style="position:absolute; inset:0; background:rgba(0,0,0,0.45); backdrop-filter: blur(2px);"></div>
  <div id="aboutPanel" tabindex="-1" style="position:relative; max-width:820px; margin:clamp(12px,6vh,40px) auto; background:var(--bg); color:var(--fg); border-radius:12px; padding:20px; box-shadow:0 24px 48px rgba(2,6,23,0.6); border:1px solid rgba(148,163,184,0.12); max-height:calc(100dvh - 12vh - env(safe-area-inset-bottom)); overflow:auto; -webkit-overflow-scrolling:touch; padding-bottom:calc(20px + env(safe-area-inset-bottom));">
        <div style="display:flex; justify-content:space-between; align-items:center; gap:12px;">
          <h2 id="aboutTitle" style="margin:0; font-size:18px;">About This Visualization</h2>
          <button id="aboutClose" class="theme-btn" title="Close about" aria-label="Close about dialog" style="height:36px; width:36px;">✕</button>
        </div>
        <div id="aboutContent" style="margin-top:12px; color:var(--muted); font-size:14px; line-height:1.5;"></div>
      </div>
    </div>
  </div>

  <script>
      (async () => {
        // Theme handling: toggle and persist theme in localStorage
        const themeKey = 'pv_theme';
        function applyTheme(t){ 
          if(t==='dark' || t==='light') {
            document.documentElement.setAttribute('data-theme', t); 
            // Keep the browser chrome color in sync with the page theme so mobile Safari
            // doesn't show the bright mint color. Update the meta theme-color tag.
            try {
              const themeMeta = document.querySelector('meta[name="theme-color"]');
              if (themeMeta) themeMeta.setAttribute('content', t === 'dark' ? '#071022' : '#ffffff');
            } catch (e) { /* ignore meta update errors */ }
            // Update colors after theme change (if chart is already rendered)
            if (typeof updateNodeColors === 'function') {
              setTimeout(() => { updateNodeColors(); updateGradients(); }, 50);
            }
          }
        }
        function initTheme(){ const stored = localStorage.getItem(themeKey); if(stored){ applyTheme(stored); document.getElementById('themeToggle')?.setAttribute('aria-pressed', stored==='dark'?'true':'false'); } else {
            const prefers = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light'; applyTheme(prefers); document.getElementById('themeToggle')?.setAttribute('aria-pressed', prefers==='dark'?'true':'false'); }
          document.getElementById('themeToggle')?.addEventListener('click', ()=>{ const cur = document.documentElement.getAttribute('data-theme')==='dark' ? 'dark' : 'light'; const next = cur==='dark' ? 'light' : 'dark'; applyTheme(next); localStorage.setItem(themeKey, next); document.getElementById('themeToggle')?.setAttribute('aria-pressed', next==='dark'?'true':'false'); });
        }
        try{ initTheme(); }catch(e){ /* ignore theme init errors */ }
      // Load argument metadata (premises/steps) so we can show them on node hover
      const argMetaResp = await fetch('data/theistic-arguments.json');
      let argMeta = { arguments: [] };
      try { argMeta = await argMetaResp.json(); } catch(e) { console.warn('Could not load arguments.json', e); }

        // About modal wiring: uses the same argMeta loaded above. If argMeta.about missing, fall back to a short default.
        const aboutBtn = document.getElementById('aboutBtn');
        const aboutModal = document.getElementById('aboutModal');
        const aboutBackdrop = document.getElementById('aboutBackdrop');
        const aboutContent = document.getElementById('aboutContent');
        const aboutClose = document.getElementById('aboutClose');
        let lastFocusedElement = null;

        function openAbout(){
          const info = (argMeta && argMeta.about) ? argMeta.about : { title: 'About', paragraphs: ['No about text available.'] };
          // build HTML paragraphs
          aboutContent.innerHTML = info.paragraphs.map(p => `<p style="margin:0 0 12px 0; color:var(--muted-dark);">${p}</p>`).join('');
            aboutModal.style.display = 'block';
            // Mark main content as hidden from AT while modal is open
            document.querySelector('.wrap')?.setAttribute('aria-hidden', 'true');
            aboutModal.setAttribute('aria-hidden', 'false');
          // prevent background from scrolling while modal is open
          document.body.style.overflow = 'hidden';
          aboutBtn.setAttribute('aria-expanded', 'true');
          lastFocusedElement = document.activeElement;
    // focus the panel (so keyboard users can scroll inside it) or close button if panel can't be focused
    try{ aboutPanel.focus(); }catch(e){ try{ aboutClose.focus(); }catch(e){} }
    // Ensure the panel is scrolled into view (useful on iOS where the browser UI can obscure the bottom)
    try{ aboutPanel.scrollTop = 0; aboutPanel.scrollIntoView({block: 'center', behavior: 'auto'}); }catch(e){}
          // simple focus trap: keep focus inside modal
          document.addEventListener('focus', trapFocus, true);
        }

        function closeAbout(){
          aboutModal.style.display = 'none';
          // Restore accessibility tree
          document.querySelector('.wrap')?.removeAttribute('aria-hidden');
          aboutModal.setAttribute('aria-hidden', 'true');
          // restore scrolling on body
          document.body.style.overflow = '';
          aboutBtn.setAttribute('aria-expanded', 'false');
          document.removeEventListener('focus', trapFocus, true);
          if (lastFocusedElement && lastFocusedElement.focus) lastFocusedElement.focus();
        }

        function trapFocus(e){
          if (!aboutModal.contains(e.target)){
            e.stopPropagation();
            aboutClose.focus();
          }
        }

        if (aboutBtn){ aboutBtn.addEventListener('click', openAbout); }
        if (aboutBackdrop){ aboutBackdrop.addEventListener('click', closeAbout); }
        if (aboutClose){ aboutClose.addEventListener('click', closeAbout); }
        window.addEventListener('keydown', (e) => { if (e.key === 'Escape' && aboutModal && aboutModal.style.display === 'block') { closeAbout(); } });

      // Arguments from JSON, but fall back to the built-in list if JSON is missing/empty
      const fallbackArguments = [
        { id: "ontological", title: "Ontological" },
        { id: "kalam", title: "Kalam" },
        { id: "leibniz", title: "Leibnizian" },
        { id: "moral", title: "Moral" },
        { id: "teleological", title: "Teleological" }
      ];

  const argsFromJson = (argMeta.arguments && argMeta.arguments.length) ? argMeta.arguments : fallbackArguments;
  const argById = new Map((argsFromJson || []).map(a => [a.id, a]));
  const attrList = argMeta.attributes || [];
  const attrById = new Map((attrList || []).map(a => [a.id, a]));

      // Use argument metadata as source of truth so IDs line up with data/arguments.json
      const data = {
      arguments: (argsFromJson || []).map(a => ({ id: a.id, label: a.title || (a.id.charAt(0).toUpperCase() + a.id.slice(1)) })),
      attributes: (attrList || []).map(a => ({ id: a.id, label: a.title || (a.id.charAt(0).toUpperCase() + a.id.slice(1)) })),
      links: argMeta.links || [
        { source: "ontological", target: "max_great", value: 12, explain: "If possibly necessary being, then necessary being exists (modal ontological)." },
        { source: "ontological", target: "necessary", value: 10, explain: "Ontological also supports necessity of being." },
        { source: "kalam", target: "timeless", value: 10, explain: "Cause of space–time is not in space–time." },
        { source: "kalam", target: "personal", value: 8, explain: "A timeless impersonal cause would yield no beginning, so a personal will explains the first moment." },
        { source: "leibniz", target: "necessary", value: 9, explain: "Principle of Sufficient Reason (PSR) → necessary external explanation of contingent reality." },
        { source: "leibniz", target: "personal", value: 6, explain: "Principle of Sufficient Reason (PSR) suggests a personal explanation, not just abstract." },
        { source: "teleological", target: "designer", value: 12, explain: "Fine-tuning suggests purposive order." },
        { source: "teleological", target: "personal", value: 6, explain: "Design also implies a personal mind behind it." },
        { source: "moral", target: "good", value: 12, explain: "Ground of objective moral values & duties." }
      ]
    };

    // Get colors from CSS custom properties (theme-aware)
    function getArgColor(id) {
      const style = getComputedStyle(document.documentElement);
      return style.getPropertyValue(`--${id}-color`).trim() || '#93c5fd';
    }
    
    function getAttrColor(id) {
      const style = getComputedStyle(document.documentElement);
      // CSS variables use hyphens; some ids use underscores (e.g., max_great).
      const cssId = String(id).replace(/_/g, '-');
      let val = style.getPropertyValue(`--${cssId}-color`).trim();
      if (!val) {
        // fall back to generic attribute fill
        val = style.getPropertyValue('--attr-fill').trim();
      }
      // resolve var(...) references if present
      if (val && val.startsWith('var(')){
        const m = val.match(/var\((--[^)]+)\)/);
        if (m && m[1]) {
          const resolved = style.getPropertyValue(m[1]).trim();
          if (resolved) val = resolved;
        }
      }
      return val || '#94a3b8';
    }

    // Lighten a color by increasing its HSL lightness. Accepts hex (#rgb/#rrggbb) or rgb(...) strings.
    function lightenHex(color, weight = 0.22) {
      try {
        const str = String(color).trim();
        let r, g, b;
        if (str.startsWith('rgb')) {
          const nums = str.match(/\d+/g);
          if (!nums || nums.length < 3) return color;
          [r, g, b] = nums.map(n => parseInt(n, 10));
        } else {
          const h = str.replace('#', '');
          const full = h.length === 3 ? h.split('').map(c => c + c).join('') : h;
          const bigint = parseInt(full, 16);
          if (Number.isNaN(bigint)) return color;
          r = (bigint >> 16) & 255;
          g = (bigint >> 8) & 255;
          b = bigint & 255;
        }

        // convert RGB [0..255] to HSL (h in degrees, sat and l in [0..1])
        const r1 = r / 255, g1 = g / 255, b1 = b / 255;
        const max = Math.max(r1, g1, b1), min = Math.min(r1, g1, b1);
        let h = 0, sat = 0, l = (max + min) / 2;
        if (max !== min) {
          const d = max - min;
          sat = l > 0.5 ? d / (2 - max - min) : d / (max + min);
          switch (max) {
            case r1: h = (g1 - b1) / d + (g1 < b1 ? 6 : 0); break;
            case g1: h = (b1 - r1) / d + 2; break;
            case b1: h = (r1 - g1) / d + 4; break;
          }
          h = h * 60;
        }

        // increase lightness toward 1 by weight
        const w = Math.max(0, Math.min(1, weight));
        const newL = Math.min(1, l + (1 - l) * w);

        // convert back HSL -> RGB
        function hue2rgb(p, q, t) {
          if (t < 0) t += 1;
          if (t > 1) t -= 1;
          if (t < 1/6) return p + (q - p) * 6 * t;
          if (t < 1/2) return q;
          if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
          return p;
        }

        let r2, g2, b2;
        if (sat === 0) {
          r2 = g2 = b2 = newL; // achromatic
        } else {
          const q = newL < 0.5 ? newL * (1 + sat) : newL + sat - newL * sat;
          const p = 2 * newL - q;
          const hk = (h / 360);
          r2 = hue2rgb(p, q, hk + 1/3);
          g2 = hue2rgb(p, q, hk);
          b2 = hue2rgb(p, q, hk - 1/3);
        }

        const nr = Math.round(r2 * 255);
        const ng = Math.round(g2 * 255);
        const nb = Math.round(b2 * 255);
        return `rgb(${nr}, ${ng}, ${nb})`;
      } catch (e) {
        return color;
      }
    }

    function getLighterForNode(d) {
      const base = d.type === 'arg' ? getArgColor(d.id) : getAttrColor(d.id);
      return lightenHex(base, 0.22);
    }

    const nodes = [
      ...data.arguments.map(d => ({ id: d.id, label: d.label, type: 'arg' })),
      ...data.attributes.map((d, i) => ({ id: d.id, label: d.label, type: 'attr', order: i }))
    ];

    const indexById = new Map(nodes.map((d, i) => [d.id, i]));

    // Map links to numeric indices; filter out any that refer to missing node ids
    const links = data.links.map(l => {
      const sIdx = indexById.get(l.source);
      const tIdx = indexById.get(l.target);
      if (sIdx == null || tIdx == null) {
        console.warn('Skipping link with missing node id', l);
        return null;
      }
      return {
        source: sIdx,
        target: tIdx,
        value: l.value,
        explain: l.explain || "(no further explanation)"
      };
    }).filter(Boolean);

  const svg = d3.select('#chart');
  const width = svg.node().clientWidth;
  const height = svg.node().clientHeight;
  const isMobile = width < 600; // simple breakpoint for responsive adjustments
  // We no longer visually widen nodes beyond the sankey layout width; instead we add separate hit targets for touch.

  // Create main group for zoom/pan functionality
  const chartGroup = svg.append('g').attr('class', 'chart-container');
  
  // Add zoom behavior without strict translation constraints for more freedom
  const zoom = d3.zoom()
    .scaleExtent([0.3, 3])
    .on('zoom', (event) => {
      chartGroup.attr('transform', event.transform);
    });
  
  svg.call(zoom);

    // Ensure nodes in the same column keep a desired vertical order by using an explicit 'order' property
    const sankey = d3.sankey()
      .nodeId((d, i) => i)
      .nodeAlign(d3.sankeyLeft)
      // Use a consistent node width; do not manually stretch rects afterwards.
      .nodeWidth(14)
      .nodePadding(isMobile ? 12 : 16)
      // sort nodes within each column by the 'order' property (defaults to 0)
      .nodeSort((a, b) => ( (a.order || 0) - (b.order || 0) ))
      .extent([[isMobile ? 40 : 140, 20], [width - (isMobile ? 40 : 140), height - 20]]);

    const graph = sankey({ nodes: nodes.map(d => ({ ...d })), links: links.map(d => ({ ...d })) });

    // Reposition attribute nodes according to their explicit 'order' so right-side order is enforced.
    // Gather attribute nodes (these are sinks, typically on the right column) and re-stack them.
    const attrNodes = graph.nodes.filter(n => n.type === 'attr').slice().sort((a,b) => (a.order || 0) - (b.order || 0));
    if (attrNodes.length) {
      const padTop = 20;
      const padBottom = 20;
      const available = height - padTop - padBottom;
      const totalHeights = attrNodes.reduce((sum, n) => sum + (n.y1 - n.y0), 0);
      const totalPadding = Math.max(0, (attrNodes.length - 1) * sankey.nodePadding());
      const needed = totalHeights + totalPadding;
      // start centered vertically
      let y = padTop + Math.max(0, (available - needed) / 2);
      for (const n of attrNodes) {
        const h = n.y1 - n.y0;
        n.y0 = y;
        n.y1 = y + h;
        y += h + sankey.nodePadding();
      }
    }

    // Function to update gradients with current theme colors
    function updateGradients() {
      const defs = chartGroup.select('defs');
      defs.selectAll('linearGradient').remove(); // Clear existing gradients
      
      graph.links.forEach((d,i) => {
        const gradId = `grad-${i}`;
        const sourceNode = nodes[d.source.index];
        const targetNode = nodes[d.target.index];
        const sourceColor = sourceNode.type === 'arg' ? getArgColor(sourceNode.id) : getAttrColor(sourceNode.id);
        const targetColor = targetNode.type === 'arg' ? getArgColor(targetNode.id) : getAttrColor(targetNode.id);
        
        const linearGrad = defs.append('linearGradient')
          .attr('id', gradId)
          .attr('gradientUnits','userSpaceOnUse')
          .attr('x1', d.source.x1).attr('x2', d.target.x0)
          .attr('y1', (d.source.y0 + d.source.y1)/2)
          .attr('y2', (d.target.y0 + d.target.y1)/2);
        linearGrad.append('stop').attr('offset','0%').attr('stop-color',sourceColor).attr('stop-opacity',0.8);
        linearGrad.append('stop').attr('offset','100%').attr('stop-color',targetColor).attr('stop-opacity',0.8);
        d.gradId = gradId;
      });
    }

    const defs = chartGroup.append('defs');
    
    // Add text glow filter for label halos - theme-aware colors
    const textGlowFilter = defs.append('filter')
      .attr('id', 'textGlow')
      .attr('x', '-50%')
      .attr('y', '-50%')
      .attr('width', '200%')
      .attr('height', '200%');
      
    // Create a flood fill with theme-aware glow color
    const flood = textGlowFilter.append('feFlood')
      .attr('flood-color', 'var(--text-glow-color)')
      .attr('flood-opacity', '0.8')
      .attr('result', 'glowColor');
      
    textGlowFilter.append('feMorphology')
      .attr('operator', 'dilate')
      .attr('radius', '2')
      .attr('in', 'SourceGraphic')
      .attr('result', 'dilated');
      
    textGlowFilter.append('feGaussianBlur')
      .attr('stdDeviation', '3')
      .attr('in', 'dilated')
      .attr('result', 'blurred');
      
    // Composite the flood color with the blurred shape
    textGlowFilter.append('feComposite')
      .attr('in', 'glowColor')
      .attr('in2', 'blurred')
      .attr('operator', 'in')
      .attr('result', 'coloredBlur');
      
    const merge = textGlowFilter.append('feMerge');
    merge.append('feMergeNode').attr('in', 'coloredBlur');
    merge.append('feMergeNode').attr('in', 'SourceGraphic');
    
    updateGradients();

    // Legend and descriptive subtitle removed — labels on the graph provide the context.

    const link = chartGroup.append('g')
      .attr('fill', 'none')
      .selectAll('path')
      .data(graph.links)
      .join('path')
      .attr('class', 'link')
      .attr('d', d3.sankeyLinkHorizontal())
      .attr('stroke', d => `url(#${d.gradId})`)
        .attr('stroke-width', d => Math.max(1, d.width))
        // Make connectors keyboard focusable for accessibility
      // tabindex assigned later in custom ordering routine
        .attr('role', 'button')
        .attr('aria-label', d => {
          const s = nodes[d.source.index];
          const t = nodes[d.target.index];
          return `Connection from ${s.label} to ${t.label}`;
        })
        .attr('id', (d,i) => `link-${i}`)
        .attr('aria-describedby', (d,i) => `link-${i}-desc`)
        .on('focus', function(event, d){
          // Keyboard focus: show tooltip at synthetic position (center of link)
          lastInteractionWasKeyboard = true;
          d3.select(this).classed('kb-focus', true);
          showLinkTooltipForFocus(d, this);
          try{ updateA11yLive((d && d.explain) ? d.explain : `Connection from ${nodes[d.source.index].label} to ${nodes[d.target.index].label}`); }catch(e){}
        })
        .on('blur', function(){ d3.select(this).classed('kb-focus', false); hideTooltipImmediate(); });

    const tooltip = d3.select('#tooltip');
    const a11yLive = document.getElementById('a11y-live');

    function stripHtml(html){
      const tmp = document.createElement('div'); tmp.innerHTML = html || ''; return tmp.textContent || tmp.innerText || '';
    }

    // Make the word "Therefore:" bold in tooltip step text (preserve rest of the text)
    function formatStepHtml(text){
      if (!text) return '';
      // Replace a leading "Therefore:" (case-insensitive) with a bolded version
      return String(text).replace(/^\s*(Therefore)\s*:\s*/i, '<strong>$1:</strong> ');
    }

    function updateA11yLive(text){
      if (!a11yLive) return;
      a11yLive.textContent = '';
      setTimeout(() => { a11yLive.textContent = text || ''; }, 20);
    }
    // Helper to position tooltip near the cursor and shift left if it would overflow the right edge.
    let _lastTooltipAt = 0;
    let _hideTooltipTimeout = null;
    
    // Helper functions for debounced tooltip show/hide
    function showTooltip(event, html, opts = {}) {
      // cancel any pending hide
      if (_hideTooltipTimeout) {
        clearTimeout(_hideTooltipTimeout);
        _hideTooltipTimeout = null;
      }
      showTooltipAtMouse(event, html, opts);
      try{ updateA11yLive(stripHtml(html)); }catch(e){}
    }
    
    function hideTooltipDelayed(delay = 50) {
      if (_hideTooltipTimeout) clearTimeout(_hideTooltipTimeout);
      _hideTooltipTimeout = setTimeout(() => {
        tooltip.style('opacity', 0);
        _hideTooltipTimeout = null;
      }, delay);
    }
    
    function hideTooltipImmediate() {
      if (_hideTooltipTimeout) {
        clearTimeout(_hideTooltipTimeout);
        _hideTooltipTimeout = null;
      }
      tooltip.style('opacity', 0);
    }
    
    // showTooltipAtMouse(event, html, opts?)
    // opts: { avoidRect: DOMRect } - a client bounding rect to avoid overlapping
    function showTooltipAtMouse(event, html, opts = {}){
      try{
        const now = Date.now();
        // ignore rapid successive calls (common when touch generates synthetic mouse events)
        if (now - _lastTooltipAt < 60) return;
        _lastTooltipAt = now;
        // Determine a baseline max-width (desktop gets wider tooltips)
        const baseMax = window.innerWidth >= 1000 ? 340 : (window.innerWidth >= 700 ? 280 : 200);
        // reset any adaptive max-width so measurement is accurate for current viewport tier
        tooltip.style('max-width', baseMax + 'px');
        tooltip.html(html).style('opacity', 1).style('left', '0px');

        // prefer to place below the pointer/click initially
        const pageYOffsetVal = (window.pageYOffset || document.documentElement.scrollTop || 0);
        const pointerY = (event.pageY || (event.clientY + pageYOffsetVal));
        const preferredTop = pointerY + 12;
        tooltip.style('top', preferredTop + 'px');

        const ttNode = tooltip.node();
        if(!ttNode) return;

        // measure width/height after content insertion
        let rect = ttNode.getBoundingClientRect();
        let w = rect.width || ttNode.offsetWidth || 0;
        let h = rect.height || ttNode.offsetHeight || 0;

        const docLeft = window.pageXOffset || document.documentElement.scrollLeft || 0;
        const minLeft = docLeft + 8;
        const maxRight = docLeft + window.innerWidth - 8;

        // If avoidRect provided, compute available space on both sides of it.
        let availableLeft = maxRight - minLeft; // fallback: whole width
        let availableRight = maxRight - minLeft;
        let rectLeft = null, rectRight = null;
        if (opts.avoidRect) {
          const r = opts.avoidRect;
          rectLeft = r.left + (window.pageXOffset || document.documentElement.scrollLeft || 0);
          rectRight = r.right + (window.pageXOffset || document.documentElement.scrollLeft || 0);
          availableRight = Math.max(0, maxRight - (rectRight + 8));
          availableLeft = Math.max(0, (rectLeft - 8) - minLeft);
          // proactively constrain tooltip width to the larger available side so it won't overlap
          const larger = Math.max(availableLeft, availableRight);
          if (larger > 80) {
            // Cap the max-width at the baseMax (viewport-tier dependent) even when there's lots of space
            const maxWidth = Math.min(baseMax, Math.floor(larger));
            tooltip.style('max-width', maxWidth + 'px');
            // re-measure after limiting width
            rect = ttNode.getBoundingClientRect();
            w = rect.width || ttNode.offsetWidth || 0;
            h = rect.height || ttNode.offsetHeight || 0;
          }
        } else {
          // if no rect, compute space relative to pointer
          const pointerX = (event.pageX || (event.clientX + (window.pageXOffset || document.documentElement.scrollLeft))) || (minLeft + 12);
          availableRight = Math.max(0, maxRight - (pointerX + 12));
          availableLeft = Math.max(0, (pointerX - 12) - minLeft);
        }

        // Decide placement side. Prefer right side if it fits, otherwise left if it fits, else choose larger side.
        let placeSide = 'right';
        if (opts.avoidRect) {
          if (availableRight >= w) placeSide = 'right';
          else if (availableLeft >= w) placeSide = 'left';
          else placeSide = (availableRight >= availableLeft) ? 'right' : 'left';
        } else {
          // prefer right of pointer
          placeSide = (availableRight >= w) ? 'right' : ((availableLeft >= w) ? 'left' : (availableRight >= availableLeft ? 'right' : 'left'));
        }

        // If tooltip is wider than available on the chosen side, reduce max-width and re-measure
        const desiredAvailable = (placeSide === 'right') ? availableRight : availableLeft;
        if (w > desiredAvailable && desiredAvailable > 80) {
          // set a new adaptive max-width (add small padding)
          const newMax = Math.max(80, Math.floor(desiredAvailable));
          tooltip.style('max-width', newMax + 'px');
          // re-measure
          rect = ttNode.getBoundingClientRect();
          w = rect.width || ttNode.offsetWidth || 0;
          h = rect.height || ttNode.offsetHeight || 0;
        }

        // compute left position
        let left;
        if (placeSide === 'right'){
          if (opts.avoidRect && rectRight != null) left = rectRight + 8;
          else left = (event.pageX || (event.clientX + (window.pageXOffset || document.documentElement.scrollLeft))) + 12;
        } else {
          if (opts.avoidRect && rectLeft != null) left = rectLeft - 8 - w;
          else left = (event.pageX || (event.clientX + (window.pageXOffset || document.documentElement.scrollLeft))) - 12 - w;
        }

        // clamp final left to viewport
        left = Math.min(Math.max(left, minLeft), Math.max(minLeft, maxRight - w));
        tooltip.style('left', left + 'px');

        // vertical placement: prefer to place below the pointer. Only place above if it fully fits there.
        const viewportBottom = pageYOffsetVal + window.innerHeight;
        const preferredTopPx = pointerY + 12;
        const maxTopAllowed = viewportBottom - 8 - h; // maximum top so tooltip bottom stays inside
        const minTopAllowed = pageYOffsetVal + 8;
        if (preferredTopPx <= maxTopAllowed) {
          // there's room to place fully below
          tooltip.style('top', preferredTopPx + 'px');
        } else {
          // no room to place fully below
          const altTop = pointerY - 12 - h; // top if we place entirely above pointer
          if (altTop >= minTopAllowed) {
            // placing fully above is possible — do that
            tooltip.style('top', altTop + 'px');
          } else {
            // neither fits fully below nor fully above; clamp to keep tooltip inside viewport
            const clamped = Math.min(Math.max(preferredTopPx, minTopAllowed), maxTopAllowed);
            tooltip.style('top', clamped + 'px');
          }
        }
      }catch(e){ /* ignore positioning errors */ }
    }

    // Centered tooltip (used for keyboard-focused links) – places tooltip centered on (x,y)
    function showTooltipCentered(x, y, html){
      try {
        // baseline max-width tiered by viewport width similar to showTooltipAtMouse
        const baseMax = window.innerWidth >= 1000 ? 340 : (window.innerWidth >= 700 ? 280 : 200);
        if (_hideTooltipTimeout) { clearTimeout(_hideTooltipTimeout); _hideTooltipTimeout = null; }
        tooltip.style('max-width', baseMax + 'px');
        tooltip.html(html).style('opacity', 1).style('left', '0px');
        // Measure
        const ttNode = tooltip.node();
        if(!ttNode) return;
        let rect = ttNode.getBoundingClientRect();
        let w = rect.width || ttNode.offsetWidth || 0;
        let h = rect.height || ttNode.offsetHeight || 0;
        const docLeft = window.pageXOffset || document.documentElement.scrollLeft || 0;
        const docTop = window.pageYOffset || document.documentElement.scrollTop || 0;
        const minLeft = docLeft + 4;
        const maxRight = docLeft + window.innerWidth - 4;
        const minTop = docTop + 4;
        const maxBottom = docTop + window.innerHeight - 4;
        let left = x - w/2;
        let top = y - h/2;
        // Clamp inside viewport
        if (left < minLeft) left = minLeft;
        if (left + w > maxRight) left = maxRight - w;
        if (top < minTop) top = minTop;
        if (top + h > maxBottom) top = maxBottom - h;
        tooltip.style('left', left + 'px').style('top', top + 'px');
        try{ updateA11yLive(stripHtml(html)); }catch(e){}
      } catch(e) { /* swallow */ }
    }
    link.on('mousemove', (event, d) => {
        const s = nodes[d.source.index];
        const t = nodes[d.target.index];
        const label = `${s.label} → ${t.label}`;
        showTooltip(event, `<strong>${label}</strong><br/>${d.explain}`);
      })
      .on('mouseleave', () => hideTooltipDelayed(100))
      .on('click touchstart', function(event, d) {
        const isCoarseTap = window.matchMedia && window.matchMedia('(pointer: coarse)').matches;
        if (event.preventDefault) event.preventDefault();
        if (event.stopPropagation) event.stopPropagation();
        // Clear node states and previous active link
        d3.selectAll('.node').classed('hover', false).classed('active', false).classed('focused', false);
        d3.selectAll('.link').classed('active-link', false).classed('kb-focus', false);
        if (isCoarseTap) {
          // Persist highlight for this link on mobile
            d3.select(this).classed('active-link', true);
          // Explicitly show tooltip (don't rely on synthetic mousemove)
          try {
            const s = nodes[d.source.index];
            const t = nodes[d.target.index];
            const label = `${s.label} → ${t.label}`;
            const box = this.getBoundingClientRect();
            const synthetic = { pageX: box.left + window.pageXOffset + box.width/2, pageY: box.top + window.pageYOffset + box.height/2 };
            showTooltipAtMouse(synthetic, `<strong>${label}</strong><br/>${d.explain}`, { avoidRect: box });
            try{ updateA11yLive(stripHtml(`<strong>${label}</strong><br/>${d.explain}`)); }catch(e){}
          } catch(e){}
        }
        updateNodeColors();
      });

    const node = chartGroup.append('g')
      .selectAll('g')
      .data(graph.nodes)
      .join('g')
        .attr('class', d => `node ${d.type}`)
        // keyboard + a11y: make group focusable and act like a button
        // tabindex assigned later in custom ordering routine
        .attr('role', 'button')
        .attr('aria-label', d => `${d.label} ${d.type === 'arg' ? 'argument' : 'attribute'}`)
          .attr('id', d => `node-${d.index}`)
          .attr('aria-describedby', d => `node-${d.index}-desc`)
        // CLICK: On coarse (touch) pointers treat click like a tap (show tooltip + isolate).
        // On fine (mouse) pointers do nothing (hover already shows tooltip; click used only for keyboard a11y via Enter/Space below).
        .on('click', function(event, d) {
          if (isCoarse) {
            showNodeDetails(event, d, 'click');
          } else {
            // Desktop mouse click: intentionally no-op to avoid selection without tooltip.
            // (Keyboard activation handled in keydown handler.)
          }
        })

    .on('focus', function(event, d) {
      // Only visually highlight if coarse (touch) or keyboard-driven
      if (!isCoarse && !lastInteractionWasKeyboard) return;
      d3.select(this).classed('focused', true);
      updateNodeColors();
      // Show tooltip for keyboard focus (not for mouse click focus)
      if (!isCoarse && lastInteractionWasKeyboard) {
        showNodeTooltipForFocus(d, this);
      }
    })
    .on('blur', function() { d3.select(this).classed('focused', false); updateNodeColors(); })
        .on('keydown', function(event, d) {
          if (event.key === 'Enter' || event.key === ' ' || event.code === 'Space'){
            event.preventDefault();
            isolate(d);
            const el = d3.select(this);
            el.classed('active', true);
            updateNodeColors();
            setTimeout(() => { el.classed('active', false); updateNodeColors(); }, 260);
          }
        })
        .on('touchstart', function(event, d){
          showNodeDetails(event, d, 'touch');
        });

      // Unified handler for coarse pointer activation (touch/click) so selection & tooltip always sync.
      function showNodeDetails(event, d, source){
        // Prevent follow-up synthetic mouse events for touch.
        if (event && event.preventDefault) event.preventDefault();
        if (event && event.stopPropagation) event.stopPropagation();
        // Clear previous active/hover/focused states so only one node is active at a time.
        d3.selectAll('.node').classed('active', false).classed('hover', false).classed('focused', false);
        // Also clear any active link highlight when selecting a node
        d3.selectAll('.link').classed('active-link', false).classed('kb-focus', false);
        const el = d3.select(this instanceof Element ? this : event.currentTarget);
        el.classed('active', true);
        isolate(d); // Apply context highlighting (same as keyboard isolate)
        updateNodeColors();

        const point = (event.touches && event.touches[0]) ? event.touches[0] : event;
        try{
          const rectEl = (el.node() && el.node().querySelector) ? el.node().querySelector('rect') : null;
          const avoidRect = rectEl && rectEl.getBoundingClientRect ? rectEl.getBoundingClientRect() : (el.node() && el.node().getBoundingClientRect ? el.node().getBoundingClientRect() : null);
          if (d.type === 'arg') {
            const meta = argById.get(d.id) || {};
            const steps = meta.steps || [];
            let bodyHtml;
            if (steps.length) {
              const items = steps.map(s => `<li style="margin:0 0 8px 0; line-height:1.4">${formatStepHtml(s.text)}</li>`).join('');
              bodyHtml = `<ol style="margin:6px 0 0 0; padding-left:20px;">${items}</ol>`;
            } else {
              bodyHtml = '(no steps found)';
            }
            showTooltipAtMouse(point, `<strong>${meta.title || d.label}</strong><br/>${bodyHtml}`, { avoidRect });
            try{ updateA11yLive(stripHtml(`${meta.title || d.label}. ${ (meta.steps || []).map(s=>s.text).join(' — ') }`)); }catch(e){}
          } else {
            const meta = attrById.get(d.id) || {};
            const desc = meta.description || '(no description)';
            showTooltipAtMouse(point, `<strong>${meta.title || d.label}</strong><br/>${desc}`, { avoidRect });
            try{ updateA11yLive(stripHtml(`${meta.title || d.label}. ${desc}`)); }catch(e){}
          }
          // Focus node for accessibility (screen readers announce activation)
          try{ el.node().focus({ preventScroll: true }); }catch(e){}
        }catch(e){ /* swallow errors */ }
      }

      // Show premises on hover (desktop) or maintained by touch handler (mobile)
      node.filter(d => d.type === 'arg')
        .on('mouseenter', function(event, d) {
          // only show tooltip on hover for desktop (mobile uses touch/click)
          if (isMobile) return;
          d3.select(this).classed('hover', true);
          updateNodeColors();
        })
        .on('mousemove', function(event, d) {
          // only show tooltip on hover for desktop (mobile uses touch/click)
          if (isMobile) return;
          
          const meta = argById.get(d.id);
          if (!meta) {
            showTooltip(event, `<strong>${d.label}</strong>`);
            return;
          }
          // Show all steps as numbered list
          const steps = meta.steps || [];
          let bodyHtml;
          if (steps.length) {
            const items = steps.map(s => `<li style="margin:0 0 8px 0; line-height:1.4">${formatStepHtml(s.text)}</li>`).join('');
            bodyHtml = `<ol style="margin:6px 0 0 0; padding-left:20px;">${items}</ol>`;
          } else {
            bodyHtml = '(no steps found)';
          }
          
          try{
            const rectEl = this.querySelector && this.querySelector('rect') ? this.querySelector('rect') : this.getBoundingClientRect();
            const avoidRect = rectEl.getBoundingClientRect ? rectEl.getBoundingClientRect() : rectEl;
            showTooltip(event, `<strong>${meta.title || d.label}</strong><br/>${bodyHtml}`, { avoidRect });
          }catch(e){ showTooltip(event, `<strong>${meta.title || d.label}</strong><br/>${bodyHtml}`); }
        })
        .on('mouseleave', function(){ 
          d3.select(this).classed('hover', false);
          updateNodeColors();
          if (!isMobile) hideTooltipDelayed(100);
        });

      // Show attribute description on hover (desktop) or maintained by touch handler (mobile)
      node.filter(d => d.type === 'attr')
        .on('mouseenter', function(event, d) {
          // only show tooltip on hover for desktop (mobile uses touch/click)
          if (isMobile) return;
          d3.select(this).classed('hover', true);
          updateNodeColors();
        })
        .on('mousemove', function(event, d) {
          // only show tooltip on hover for desktop (mobile uses touch/click)
          if (isMobile) return;
          
          const meta = attrById.get(d.id) || {};
          const desc = meta.description || '(no description)';
          try{
            const rectEl = this.querySelector && this.querySelector('rect') ? this.querySelector('rect') : this.getBoundingClientRect();
            const avoidRect = rectEl.getBoundingClientRect ? rectEl.getBoundingClientRect() : rectEl;
            showTooltip(event, `<strong>${meta.title || d.label}</strong><br/>${desc}`, { avoidRect });
          }catch(e){ showTooltip(event, `<strong>${meta.title || d.label}</strong><br/>${desc}`); }
        })
        .on('mouseleave', function(){ 
          d3.select(this).classed('hover', false);
          updateNodeColors();
          if (!isMobile) hideTooltipDelayed(100);
        });

    // Function to update node colors
    function updateNodeColors() {
      chartGroup.selectAll('.node').each(function(d){
        const nodeG = d3.select(this);
        const rect = nodeG.select('rect.visible-node');
        if (!rect.empty()){
          const isHighlighted = nodeG.classed('hover') || nodeG.classed('active') || nodeG.classed('focused');
          rect.attr('fill', isHighlighted ? getLighterForNode(d) : (d.type === 'arg' ? getArgColor(d.id) : getAttrColor(d.id)));
        }
      });
    }

      // Tooltip for keyboard-focused nodes (centered over/near node rectangle)
      function showNodeTooltipForFocus(d, nodeEl){
        try{
          const rectEl = nodeEl.querySelector && nodeEl.querySelector('rect.visible-node');
          if (!rectEl) return;
          const r = rectEl.getBoundingClientRect();
          const syntheticEvt = { // minimal event-like object for positioning
            pageX: r.left + window.pageXOffset + r.width + 12,
            pageY: r.top + window.pageYOffset + r.height/2
          };
          if (d.type === 'arg') {
            const meta = argById.get(d.id) || {};
            const steps = meta.steps || [];
            let bodyHtml;
              if (steps.length) {
                const items = steps.map(s => `<li style="margin:0 0 8px 0; line-height:1.4">${formatStepHtml(s.text)}</li>`).join('');
                bodyHtml = `<ol style="margin:6px 0 0 0; padding-left:20px;">${items}</ol>`;
              } else { bodyHtml = '(no steps found)'; }
            showTooltipAtMouse(syntheticEvt, `<strong>${meta.title || d.label}</strong><br/>${bodyHtml}`, { avoidRect: r });
          } else {
            const meta = attrById.get(d.id) || {};
            const desc = meta.description || '(no description)';
            showTooltipAtMouse(syntheticEvt, `<strong>${meta.title || d.label}</strong><br/>${desc}`, { avoidRect: r });
          }
        }catch(e){}
      }

      // Tooltip for keyboard-focused links (midpoint of link path)
      function showLinkTooltipForFocus(d, linkEl){
        /* Center the tooltip directly over the connector midpoint (not offset to the side) */
        try {
          const sNode = nodes[d.source.index];
          const tNode = nodes[d.target.index];
          const label = `${sNode.label} → ${tNode.label}`;
          const sx1 = d.source.x1;
          const tx0 = d.target.x0;
            const sCy = (d.source.y0 + d.source.y1) / 2;
            const tCy = (d.target.y0 + d.target.y1) / 2;
          const midDataX = (sx1 + tx0) / 2;
          const midDataY = (sCy + tCy) / 2;
          const zt = d3.zoomTransform(svg.node());
          const svgRect = svg.node().getBoundingClientRect();
          const midPageX = zt.applyX(midDataX) + svgRect.left + window.pageXOffset;
          const midPageY = zt.applyY(midDataY) + svgRect.top + window.pageYOffset;
          showTooltipCentered(midPageX, midPageY, `<strong>${label}</strong><br/>${d.explain}`);
        } catch(e) { /* ignore */ }
      }

    // Add an enlarged invisible hit-target for touch / coarse pointers (insert first so visible rect stays on top)
    const isCoarse = window.matchMedia('(pointer: coarse)').matches;
    // Track interaction modality to distinguish keyboard focus from mouse click focus on desktop.
    let lastInteractionWasKeyboard = false;
    window.addEventListener('keydown', e => {
      // Tab and arrow navigation (and Enter/Space) count as keyboard intent
      if (['Tab','Shift','ArrowUp','ArrowDown','ArrowLeft','ArrowRight','Enter',' '].includes(e.key)) {
        lastInteractionWasKeyboard = true;
        // Switching to keyboard modality: clear any hover/active states from mouse
        d3.selectAll('.node').classed('hover', false).classed('active', false);
        // Recompute colors (focused will be re-added by focus handler)
        updateNodeColors();
        hideTooltipImmediate();
      }
    });
    window.addEventListener('mousedown', () => {
      if (!lastInteractionWasKeyboard) return; // already mouse
      // Switching to mouse: remove keyboard-focused styling (will reapply on actual hover)
      lastInteractionWasKeyboard = false;
      d3.selectAll('.node').classed('focused', false);
      d3.selectAll('.link').classed('kb-focus', false);
      updateNodeColors();
      hideTooltipImmediate();
    });
    window.addEventListener('pointerdown', e => {
      if (e.pointerType === 'mouse' && lastInteractionWasKeyboard) {
        lastInteractionWasKeyboard = false;
        d3.selectAll('.node').classed('focused', false);
        d3.selectAll('.link').classed('kb-focus', false);
        updateNodeColors();
        hideTooltipImmediate();
      }
    });
    if (isCoarse) {
      node.append('rect')
        .attr('class', 'hit-target')
        .attr('x', d => d.x0 - 8)
        .attr('y', d => d.y0 - 4)
        .attr('width', d => (d.x1 - d.x0) + 16)
        .attr('height', d => (d.y1 - d.y0) + 8)
        .attr('fill', 'transparent')
        .style('pointer-events', 'all');
    }

    // Base visual rectangles exactly matching sankey layout coordinates (appended after hit-target to be on top)
    const nodeRects = node.append('rect')
      .attr('class', 'visible-node')
      .attr('x', d => d.x0)
      .attr('y', d => d.y0)
      .attr('height', d => Math.max(6, d.y1 - d.y0))
      .attr('width', d => d.x1 - d.x0)
      .attr('rx', 2).attr('ry', 2)
      .attr('fill', d => d.type === 'arg' ? getArgColor(d.id) : getAttrColor(d.id));

    const labels = node.append('text')
      .attr('class', 'label')
      .attr('x', d => (d.x0 + d.x1) / 2)
      .attr('y', d => (d.y0 + d.y1) / 2)
      .attr('text-anchor', 'middle')
      .style('fill', 'var(--fg)')
      .text(d => {
        const meta = d.type === 'arg' ? (argById.get(d.id) || {}) : (attrById.get(d.id) || {});
        // On mobile use the short abbreviation (meta.abbr). On desktop prefer a slightly longer
        // label that drops the word "Argument" (meta.abbrDesktop) if available; otherwise fall back.
        if (isMobile) return meta.abbr || d.label;
        return meta.abbrDesktop || meta.abbr || d.label;
      })
      .style('font-size', isMobile ? '12px' : null);

    // Apply initial node colors (respects any current focused/active state)
    updateNodeColors();

    // Explicit sequential tab order: aboutBtn, themeToggle, nodes (visual top->bottom), then links (top->bottom)
    function assignTabOrder(){
      let idx = 1;
      d3.select('#aboutBtn').attr('tabindex', idx++);
      d3.select('#themeToggle').attr('tabindex', idx++);
      // sort nodes by top y position
      const nodeOrder = graph.nodes.slice().sort((a,b) => a.y0 - b.y0);
      nodeOrder.forEach(n => {
        chartGroup.selectAll('.node').filter(d => d === n).attr('tabindex', idx++);
      });
      // sort links by vertical midpoint of their source (or avg of both)
      const linkOrder = graph.links.slice().sort((a,b) => {
        const ay = ((a.source.y0 + a.source.y1)/2 + (a.target.y0 + a.target.y1)/2)/2;
        const by = ((b.source.y0 + b.source.y1)/2 + (b.target.y0 + b.target.y1)/2)/2;
        return ay - by;
      });
      linkOrder.forEach(l => {
        chartGroup.selectAll('.link').filter(d => d === l).attr('tabindex', idx++);
      });
    }
    assignTabOrder();

    // Create hidden descriptions for links and nodes for screen readers
    (function createA11yDescriptions(){
      graph.links.forEach((l, i) => {
        const id = `link-${i}-desc`;
        if (!document.getElementById(id)){
          const div = document.createElement('div');
          div.id = id;
          div.className = 'sr-only';
          const s = nodes[l.source.index];
          const t = nodes[l.target.index];
          div.textContent = `${s.label} to ${t.label}. ${l.explain || ''}`;
          document.body.appendChild(div);
        }
      });
      graph.nodes.forEach((n, i) => {
        const id = `node-${n.index}-desc`;
        if (!document.getElementById(id)){
          const div = document.createElement('div');
          div.id = id;
          div.className = 'sr-only';
          if (n.type === 'arg'){
            const meta = argById.get(n.id) || {};
            const steps = (meta.steps || []).map(s => s.text).join(' — ');
            div.textContent = `${meta.title || n.label}. ${steps || ''}`;
          } else {
            const meta = attrById.get(n.id) || {};
            div.textContent = `${meta.title || n.label}. ${meta.description || ''}`;
          }
          document.body.appendChild(div);
        }
      });
    })();

    function isolate(n){
      node.classed('faint', d => d !== n);
      link.classed('faint', d => d.source !== n && d.target !== n);
    }
    // Hide tooltip when clicking or tapping outside nodes/links/tooltip
    function hideTooltipIfOutside(event){
      const el = event.target;
      if (!el) return;
      // if click inside a node, link, or the tooltip itself, do nothing
      if (el.closest && (el.closest('.node') || el.closest('.link') || el.closest('#tooltip'))) return;
      hideTooltipImmediate();
      // clear visual interaction states
      d3.selectAll('.node').classed('hover', false).classed('active', false).classed('focused', false);
      // remove any isolation fainting
      d3.selectAll('.node').classed('faint', false);
      d3.selectAll('.link').classed('faint', false).classed('active-link', false).classed('kb-focus', false);
      // recompute node colors so previously lightened fill resets
      updateNodeColors();
    }
    document.addEventListener('click', hideTooltipIfOutside);
    document.addEventListener('touchstart', hideTooltipIfOutside);

  window.addEventListener('keydown', e => { if (e.key === 'Escape') { node.classed('faint', false); link.classed('faint', false); hideTooltipImmediate(); d3.selectAll('.node').classed('hover', false).classed('active', false).classed('focused', false); d3.selectAll('.link').classed('active-link', false).classed('kb-focus', false); updateNodeColors(); }});

      })();
    </script>
</body>
</html>
