<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <title>Tidy Tree</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
        #topbar {
            display: flex;
            align-items: center;
            gap: 16px;
            padding: 8px 24px;
            background: var(--bg-light);
            border-bottom: 1px solid #e0e0e0;
            min-height: 48px;
        }
        body.dark-mode #topbar {
            background: var(--bg-dark);
            border-bottom: 1px solid var(--link-dark);
        }
        #topbar label, #topbar button {
            margin: 0 4px;
        }
        #topbar label {
            font-weight: 500;
            color: inherit;
            display: flex;
            align-items: center;
            gap: 4px;
        }
        #topbar button {
            background: linear-gradient(90deg, #00BFAE 0%, #0074d9 100%);
            color: #fff;
            border: none;
            border-radius: 6px;
            padding: 8px 14px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0,0,0,0.06);
            transition: background 0.2s, box-shadow 0.2s, color 0.2s;
        }
        #topbar button:hover, #topbar button:focus {
            background: linear-gradient(90deg, #00E6B2 0%, #005fa3 100%);
            color: #fff;
            box-shadow: 0 4px 16px rgba(0,0,0,0.10);
        }
        body.dark-mode #topbar button {
            background: linear-gradient(90deg, var(--accent-dark) 0%, #005fa3 100%);
            color: var(--text-dark);
        }
        body.dark-mode #topbar button:hover, body.dark-mode #topbar button:focus {
            background: linear-gradient(90deg, var(--node-hover-stroke-dark) 0%, #003d5c 100%);
            color: var(--text-dark);
        }
        #topbar input[type="checkbox"] {
            accent-color: #00BFAE;
            width: 16px;
            height: 16px;
            margin-right: 4px;
        }
        body.dark-mode #topbar input[type="checkbox"] {
            accent-color: var(--accent-dark);
        }
        #topbar > * {
            margin-right: 8px;
        }
        #topbar > *:last-child {
            margin-right: 0;
        }
        :root {
            --bg-light: #fff;
            --bg-dark: #181A20;
            --panel-dark: #23272F;
            --node-fill-dark: #263238;
            --node-stroke-dark: #00BFAE;
            --node-hover-fill-dark: #374151;
            --node-hover-stroke-dark: #00E6B2;
            --link-dark: #3B4252;
            --text-dark: #E0E7EF;
            --text-secondary-dark: #A0AEC0;
            --accent-dark: #00BFAE;
            --tooltip-bg-dark: #23272F;
            --tooltip-border-dark: #00BFAE;
        }

        body {
            margin: 0;
            font: 14px/1.4 system-ui, sans-serif;
            overflow: hidden;
            background: var(--bg-light);
            color: #222;
            transition: background 0.3s, color 0.3s;
        }

        body.dark-mode {
            background: var(--bg-dark);
            color: var(--text-dark);
        }

        body.dark-mode #topbar {
            background: var(--bg-dark);
            border-bottom: 1px solid var(--link-dark);
            color: var(--text-dark);
        }

        #chart {
            width: 100vw;
            height: calc(100vh - 48px);
            overflow: hidden;
            background: var(--bg-light);
        }

        body.dark-mode #chart {
            background: var(--bg-dark);
        }

        svg {
            width: 100%;
            height: 100%;
            display: block;
            background: transparent;
            touch-action: none; /* allow d3-zoom to handle gestures on mobile */
        }

        /* Small-screen adjustments */
        @media (max-width: 600px) {
            #topbar {
                flex-wrap: wrap;
                gap: 8px;
                padding: 8px 12px;
                overflow-x: auto; /* allow horizontal scroll if too many controls */
                -webkit-overflow-scrolling: touch;
            }
            #topbar button { min-width: 110px; }
            #topbar > * { margin-right: 8px; }
            #topbar strong { font-size: 16px; }
            #topbar button {
                padding: 8px 10px;
                font-size: 15px;
                min-height: 40px;
            }
            .tooltip, .popup-help {
                max-width: calc(100vw - 24px);
                font-size: 15px;
                padding: 10px;
            }
            .esv-credit {
                left: 8px;
                right: 8px;
                bottom: 8px;
                max-width: none;
                font-size: 12px;
            }
            /* hide the footer on small screens to avoid overlaying the chart and bottom-sheet */
            .esv-credit { display: none; }
            /* Controls toggle and bottom-sheet */
            /* make toggle fixed so it doesn't get scrolled/hidden on small screens */
            #controlsToggle { display: inline-block !important; position: fixed !important; left: 12px; top: calc(env(safe-area-inset-top, 0px) + 8px); z-index: 9000; }
            #controls { display: none; width: 100%; }
            #controls.open { display: flex; flex-wrap: wrap; gap: 8px; }
            .bottom-sheet { background: var(--bg-dark); color: var(--text-dark); }
            /* when JS positions the controls as fixed, improve scrolling and backdrop */
            #controls[style] {
                -webkit-overflow-scrolling: touch;
                scrollbar-width: thin;
                background-clip: padding-box;
                backdrop-filter: blur(6px) saturate(80%);
            }
        }

        /* hide the large page title on small screens (we show controls instead) */
        @media (max-width: 600px) {
            #topbar strong { display: none; }
            /* compact mobile controls panel will be positioned by JS to avoid overlapping the divider */
        }

        /* keep topbar above floating bottom-sheet */
        #topbar { position: relative; z-index: 5000; }

        /* bottom-sheet base styles (works on all sizes but optimized for mobile) */
        .bottom-sheet {
            position: fixed;
            left: 0;
            right: 0;
            bottom: -100%;
            background: var(--bg-dark);
            color: var(--text-dark);
            border-top-left-radius: 12px;
            border-top-right-radius: 12px;
            box-shadow: 0 -8px 24px rgba(0,0,0,0.32);
            padding: 16px;
            z-index: 2500;
            transition: bottom 260ms ease;
            max-height: 70vh;
            overflow: auto;
        }
        .bottom-sheet.open { bottom: 0; }
        .bottom-sheet .close-btn {
            position: absolute;
            right: 12px;
            top: 8px;
            background: transparent;
            border: none;
            color: var(--text-dark);
            font-size: 20px;
            padding: 6px;
            cursor: pointer;
        }

        .link {
            fill: none;
            stroke: #ccc;
            stroke-width: 1.5px;
        }

        body.dark-mode .link {
            stroke: var(--link-dark);
        }

        .node circle {
            r: 5;
            cursor: pointer;
            stroke: #333;
            stroke-width: 1px;
            fill: #fff;
            transition: fill 0.2s, stroke 0.2s;
        }

        .node circle {
            fill: #e0f7fa;
            stroke: #00796b;
        }

        body.dark-mode .node circle {
            fill: var(--node-fill-dark);
            stroke: var(--node-stroke-dark);
        }

        .node:hover circle {
            fill: #b2ebf2;
            stroke: #004d40;
        }

        body.dark-mode .node:hover circle {
            fill: var(--node-hover-fill-dark);
            stroke: var(--node-hover-stroke-dark);
        }

        .node text {
            font-size: 12px;
            dominant-baseline: middle;
            paint-order: stroke;
            stroke: #fff;
            stroke-width: 4px;
            stroke-linejoin: round;
        }

        .node text tspan {
            paint-order: stroke;
            stroke: #fff;
            stroke-width: 4px;
            stroke-linejoin: round;
        }

        .node text .label {
            fill: #222;
            stroke: none;
        }

        body.dark-mode .node text {
            fill: var(--text-dark) !important;
            stroke: var(--bg-dark) !important;
        }

        body.dark-mode .node text .label {
            fill: var(--text-dark) !important;
            stroke: none !important;
        }

        .tooltip {
            position: fixed;
            pointer-events: auto;
            background: #fff;
            border: 1px solid #ddd;
            padding: 8px 10px;
            border-radius: 6px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, .08);
            max-width: 320px;
            font-size: 13px;
            z-index: 1000;
        }

        .popup-help {
            position: fixed;
            pointer-events: auto;
            background: #fff;
            border: 1px solid #ddd;
            padding: 8px 10px;
            border-radius: 6px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, .08);
            max-width: 320px;
            font-size: 13px;
            z-index: 1001;
        }

        body.dark-mode .tooltip,
        body.dark-mode .popup-help {
            background: var(--tooltip-bg-dark) !important;
            border: 1px solid var(--tooltip-border-dark) !important;
            color: var(--text-dark) !important;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.32) !important;
        }

        body.dark-mode .tooltip a,
        body.dark-mode .popup-help a {
            color: var(--accent-dark) !important;
            text-decoration: underline;
        }

        body.dark-mode .tooltip a:hover,
        body.dark-mode .popup-help a:hover {
            color: var(--node-hover-stroke-dark) !important;
        }

        .node.clickable text {
            fill: #0074d9;
            cursor: pointer;
            text-decoration: none;
        }

        .node.clickable:hover text {
            fill: #005fa3;
            text-decoration: none;
        }
        /* ESV credit footnote (small, unobtrusive, respects dark mode) */
        .esv-credit {
            position: fixed;
            left: 12px;
            bottom: 8px;
            z-index: 2000;
            font-size: 12px;
            line-height: 1.2;
            padding: 6px 8px;
            border-radius: 6px;
            background: rgba(255,255,255,0.92);
            color: #333;
            border: 1px solid #e6e6e6;
            opacity: 0.95;
            pointer-events: none;
            max-width: calc(100vw - 40px);
        }

        body.dark-mode .esv-credit {
            background: rgba(24,26,32,0.7);
            color: var(--text-secondary-dark);
            border: 1px solid rgba(255,255,255,0.04);
        }
    </style>
</head>

<body class="dark-mode">
    <div id="topbar">
    <strong style="font-size:18px; letter-spacing:0.5px; margin-right:16px;">Tidy Tree</strong>
    <button id="controlsToggle" aria-expanded="false">Controls ▾</button>
        <div id="controls" style="display:flex; align-items:center; gap:12px;">
            <label style="display:none;"><input type="checkbox" id="wrap"> Wrap labels</label>
            <label><input type="checkbox" id="clusterToggle"> Cluster layout</label>
            <label style="display:none;">Node size: <input type="range" id="nodesize" min="10" max="100" value="20"></label>
            <label style="display:none;">Vertical spacing: <input type="range" id="nodesizeY" min="10" max="150" value="60"></label>
            <label style="display:none;">Horizontal spacing: <input type="range" id="nodesizeX" min="10" max="300" value="180"></label>
            <button id="collapseAll">Collapse All</button>
            <button id="expandAll">Expand All</button>
            <button id="collapseOneLevel">Collapse One Level</button>
            <button id="expandOneLevel">Expand One Level</button>
        </div>
        <label style="margin-left:auto;"><input type="checkbox" id="darkModeToggle"> Dark mode</label>
    </div>
    <div id="chart"></div>

    <!-- bottom sheet for mobile node details -->
    <div id="bottomSheet" class="bottom-sheet" role="dialog" aria-hidden="true"></div>

    <!-- D3 v7 -->
    <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
    <script>
        async function init() {
            let response = await fetch('data/ResurrectionDisciplesBelievedItActs01.json');
            let data = await response.json();

            // === 2) Basic settings ===
            const container = document.getElementById('chart');
            let width = container.clientWidth;
            let height = container.clientHeight;

                // Compute chart height based on topbar height so content isn't hidden under it on small screens
                function computeChartHeight() {
                    const topbar = document.getElementById('topbar');
                    const rect = topbar ? topbar.getBoundingClientRect() : { height: 48 };
                    const hh = Math.max(48, rect.height);
                    const chartEl = document.getElementById('chart');
                    chartEl.style.height = `calc(100vh - ${hh}px)`;
                    width = chartEl.clientWidth;
                    height = chartEl.clientHeight;
                    svg.attr('width', width).attr('height', height);
                }

                // Create bottom-sheet element for mobile node details
                const bottomSheet = document.getElementById('bottomSheet');
                function openBottomSheet(html) {
                    // hide other transient UI
                    tooltip.style('opacity', 0);
                    popupHelp.style('opacity', 0).style('pointer-events', 'none');
                    bottomSheet.innerHTML = `<button class="close-btn" aria-label="Close">×</button><div class="bottom-content">${html}</div>`;
                    bottomSheet.classList.add('open');
                    bottomSheet.setAttribute('aria-hidden', 'false');
                    // ensure visible on small screens
                    setTimeout(() => {
                        bottomSheet.scrollIntoView({ behavior: 'smooth', block: 'end' });
                        const btn = bottomSheet.querySelector('.close-btn');
                        if (btn) { btn.focus({ preventScroll: true }); btn.addEventListener('click', closeBottomSheet, { once: true }); }
                    }, 50);
                }
                function closeBottomSheet() {
                    bottomSheet.classList.remove('open');
                    bottomSheet.setAttribute('aria-hidden', 'true');
                }
                bottomSheet.addEventListener('click', (e)=>{
                    // allow clicking outside content to close if needed; a close button could be added
                    if (e.target === bottomSheet) closeBottomSheet();
                });

                // Controls toggle for small screens
                const controlsToggle = document.getElementById('controlsToggle');
                const controls = document.getElementById('controls');
                function updateControlsVisibility() {
                    const isSmall = window.matchMedia && window.matchMedia('(max-width: 600px)').matches;
                    // rely on CSS for toggle visibility to avoid inline style flashing
                    if (!isSmall) { controls.classList.add('open'); controls.style.display = 'flex'; }
                    else { controls.classList.remove('open'); controls.style.display = 'none'; }
                }
                controlsToggle.addEventListener('click', ()=>{
                    const open = controls.classList.toggle('open');
                    controls.style.display = open ? 'flex' : 'none';
                    controlsToggle.setAttribute('aria-expanded', open ? 'true' : 'false');
                    // position controls right below topbar on small screens
                    const isSmall = window.matchMedia && window.matchMedia('(max-width: 600px)').matches;
                    if (isSmall && open) {
                        // anchor the panel to the controls toggle so it appears directly under the button
                        const toggleRect = controlsToggle.getBoundingClientRect();
                        controls.style.position = 'fixed';
                        controls.style.left = Math.max(8, toggleRect.left) + 'px';
                        controls.style.top = (toggleRect.bottom + 6) + 'px';
                        controls.style.background = 'linear-gradient(90deg, rgba(0,191,174,0.04), rgba(0,116,217,0.04))';
                        controls.style.padding = '8px';
                        controls.style.borderRadius = '10px';
                        controls.style.boxShadow = '0 8px 24px rgba(0,0,0,0.4)';
                        controls.style.maxWidth = 'calc(100vw - 32px)';
                        // limit height so it doesn't sit on top of the tree; allow internal scrolling
                        controls.style.maxHeight = '38vh';
                        controls.style.overflow = 'auto';
                        controls.style.zIndex = 8600;
                    } else {
                        // reset inline positioning
                        controls.style.position = '';
                        controls.style.left = '';
                        controls.style.top = '';
                        controls.style.background = '';
                        controls.style.padding = '';
                        controls.style.borderRadius = '';
                        controls.style.boxShadow = '';
                        controls.style.maxWidth = '';
                        controls.style.zIndex = '';
                    }
                });
                updateControlsVisibility();

            const svg = d3.select("#chart").append("svg")
                .attr("width", width).attr("height", height)
                .attr('role', 'img')
                .attr('aria-label', 'Tidy tree visualization');

            // Create a main group for zoom/pan
            const g = svg.append("g");
            // Create links and nodes groups in correct order
            const linkGroup = g.append("g").attr("class", "links");
            const nodeGroup = g.append("g").attr("class", "nodes");

            // allow broader zoom on touch devices for easier pinch-zooming
            const zoom = d3.zoom().scaleExtent([0.3, 4]).on("zoom", (event) => {
                g.attr("transform", event.transform);
                updatePopupHelpPosition();
            });
            svg.call(zoom);

            // ensure chart height computed initially (now that svg exists)
            computeChartHeight();

            // Handle resizing: keep SVG sized to container and re-layout tree
            function resizeHandler() {
                // recompute chart height using topbar
                computeChartHeight();
                updateControlsVisibility();
                // Recompute layout origin so root remains roughly centered vertically
                if (root) {
                    root.x0 = height / 2;
                }
                update(root);
                // Maintain a sensible transform after resize
                const currentTransform = d3.zoomTransform(svg.node());
                // if transform is identity, re-center root
                if (currentTransform.k === 1 && Math.abs(currentTransform.x) < 1 && Math.abs(currentTransform.y) < 1) {
                    svg.call(zoom.transform, d3.zoomIdentity.translate(Math.min(220, width * 0.25), height / 2).scale(1));
                }
            }

            // Debounced resize
            let resizeTimer = null;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimer);
                resizeTimer = setTimeout(resizeHandler, 150);
            });

            // ensure chart height computed initially
            computeChartHeight();


            const tooltip = d3.select("body").append("div")
                .attr("class", "tooltip").style("opacity", 0);
            // Add a separate popup help element
            const popupHelp = d3.select("body").append("div")
                .attr("class", "popup-help").style("opacity", 0).style("position", "fixed");

            // Helper to clamp a fixed-position element to the viewport (keeps a small margin)
            function clampToViewport(sel, desiredLeft, desiredTop) {
                const el = sel.node();
                const margin = 8;
                if (!el) return { left: desiredLeft, top: desiredTop };
                // Temporarily set to desired position so getBoundingClientRect reports correct size
                sel.style('left', desiredLeft + 'px').style('top', desiredTop + 'px');
                const rect = el.getBoundingClientRect();
                const maxTop = Math.max(margin, window.innerHeight - rect.height - margin);
                const maxLeft = Math.max(margin, window.innerWidth - rect.width - margin);
                const left = Math.min(Math.max(desiredLeft, margin), maxLeft);
                const top = Math.min(Math.max(desiredTop, margin), maxTop);
                sel.style('left', left + 'px').style('top', top + 'px');
                return { left, top };
            }

            // Minimal robust popup help tracking
            let popupHelpNode = null;

            function updatePopupHelpPosition() {
                if (!popupHelpNode) return;
                // Use tree layout coordinates
                let x = popupHelpNode.x;
                let y = popupHelpNode.y;
                // Get current transform
                const transform = d3.zoomTransform(svg.node());
                // Apply D3 transform to node coordinates
                const transformed = transform.apply([y, x]);
                // Convert SVG coordinates to screen coordinates
                const point = svg.node().createSVGPoint();
                point.x = transformed[0];
                point.y = transformed[1];
                const ctm = svg.node().getScreenCTM();
                if (ctm) {
                    const screenPoint = point.matrixTransform(ctm);
                    // Calculate desired position with offset
                    const desiredLeft = screenPoint.x + 24;
                    const desiredTop = screenPoint.y + 24;
                    // Clamp to viewport so popup doesn't go below the bottom (or off the right)
                    const popupEl = popupHelp.node();
                    if (popupEl) {
                        const rect = popupEl.getBoundingClientRect();
                        const margin = 8;
                        const maxTop = Math.max(margin, window.innerHeight - rect.height - margin);
                        const maxLeft = Math.max(margin, window.innerWidth - rect.width - margin);
                        const left = Math.min(Math.max(desiredLeft, margin), maxLeft);
                        const top = Math.min(Math.max(desiredTop, margin), maxTop);
                        popupHelp.style("left", left + "px").style("top", top + "px");
                    } else {
                        popupHelp.style("left", (screenPoint.x + 24) + "px").style("top", (screenPoint.y + 24) + "px");
                    }
                }
            }

            // Ensure the rendered tree fits horizontally in the viewport by nudging the zoom transform
            // so the left/right visible node extents don't fall outside the screen on small devices.
        function ensureTreeVisible(margin = 24) {
                try {
            // on narrow phones give a larger margin to avoid nodes being too close to the edge
            const small = window.matchMedia && window.matchMedia('(max-width: 600px)').matches;
            if (small) margin = Math.max(margin, 48);
                    const nodes = root.descendants().filter(d => !(d.x == null || d.y == null));
                    if (!nodes || nodes.length === 0) return;
                    const transform = d3.zoomTransform(svg.node());
                    // compute screen X (horizontal) for each node (svg coords are [y,x])
                    let minScreenX = Infinity, maxScreenX = -Infinity;
                    nodes.forEach(d => {
                        const pt = transform.apply([d.y, d.x]);
                        const sx = pt[0];
                        if (sx < minScreenX) minScreenX = sx;
                        if (sx > maxScreenX) maxScreenX = sx;
                    });
                    const leftLimit = margin;
                    const rightLimit = window.innerWidth - margin;
                    let dx = 0;
                    if (maxScreenX > rightLimit) {
                        dx = rightLimit - maxScreenX; // negative value moves tree left
                    } else if (minScreenX < leftLimit) {
                        dx = leftLimit - minScreenX; // positive moves tree right
                    }
                    if (dx !== 0) {
                        const newTransform = d3.zoomIdentity.translate(transform.x + dx, transform.y).scale(transform.k);
                        svg.transition().duration(300).call(zoom.transform, newTransform);
                    }
                } catch (e) {
                    // non-fatal
                    console.warn('ensureTreeVisible failed', e);
                }
            }

            // Collapsible tree helpers
            function collapse(d) {
                if (d.children) { d._children = d.children; d._children.forEach(collapse); d.children = null; }
            }
            function expand(d) {
                if (d._children) { d.children = d._children; d._children = null; }
            }

            const root = d3.hierarchy(data);
            root.x0 = height / 2;
            root.y0 = 0;
            // Collapse the 'Death', 'Burial', and 'Resurrection' nodes themselves so only those are visible under the root
            if (root.children) {
                root.children.forEach(child => {
                    if (["Death", "Burial", "Resurrection"].includes(child.data.name)) {
                        collapse(child);
                    } else {
                        collapse(child);
                    }
                });
            }

            // Default to cluster layout
            let treeLayout = d3.cluster();
            // initial nodeSize will be set from the UI controls below so spacing matches the visible defaults

            // Controls
            const nodeSizeYInput = document.getElementById('nodesizeY');
            const nodeSizeXInput = document.getElementById('nodesizeX');
            nodeSizeYInput.addEventListener('input', updateNodeSize);
            nodeSizeXInput.addEventListener('input', updateNodeSize);
            function updateNodeSize() {
                const y = +nodeSizeYInput.value;
                const x = +nodeSizeXInput.value;
                treeLayout.nodeSize([y, x]);
                update(root);
            }
            // const tree = d3.tree().nodeSize([120, 200]); // vertical spacing, horizontal spacing

            const nodeSizeInput = document.getElementById('nodesize');
            nodeSizeInput.addEventListener('input', () => {
                const v = +nodeSizeInput.value;
                treeLayout.nodeSize([v, v + 80]);
                update(root);
            });
            const wrapToggle = document.getElementById('wrap');

            // Initialize layout sizing to the denser defaults used previously
            // But increase vertical spacing on narrow/tall mobile screens so nodes don't overlap
            const initialVertical = (height && height < 700) ? 28 : 17; // vertical spacing (larger on phones)
            // Slightly reduce horizontal spacing on narrow screens so the tree fits
            const initialHorizontal = (width && width < 480) ? 160 : 200; // horizontal spacing
            // Sync hidden UI controls to reflect these defaults so toggling preserves expected spacing
            if (nodeSizeYInput) nodeSizeYInput.value = initialVertical;
            if (nodeSizeXInput) nodeSizeXInput.value = initialHorizontal;
            if (nodeSizeInput) nodeSizeInput.value = initialVertical;
            treeLayout.nodeSize([initialVertical, initialHorizontal]);

            // Cluster toggle: set up once (not inside update) so it isn't reset on every render
            const clusterToggle = document.getElementById('clusterToggle');
            // Default to cluster layout (matches initial treeLayout)
            clusterToggle.checked = true;
            clusterToggle.addEventListener('change', function () {
                if (clusterToggle.checked) {
                    treeLayout = d3.cluster();
                } else {
                    treeLayout = d3.tree();
                }
                // Keep node size settings
                const y = +nodeSizeYInput.value;
                const x = +nodeSizeXInput.value;
                treeLayout.nodeSize([y, x]);
                update(root);
            });

            // Word wrap helper
            function wrapText(selection, width = 160) {
                selection.each(function (d) {
                    const text = d3.select(this);
                    const words = (text.text() || "").split(/\s+/).reverse();
                    let line = [], lineNumber = 0;
                    // Set x based on node type
                    const x = (d.children || d._children) ? -10 : 10;
                    let tspan = text.text(null).append("tspan").attr("x", x).attr("dy", "0em");
                    let word, lineHeight = 1.1;
                    while (word = words.pop()) {
                        line.push(word);
                        tspan.text(line.join(" "));
                        if (tspan.node().getComputedTextLength() > width) {
                            line.pop();
                            tspan.text(line.join(" "));
                            line = [word];
                            tspan = text.append("tspan")
                                .attr("x", x)
                                .attr("dy", ++lineNumber * lineHeight + "em")
                                .text(word);
                        }
                    }
                });
            }

            // Color per node (inherit from ancestors if not set)
            function nodeColor(d) {
                let x = d;
                while (x) {
                    if (x.data && x.data.color) return x.data.color;
                    x = x.parent;
                }
                return "#6c6c6c";
            }

            function update(source) {
                treeLayout(root);
                const nodes = root.descendants();
                const links = root.links();
                // (cluster toggle is wired once at top-level to avoid being reset on each update)

                // nodes.forEach(d => d.y = d.depth * 180); // horizontal spacing per depth

                // LINKS (drawn first, behind nodes)
                const link = linkGroup.selectAll("path.link").data(links, d => d.target.id || (d.target.id = crypto.randomUUID()));
                link.enter().append("path")
                    .attr("class", "link")
                    .attr("d", d3.linkHorizontal().x(d => source.y0).y(d => source.x0))
                    .merge(link)
                    .transition().duration(350)
                    .attr("d", d3.linkHorizontal().x(d => d.y).y(d => d.x));
                link.exit().transition().duration(250)
                    .attr("d", d3.linkHorizontal().x(d => source.y).y(d => source.x))
                    .remove();

                // NODES (drawn above links)
                const node = nodeGroup.selectAll("g.node").data(nodes, d => d.id || (d.id = crypto.randomUUID()));

                // Shared activation logic for nodes (click or tap)
                function handleNodeActivate(event, d) {
                    const isSmall = window.matchMedia && window.matchMedia('(max-width: 600px)').matches;
                    if (!d.children && !d._children && d.data.source && d.data.source.url) {
                        let html = `<strong>${d.data.name}</strong>`;
                        if (d.data.date) html += `<div style='margin-top:4px; font-weight:bold;'>${d.data.date}</div>`;
                        if (d.data.details) html += `<div style='margin-top:6px;'>${d.data.details}</div>`;
                        html += `<div style='margin-top:10px;'><a href='${d.data.source.url}' target='_blank' style='color:var(--accent-dark);text-decoration:underline'>${d.data.source.title || "View Source"}</a></div>`;
                        if (isSmall) {
                            openBottomSheet(html);
                        } else {
                            popupHelp.html(html)
                                .style("opacity", 1)
                                .style("pointer-events", "auto");
                            popupHelpNode = d;
                            updatePopupHelpPosition();
                            setTimeout(() => {
                                document.addEventListener('pointerdown', popupHelpOutsideClickHandler, true);
                            }, 0);
                        }
                    } else {
                        if (!d.children && d._children) {
                            expand(d);
                            if (d.children) d.children.forEach(expandAllRecursive);
                        } else {
                            collapse(d);
                        }
                        update(d);
                        popupHelp.style("opacity", 0)
                            .style("pointer-events", "none");
                        document.removeEventListener('pointerdown', popupHelpOutsideClickHandler, true);
                        popupHelpNode = null;
                    }
                }

                // tap detection: small movement + short time -> treat as tap
                const pointerStarts = new Map();

                const nodeEnter = node.enter().append("g")
                    .attr("class", d => (!d.children && !d._children && d.data.source && d.data.source.url) ? "node clickable" : "node")
                    .attr("transform", d => `translate(${source.y0},${source.x0})`)
                    .on('pointerdown', (event, d) => {
                        try { if (event.isPrimary) pointerStarts.set(event.pointerId, { x: event.clientX, y: event.clientY, t: Date.now() }); } catch (e) { /* ignore */ }
                    })
                    .on('pointerup', (event, d) => {
                        const s = pointerStarts.get(event.pointerId);
                        if (s) {
                            const dx = event.clientX - s.x;
                            const dy = event.clientY - s.y;
                            const dist = Math.hypot(dx, dy);
                            const dt = Date.now() - s.t;
                            pointerStarts.delete(event.pointerId);
                            if (dist < 8 && dt < 400) {
                                // mark tapped to avoid duplicate click handling
                                d._handledTap = Date.now();
                                handleNodeActivate(event, d);
                                event.preventDefault();
                                return;
                            }
                        }
                    })
                    .on('pointercancel', (event) => { pointerStarts.delete(event.pointerId); })
                    .on('click', (event, d) => {
                        // avoid duplicate when pointerup already handled the tap
                        if (d._handledTap && (Date.now() - d._handledTap) < 600) { d._handledTap = 0; return; }
                        handleNodeActivate(event, d);
                    })
                    .on("pointerenter", (event, d) => {
                        // show subtitle on hover/enter (pointer-aware)
                        const txt = d.data.subtitle || "";
                        if (!txt) return;
                        tooltip.html(txt)
                            .style("opacity", 1)
                            .style("pointer-events", "none");
                        clampToViewport(tooltip, event.clientX + 24, event.clientY + 24);
                    })
                    .on("pointermove", (event) => {
                        clampToViewport(tooltip, event.clientX + 24, event.clientY + 24);
                    })
                    .on("pointerleave", () => {
                        tooltip.style("opacity", 0);
                    });
                // Remove mouseleave handler so tooltip doesn't disappear immediately

                // Helper to hide popup help only when clicking outside
                function popupHelpOutsideClickHandler(e) {
                    const popupEl = popupHelp.node();
                    if (popupHelp.style("opacity") === "1" && (!popupEl || (e.target !== popupEl && !popupEl.contains(e.target)))) {
                        popupHelp.style("opacity", 0)
                            .style("pointer-events", "none");
                        document.removeEventListener('pointerdown', popupHelpOutsideClickHandler, true);
                        // Quickfix: dispatch mouseleave to node under popup
                        if (popupHelpNode) {
                            // Find the corresponding SVG node group
                            const nodeGroup = d3.selectAll('g.node').filter(d => d === popupHelpNode);
                            nodeGroup.select('text').each(function () {
                                const evt = new MouseEvent('mouseleave', { bubbles: true });
                                this.dispatchEvent(evt);
                            });
                        }
                        popupHelpNode = null;
                    }
                }

                // Adjust node radius for small touch screens to improve tap targets
                const isSmall = window.matchMedia && window.matchMedia('(max-width: 600px)').matches;
                const targetRadius = isSmall ? 8 : 6;

                nodeEnter.append("circle")
                    .attr("r", 1e-6)
                    .attr("fill", d => (d._children ? nodeColor(d) : "#fff"))
                    .attr("stroke", d => nodeColor(d));

                const labels = nodeEnter.append("text")
                    .attr("dy", "0em")
                    .attr("x", d => (d.children || d._children) ? -10 : 10)
                    .attr("text-anchor", d => (d.children || d._children) ? "end" : "start")
                    .html(d => d.data.link
                        ? `<a href="${d.data.link}" target="_blank" style="fill:blue;text-decoration:underline">${d.data.name}</a>`
                        : d.data.name);

                function applyLabelWrapping() {
                    g.selectAll("g.node text").each(function (d) {
                        const text = d3.select(this);
                        text.text(d.data.name);
                        if (wrapToggle.checked) wrapText(text, 160);
                    });
                }
                applyLabelWrapping();
                wrapToggle.onchange = applyLabelWrapping;

                // UPDATE + TRANSITIONS
                const nodeUpdate = nodeEnter.merge(node);
                nodeUpdate.transition().duration(350)
                    .attr("transform", d => `translate(${d.y},${d.x})`)
                    .on("end", () => { updatePopupHelpPosition(); });
                nodeUpdate.select("circle").transition().duration(350)
                    .attr("r", targetRadius)
                    .attr("fill", d => (d._children ? nodeColor(d) : "#fff"))
                    .attr("stroke", d => nodeColor(d));
                nodeUpdate.select("text").transition().duration(350)
                    .attr("x", d => (d.children || d._children) ? -10 : 10)
                    .attr("text-anchor", d => (d.children || d._children) ? "end" : "start");

                const nodeExit = node.exit().transition().duration(250)
                    .attr("transform", d => `translate(${source.y},${source.x})`)
                    .remove();
                nodeExit.select("circle").attr("r", 1e-6);

                // Stash positions for smooth transitions next time
                nodes.forEach(d => { d.x0 = d.x; d.y0 = d.y; });
                // Make sure the tree fits the viewport (esp. on narrow phones where right nodes can be off-screen)
                ensureTreeVisible();
            }

            update(root);

            // Center root nicely
            // Shift right so root node is visible
            // Use a smaller left translate on small screens so we don't leave excessive blank space on the left
            const smallScreen = window.matchMedia && window.matchMedia('(max-width: 600px)').matches;
            const initialTranslateX = smallScreen ? Math.min(120, Math.max(40, width * 0.12)) : 220;
            svg.call(zoom.transform, d3.zoomIdentity.translate(initialTranslateX, height / 2).scale(1));
            // Ensure nodes fit the viewport after initial centering
            setTimeout(() => ensureTreeVisible(), 120);

            // Collapse or expand all nodes
            function collapseAll(d) {
                if (d.children) {
                    d.children.forEach(collapseAll);
                    collapse(d);
                }
            }
            function expandAll(d) {
                if (d._children) {
                    expand(d);
                    d.children.forEach(expandAll);
                } else if (d.children) {
                    d.children.forEach(expandAll);
                }
            }

            document.getElementById('collapseAll').onclick = () => {
                root.children && root.children.forEach(collapseAll);
                update(root);
                // update tracked index
                currentExpansionIndex = findMatchingStateIndex();
            };
            document.getElementById('expandAll').onclick = () => {
                root.children && root.children.forEach(expandAll);
                update(root);
                // update tracked index
                currentExpansionIndex = findMatchingStateIndex();
            };

            // State machine for one-level expand/collapse
            // We'll precompute a list of expansion "states" (sets of node keys that are expanded)
            // starting from root-only up to fully-expanded. Then collapse/expand one level
            // simply moves the current index and applies the corresponding state to the live tree.

            // Helper to get a stable key for a node: use the ancestor path (ids or names) so
            // keys are stable and unique across simulated and live hierarchies.
            function nodeKey(d) {
                // build path from root -> ... -> node using data.id if present, otherwise data.name
                try {
                    const parts = d.ancestors().reverse().map(n => (n.data && (n.data.id ?? n.data.name)) || '').filter(Boolean);
                    return parts.join('/');
                } catch (e) {
                    // fallback for nodes that don't support ancestors(): use name or id
                    return d.data?.id ?? d.data?.name ?? d.id ?? String(d);
                }
            }

            let expansionStates = []; // array of Set(nodeKey) from root-only (index 0) to fully-expanded (last)
            let currentExpansionIndex = 1; // default to first level beyond root

            // Build simulated collapse sequence from fully expanded down to root-only, then reverse it.
            function buildExpansionStatesFromData(rawData) {
                // Use a deep-cloned hierarchy so we don't touch the live `root`
                const simRoot = d3.hierarchy(JSON.parse(JSON.stringify(rawData)));

                function getExpandedKeys(n) {
                    return new Set(n.descendants().filter(d => d.children && d.children.length > 0).map(nodeKey));
                }

                const states = [];
                // Start with fully expanded state
                states.push(getExpandedKeys(simRoot));

                // Simulate repeated "collapse one level" operations until nothing left to collapse
                while (true) {
                    const candidates = simRoot.descendants().filter(d => d.children && d.children.length > 0);
                    if (candidates.length === 0) break;
                    const toCollapse = candidates.filter(d => d.children.every(c => !c.children || c.children.length === 0));
                    if (toCollapse.length === 0) break;
                    toCollapse.forEach(d => { d._children = d.children; d.children = null; });
                    states.push(getExpandedKeys(simRoot));
                }

                // states currently goes from fully-expanded -> ... -> root-only, reverse it
                return states.reverse();
            }

            // Apply an expansion state (set of node keys that should be expanded) to the live `root`
            function applyExpansionStateToLiveRoot(expandedSet) {
                root.descendants().forEach(d => {
                    const key = nodeKey(d);
                    if (expandedSet.has(key)) {
                        if (d._children) { d.children = d._children; d._children = null; }
                        // if it already has children do nothing
                    } else {
                        if (d.children) { d._children = d.children; d.children = null; }
                    }
                });
                update(root);
            }

            // Build expansion states from the original raw data
            expansionStates = buildExpansionStatesFromData(data);

            // Determine which state the current live root matches (so we can set the current index correctly)
            function findMatchingStateIndex() {
                const liveExpanded = new Set(root.descendants().filter(d => d.children && d.children.length > 0).map(nodeKey));
                if (!expansionStates || expansionStates.length === 0) return 0;
                if (expansionStates.length === 1) return 0;

                // Choose the state with the largest intersection with liveExpanded
                let bestIndex = 0;
                let bestScore = -1;
                for (let i = 0; i < expansionStates.length; i++) {
                    const s = expansionStates[i];
                    let common = 0;
                    s.forEach(k => { if (liveExpanded.has(k)) common++; });
                    if (common > bestScore) { bestScore = common; bestIndex = i; }
                }

                // If nothing matches (bestScore === 0), prefer the first-level state if it exists
                if (bestScore === 0 && expansionStates.length > 1) return Math.min(1, expansionStates.length - 1);
                return bestIndex;
            }

            currentExpansionIndex = findMatchingStateIndex();

            // COLLAPSE ONE LEVEL
            document.getElementById('collapseOneLevel').onclick = () => {
                if (expansionStates.length === 0) return;
                currentExpansionIndex = Math.max(0, currentExpansionIndex - 1);
                applyExpansionStateToLiveRoot(expansionStates[currentExpansionIndex]);
            };


            // // Collapse only visible nodes with children whose children are all leaves or collapsed
            // document.getElementById('collapseOneLevel').onclick = () => {
            //     // Find all visible nodes with children
            //     const candidates = root.descendants().filter(d => d.children && d.children.length > 0);
            //     // Only collapse those whose children are all leaves or already collapsed
            //     candidates.forEach(d => {
            //         const allChildrenAreLeavesOrCollapsed = d.children.every(
            //             c => !c.children || c.children.length === 0
            //         );
            //         if (allChildrenAreLeavesOrCollapsed) {
            //             collapse(d);
            //         }
            //     });
            //     update(root);
            // };

            // // Expand only hidden (collapsed) nodes whose hidden children are all leaves or collapsed
            // document.getElementById('expandOneLevel').onclick = () => {
            //     // Find all nodes that are currently collapsed (have _children)
            //     // const candidates = root.descendants().filter(d => d._children && d._children.length > 0);

            //     // Only expand those whose hidden children are all leaves or already collapsed
            //     candidates.forEach(d => {
            //         const allHiddenChildrenAreLeavesOrCollapsed = d._children.every(
            //             c => !c.children || c.children.length === 0
            //         );
            //         if (allHiddenChildrenAreLeavesOrCollapsed) {
            //             expand(d);  // assumes your expand(d) does: d.children = d._children; d._children = null;
            //         }
            //     });

            //     update(root);
            // };

            document.getElementById('expandOneLevel').onclick = () => {
                if (expansionStates.length === 0) return;
                currentExpansionIndex = Math.min(expansionStates.length - 1, currentExpansionIndex + 1);
                applyExpansionStateToLiveRoot(expansionStates[currentExpansionIndex]);
            };

            // By default, only root and first-level children are expanded
            update(root);
        }

        // Place helper at top-level scope so it's available everywhere
        // Ensure expand is defined at top-level scope before expandAllRecursive
        function collapse(d) {
            if (d.children) { d._children = d.children; d._children.forEach(collapse); d.children = null; }
        }
        function expand(d) {
            if (d._children) { d.children = d._children; d._children = null; }
        }
        function expandAllRecursive(d) {
            if (d._children) {
                expand(d);
                if (d.children) d.children.forEach(expandAllRecursive);
            } else if (d.children) {
                d.children.forEach(expandAllRecursive);
            }
        }

        init();

        // Dark mode toggle
        const darkModeToggle = document.getElementById('darkModeToggle');
        darkModeToggle.checked = true;
        document.body.classList.add('dark-mode');
        darkModeToggle.addEventListener('change', function () {
            document.body.classList.toggle('dark-mode', darkModeToggle.checked);
        });
    </script>

    <!-- ESV credit: Crossway recommended short credit for using ESV text -->
    <div class="esv-credit" aria-hidden="true">
        <div>Scripture quotations are from the ESV® Bible (The Holy Bible, English Standard Version®), copyright © 2001, 2007, 2011, 2016 by Crossway. Used by permission. All rights reserved.</div>
    <div>The "Minimal Facts" approach is adapted from: Gary R. Habermas and Michael R. Licona, <em>The Case for the Resurrection of Jesus</em> (B&amp;H Academic, 2004).</div>
    </div>

</body>

</html>