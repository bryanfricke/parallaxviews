<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <title>Minimal Facts Tree</title>
    <!-- Favicons: SVG primary with PNG fallbacks and webmanifest -->
    <!-- Use relative paths so files resolve correctly when hosted under a repo subpath (e.g. /parallaxviews) -->
    <link rel="icon" href="../favicon.svg" type="image/svg+xml">
    <link rel="icon" href="../favicon-32.png" sizes="32x32" type="image/png">
    <link rel="icon" href="../favicon-16.png" sizes="16x16" type="image/png">
    <link rel="apple-touch-icon" href="../apple-touch-icon.png" sizes="180x180">
    <link rel="manifest" href="../site.webmanifest">
    <link rel="mask-icon" href="../safari-pinned-tab.svg" color="#00BFAE">
    <meta name="theme-color" content="#00BFAE">
    <meta name="viewport"
        content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no" />
    <style>
        #topbar {
            display: flex;
            align-items: center;
            gap: 16px;
            padding: 8px 24px;
            background: var(--bg-light);
            border-bottom: 1px solid #e0e0e0;
            min-height: 48px;
            /* Prevent vertical panning when user swipes near controls on iOS: allow only horizontal pan */
            touch-action: pan-x;
            -webkit-user-select: none;
            user-select: none;
        }

        body.dark-mode #topbar {
            background: var(--bg-dark);
            border-bottom: 1px solid var(--link-dark);
        }

        #topbar label,
        #topbar button {
            margin: 0 4px;
        }

        #topbar label {
            font-weight: 500;
            color: inherit;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        /* Topbar buttons: subtle vertical (top-to-bottom) mint gradient to match nodes/checkbox.
           Light mode tint deepened for better contrast. */
        #topbar button {
            background: linear-gradient(180deg, #33cdbf 0%, #009f92 100%);
            color: #fff;
            border: none;
            border-radius: 6px;
            padding: 8px 14px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0, 159, 146, 0.16);
            transition: background 0.18s ease, box-shadow 0.18s ease, color 0.12s ease, transform 0.08s;
            position: relative; /* Ensure buttons maintain their position */
        }

        /* Hover / focus: slightly deeper mint and subtle lift */
        #topbar button:hover,
        #topbar button:focus {
            background: linear-gradient(180deg, #22bfae 0%, #007f6f 100%);
            color: #fff;
            box-shadow: 0 6px 18px rgba(0, 159, 146, 0.24);
        }

        /* Dark mode variant: tuned for dark backgrounds but keep the mint tint */
        body.dark-mode #topbar button {
            background: linear-gradient(180deg, #2bd1b0 0%, #007a67 100%);
            color: var(--text-dark);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.36);
        }

        body.dark-mode #topbar button:hover,
        body.dark-mode #topbar button:focus {
            background: linear-gradient(180deg, #35d8bd 0%, #00604f 100%);
            color: var(--text-dark);
            box-shadow: 0 6px 18px rgba(0, 0, 0, 0.44);
        }

        #topbar input[type="checkbox"] {
            accent-color: #00BFAE;
            width: 16px;
            height: 16px;
            margin-right: 4px;
        }

        body.dark-mode #topbar input[type="checkbox"] {
            accent-color: var(--accent-dark);
        }
        
        /* Special styles for Dark Mode toggle to ensure visibility */
        #darkModeToggle {
            width: 16px;
            height: 16px;
            margin-right: 6px;
            position: relative;
            flex-shrink: 0; /* Prevent checkbox from shrinking */
        }
        
        /* Specific styling for dark mode label */
        #darkModeLabel {
            display: flex;
            align-items: center;
            user-select: none;
            white-space: nowrap;
            font-weight: 500;
            height: 40px; /* Match the height of buttons */
            color: inherit;
        }
        
        /* Ensure dark mode toggle has consistent styling */
        #darkModeToggle {
            accent-color: #00BFAE;
            width: 16px;
            height: 16px;
            margin-right: 6px;
            position: relative;
            flex-shrink: 0;
        }
        
        body.dark-mode #darkModeToggle {
            accent-color: var(--accent-dark);
        }

        #topbar>* {
            margin-right: 8px;
        }

        #topbar>*:last-child {
            margin-right: 0;
        }

        /* Keep related control buttons adjacent when the controls wrap (mobile)
           Each pair will stay together and wrap as a unit. */
        .control-pair {
            display: inline-flex;
            gap: 8px;
            align-items: center;
            white-space: nowrap;
            /* prevent inner buttons from breaking onto separate lines */
        }

        /* Controls toggle icon: rotate when the toggle is opened (aria-expanded=true)
           Use inline-flex on the wrapper and inline-block+vertical-align on the SVG
           so the chevron sits vertically centered next to the text baseline. */
        #controlsToggle .controls-icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            margin-left: 8px;
            transition: transform 160ms ease;
            transform-origin: center;
            height: 1em;
            /* match the font-size to align with the label */
        }

        #controlsToggle[aria-expanded="true"] .controls-icon {
            transform: rotate(180deg);
        }

        /* SVG sizing/styling for the chevron icon */
        #controlsToggle .controls-icon svg {
            width: 0.88em;
            /* slightly under 1em to line up optically */
            height: 0.88em;
            display: inline-block;
            vertical-align: middle;
            fill: none;
            stroke: currentColor;
            stroke-width: 2.6;
            stroke-linecap: round;
            stroke-linejoin: round;
        }

        :root {
            --bg-light: #fff;
            --bg-dark: #181A20;
            --panel-dark: #23272F;
            /* Translucent panel backgrounds for floating UI */
            --panel-light-translucent: rgba(255, 255, 255, 0.72);
            --panel-dark-translucent: rgba(35, 39, 47, 0.58);
            --node-fill-dark: #263238;
            --node-stroke-dark: #00BFAE;
            --node-hover-fill-dark: #374151;
            --node-hover-stroke-dark: #00E6B2;
            --link-dark: #3B4252;
            --text-dark: #E0E7EF;
            --text-secondary-dark: #A0AEC0;
            --accent-dark: #00BFAE;
            --tooltip-bg-dark: #23272F;
            --tooltip-border-dark: #00BFAE;
            /* link accent (default = blue for light mode). Overridden in .dark-mode below */
            --link-accent: #0074d9;
            /* Safe area insets for notched devices */
            --safe-top: env(safe-area-inset-top, 0px);
            --safe-right: env(safe-area-inset-right, 0px);
            --safe-bottom: env(safe-area-inset-bottom, 0px);
            --safe-left: env(safe-area-inset-left, 0px);
        }

        body {
            margin: 0;
            font: 14px/1.4 system-ui, sans-serif;
            overflow: hidden;
            background: var(--bg-light);
            color: #222;
            transition: background 0.3s, color 0.3s;
        }

        body.dark-mode {
            background: var(--bg-dark);
            color: var(--text-dark);
            /* brighter teal for links in dark mode to improve contrast */
            --link-accent: #00E6B2;
            /* Slightly stronger translucency on dark for readability */
            --panel-dark-translucent: rgba(35, 39, 47, 0.78);
        }

        body.dark-mode #topbar {
            background: var(--bg-dark);
            border-bottom: 1px solid var(--link-dark);
            color: var(--text-dark);
        }

        #chart {
            width: 100vw;
            height: calc(100vh - 48px);
            overflow: hidden;
            background: var(--bg-light);
            margin-top: 48px; /* Add margin to account for fixed topbar */
        }

        body.dark-mode #chart {
            background: var(--bg-dark);
        }

        svg {
            width: 100%;
            height: 100%;
            display: block;
            background: transparent;
            touch-action: none;
            /* allow d3-zoom to handle gestures on mobile */
        }

        /* Small-screen adjustments */
        @media (max-width: 600px) {
            #topbar {
                /* keep items on one line; allow horizontal scroll if content exceeds width */
                flex-wrap: nowrap;
                gap: 8px;
                padding: 8px 12px;
                /* Reserve space for the fixed toggle using the runtime-updated var */
                padding-left: calc(var(--controls-reserve, 140px) + env(safe-area-inset-left, 0px));
                overflow-x: auto;
                /* allow horizontal scroll if too many controls */
                -webkit-overflow-scrolling: touch;
                /* Ensure top bar respects safe area insets on mobile */
                padding-top: calc(8px + env(safe-area-inset-top, 0px));
                justify-content: space-between;
            }
            
            /* On mobile, dark mode is now in controls panel, no special positioning needed */

            /* When the controls toggle is pinned fixed on small screens, reserve
               space on the left so it doesn't visually overlap other topbar items
               (iOS portrait frequently pins the toggle into the safe-area). */
            /* Reserve horizontal space for the fixed controls toggle by offsetting the
               first child (usually the page title). This avoids increasing the topbar's
               vertical size or forcing wrapped lines on narrow screens. */
            /* first-child margin removed; padding-left on #topbar now reserves space */
            #topbar button {
                min-width: 110px;
            }

            #topbar>* {
                margin-right: 8px;
            }

            #topbar strong {
                font-size: 16px;
            }

            #topbar button {
                padding: 8px 10px;
                font-size: 15px;
                min-height: 40px;
            }

            .tooltip,
            .popup-help {
                max-width: calc(100vw - 24px);
                font-size: 15px;
                padding: 10px;
            }

            .esv-credit {
                left: 8px;
                right: 8px;
                bottom: 8px;
                max-width: none;
                font-size: 12px;
            }

            /* hide the footer on small screens to avoid overlaying the chart and bottom-sheet */
            .esv-credit {
                display: none;
            }

            /* Controls toggle and bottom-sheet */
            /* make toggle fixed so it doesn't get scrolled/hidden on small screens */
            #controlsToggle {
                display: inline-block !important;
                position: fixed !important;
                left: 12px;
                top: calc(env(safe-area-inset-top, 0px) + 8px);
                z-index: 9000;
                /* Stop vertical gestures on the fixed toggle from causing the visual viewport to shift */
                touch-action: none;
                -webkit-user-select: none;
                user-select: none;
            }

            #controls {
                display: none;
                width: 100%;
            }

            #controls.open {
                display: flex;
                flex-wrap: wrap;
                gap: 8px;
                z-index: 6000; /* above #topbar (5000) so it isn't visually clipped */
            }

            /* Ensure the controls panel uses the panel/dark styling when in dark-mode
               so a JS fallback doesn't render an unexpected white box that hides content. */
            body.dark-mode #controls.open,
            body.dark-mode #controls[style] {
                /* Use translucent dark panel for see-through effect */
                background: var(--panel-dark-translucent);
                color: var(--text-dark);
                border: 1px solid rgba(255,255,255,0.06);
            }

            /* bottom-sheet styles use the base .bottom-sheet rules (theme-aware) */
            /* when JS positions the controls as fixed, improve scrolling and backdrop */
            #controls[style] {
                -webkit-overflow-scrolling: touch;
                scrollbar-width: thin;
                background-clip: padding-box;
                backdrop-filter: blur(10px) saturate(80%);
            }
        }

        /* On mobile devices, dark mode will be in the controls panel, so hide it from topbar */
        @media (max-width: 600px) {
            /* Dark mode toggle stays in controls panel on mobile - no changes needed */
        }
        
        /* Also apply the same backdrop effect for small-height landscape viewports
           (covers phones/tablets held in landscape where width may exceed 600px). */
        @media (orientation: landscape) and (max-height: 600px) {

            #controls[style],
            #controls.open {
                -webkit-overflow-scrolling: touch;
                scrollbar-width: thin;
                background-clip: padding-box;
                -webkit-backdrop-filter: blur(6px) saturate(80%);
                     /* when positioned as a floating panel allow horizontal panning only on the parent
                         to avoid accidental vertical browser chrome movement; internal scrolling is still allowed */
                     touch-action: pan-x;
                backdrop-filter: blur(6px) saturate(80%);
            }
            
            /* On iPhone-like landscape (short, touch devices), put Controls before 4+1 Facts
               to match portrait ordering. Desktop remains unchanged. */
            @media (pointer: coarse) {
                #topbar { flex-wrap: nowrap; }
                #controlsToggle { order: 0; }
                #factsAboutBtn { order: 1; }
            }
        }

        /* On small devices when in landscape, shift the controls toggle and reserve
           extra left padding so the fixed toggle/panel doesn't overlap the main
           topbar content or the rounded device chrome (helps on iPhone landscape). */
        @media (max-width: 600px) and (orientation: landscape) {
            #controlsToggle {
                left: 12px;
                /* base */
                transform: translateX(-56px);
                /* visual shift inward (left) */
            }

            /* increase reserved padding so the topbar content moves right and avoids overlap */
            :root {
                --controls-reserve: 220px;
            }
            
            /* Dark mode is in controls panel on mobile landscape, no special positioning needed */
        }

        /* hide the large page title on small screens (we show controls instead) */
        @media (max-width: 600px) {
            #topbar strong {
                display: none;
            }

            /* compact mobile controls panel will be positioned by JS to avoid overlapping the divider */
        }

        /* hide the page title on large screens per user request */
        @media (min-width: 601px) {
            #topbar strong {
                display: none;
            }
        }

        /* keep topbar above floating bottom-sheet; allow overflow so floating
           panels anchored to the toggle can escape the divider clipping seen
           on some mobile Safari zoom states. */
        #topbar {
            position: fixed;
            z-index: 5000;
            overflow: visible;
            top: 0;
            left: 0;
            right: 0;
            width: 100%;
        }

        /* Special positioning for larger screens */
        @media (min-width: 601px) {
            #topbar {
                display: flex;
                flex-wrap: nowrap;
                align-items: center;
                padding-right: calc(24px + env(safe-area-inset-right, 0px)); /* Ensure enough padding on the right for the dark mode toggle */
            }
            
            #controlsToggle {
                position: relative !important;
                left: auto !important;
                top: auto !important;
                transform: none !important;
            }
            
            /* Dark mode toggle will be in controls panel for desktop too */
        }

        /* Dark mode toggle is in controls panel for all screen sizes */
        #darkModeLabel {
            display: flex;
            align-items: center;
        }

        /* bottom-sheet base styles (works on all sizes but optimized for mobile) */
        .bottom-sheet {
            position: fixed;
            left: 0;
            right: 0;
            bottom: -100%;
            /* Default: light-panel style so it reads well on light pages
               and doesn't appear as a deep black in dark mode. Dark mode
               override below sets a softer panel color. */
            background: rgba(255, 255, 255, 0.98);
            color: #222;
            border-top-left-radius: 12px;
            border-top-right-radius: 12px;
            box-shadow: 0 -8px 24px rgba(0, 0, 0, 0.08);
            border: 1px solid rgba(0, 0, 0, 0.06);
            padding: 16px;
            z-index: 2500;
            transition: bottom 260ms ease;
            max-height: 70vh;
            overflow: auto;
        }

        /* Constrain typography inside the bottom-sheet so headings and body
           text do not appear oversized on mobile browsers (e.g. iPhone Safari).
           Provide a small, consistent title style for leaf popups. */
        .bottom-sheet .bottom-content {
            /* Prevent iOS Safari text-size-adjust (font boosting) inside the sheet
               and ensure consistent rendering across platforms. */
            -webkit-text-size-adjust: 100%;
            text-size-adjust: 100%;
            -webkit-font-smoothing: antialiased;
            font-size: 14px;
            line-height: 1.45;
            color: inherit;
        }

        .bottom-sheet .bottom-content .sheet-title {
            font-size: 16px;
            font-weight: 700;
            margin-bottom: 8px;
        }

        .bottom-sheet .bottom-content a {
            font-size: 14px;
        }

        /* Specific styles for leaf node popups (keeps non-leaf help unchanged) */
        .bottom-sheet .bottom-content .leaf-content {
            /* Force the leaf body to a consistent, readable size and prevent
               browser text-size adjustments from enlarging it unexpectedly. */
            font-size: 14px !important;
            line-height: 1.45 !important;
            color: inherit;
        }

        .bottom-sheet .bottom-content .leaf-content .leaf-date {
            margin-top: 6px;
            font-weight: 700;
            font-size: 14px !important;
        }

        .bottom-sheet .bottom-content .leaf-content .leaf-details {
            margin-top: 8px;
            font-size: 14px !important;
        }

        .bottom-sheet .bottom-content .leaf-content .leaf-link {
            margin-top: 10px;
            font-size: 14px !important;
        }

        /* Reserve horizontal space only for the first block (usually the heading)
           so the close button won't overlap the first line or two. Subsequent
           paragraphs keep the normal left-aligned width. */
        .bottom-sheet .bottom-content>*:first-child {
            padding-right: 56px;
            /* button width (32) + gap */
        }

        @media (max-width: 420px) {
            .bottom-sheet .bottom-content>*:first-child {
                padding-right: 48px;
            }
        }

        /* Dark-mode variant: use a muted panel color instead of pure black */
        body.dark-mode .bottom-sheet {
            background: var(--panel-dark);
            color: var(--text-dark);
            border: 1px solid rgba(255, 255, 255, 0.04);
            box-shadow: 0 -8px 24px rgba(0, 0, 0, 0.32);
        }

        .bottom-sheet.open {
            bottom: 0;
        }

        .bottom-sheet .close-btn {
            /* nudge the control slightly outside the rounded sheet so it doesn't overlap
               the first lines of content while remaining visually attached */
            position: absolute;
            /* place the button fully inside the rounded sheet so it won't be clipped
                    by the sheet's scrolling/overflow; keeps a comfortable inset from edges */
            right: 12px;
            top: 12px;
            /* light-mode: rounded, subtle light-gray circle with centered X */
            width: 32px;
            height: 32px;
            padding: 0;
            background: rgba(0, 0, 0, 0.035);
            border: 1px solid rgba(0, 0, 0, 0.06);
            color: rgba(0, 0, 0, 0.65);
            /* slightly smaller font and zero line-height helps the glyph sit visually centered
                    across browsers and fonts (fixes vertical centering issues with the × character) */
            font-size: 18px;
            font-weight: 700;
            line-height: 0;
            border-radius: 999px;
            /* fully round */
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.06), inset 0 1px 0 rgba(255, 255, 255, 0.7);
            z-index: 2600;
            /* ensure button appears above sheet content */
        }

        /* Dark-mode variant for the close button */
        body.dark-mode .bottom-sheet .close-btn {
            background: rgba(255, 255, 255, 0.04);
            color: var(--text-dark);
            border: 1px solid rgba(255, 255, 255, 0.06);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.24), inset 0 1px 0 rgba(255, 255, 255, 0.02);
        }

        .bottom-sheet .close-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.08), inset 0 1px 0 rgba(255, 255, 255, 0.7);
        }

        .bottom-sheet .close-btn:focus {
            outline: 2px solid rgba(0, 116, 217, 0.12);
            outline-offset: 2px;
        }

        /* Remove the iOS blue focus ring / highlight for the close button in the bottom sheet.
           Keep this narrowly scoped to the close button since focus rings are useful elsewhere
           for keyboard users. On touch devices the blue ring is visual noise. */
        .bottom-sheet .close-btn {
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            -webkit-tap-highlight-color: transparent;
        }

        /* Keep tappable appearance but do not show an additional glow on focus */
        .bottom-sheet .close-btn:focus {
            outline: none;
            box-shadow: none;
        }

        /* Simple modal for the Minimal Facts background */
        .modal-backdrop {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.5);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            padding: 24px;
            /* ensure the backdrop uses the visual viewport when available to avoid
               being covered by iOS browser chrome; padding keeps a gap from edges */
        }

        .modal-backdrop.open {
            display: flex;
        }

        .modal-content {
            background: var(--bg-light);
            color: inherit;
            max-width: 820px;
            width: 100%;
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.32);
            /* keep symmetric side padding; don't reserve extra width for the close button */
            padding: 26px 20px 18px 20px;
            position: relative;
            /* Allow the modal body to scroll when its content exceeds the available
                    vertical space (important on iOS where browser chrome reduces viewport).
                    Use safe-area insets to avoid overlapping the notch / dynamic island. */
            overflow: auto;
            -webkit-overflow-scrolling: touch;
            box-sizing: border-box;
            /* Provide a reasonable max-height to keep the modal readable on phones;
                    use viewport-relative sizing with safe-area inset fallbacks. */
            max-height: calc(100vh - 96px);
        }

        body.dark-mode .modal-content {
            background: var(--panel-dark);
            color: var(--text-dark);
        }

          .modal-content h2 {
                /* Push the heading far enough down to clear the close button without
                    shrinking the text column width. This avoids the need for a large
                    right-side padding just to make room for the control. */
                margin-top: 32px;
            font-size: 18px;
        }

        .modal-content p {
            margin: 8px 0;
        }

        /* Reduce modal body typography in landscape on phones/tablets so text
           doesn't appear oversized compared with the title. Keeps the h2 size. */
        @media (orientation: landscape) and (max-height: 700px) {
            .modal-content {
                /* keep symmetric padding in landscape as well */
                padding: 22px 14px 12px 14px;
                max-height: calc(100vh - 56px);
            }

            .modal-content .modal-body,
            .modal-content .modal-body p,
            .modal-content .modal-body li,
            .modal-content .modal-body ol,
            .modal-content .modal-body ul {
                font-size: 13px;
                line-height: 1.35;
            }

            .modal-content .modal-body .sheet-title {
                font-size: 15px;
            }
            /* Keep the title clear of the close button in tight landscape view */
            .modal-content h2 { margin-top: 30px; }
        }

        /* Make modal close match the bottom-sheet close button */
        .modal-close {
            position: absolute;
            right: 12px;
            top: 12px;
            width: 32px;
            height: 32px;
            aspect-ratio: 1 / 1;
            box-sizing: border-box;
            padding: 0;
            background: rgba(0, 0, 0, 0.035);
            border: 1px solid rgba(0, 0, 0, 0.06);
            color: rgba(0, 0, 0, 0.65);
            font-size: 18px;
            font-weight: 700;
            line-height: 0;
            border-radius: 999px; /* fully round */
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.06), inset 0 1px 0 rgba(255, 255, 255, 0.7);
            z-index: 2600;
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            -webkit-tap-highlight-color: transparent;
        }

        /* stronger, high-contrast info icon used inside modal text */
        .modal-body .info-icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            margin-right: 12px;
            vertical-align: middle;
            flex: 0 0 24px;
            /* Use the accent color as the SVG's currentColor so the outer circle
               fills with the accent and the inner glyph stays white. */
            color: var(--link-accent);
            background: transparent;
            box-shadow: none;
            border: none;
        }

        /* ensure icon contrasts in dark mode as well (uses same accent variable)
           but provide a subtle outline to improve separation on very dark panels */
        body.dark-mode .modal-body .info-icon {
            color: var(--link-accent);
            background: transparent;
            box-shadow: none;
            border: none;
        }

        body.dark-mode .modal-close {
            background: rgba(255, 255, 255, 0.04);
            color: var(--text-dark);
            border: 1px solid rgba(255, 255, 255, 0.06);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.24), inset 0 1px 0 rgba(255, 255, 255, 0.02);
        }

        /* accessible focus state for the modal close button */
        .modal-close:focus {
            outline: 2px solid rgba(0, 116, 217, 0.12);
            outline-offset: 2px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.12);
        }

    /* Container already reserves right padding; avoid per-child padding to keep the close button circular */

        .link {
            fill: none;
            stroke: #ccc;
            stroke-width: 1.5px;
        }

        body.dark-mode .link {
            stroke: var(--link-dark);
        }

        .node circle {
            r: 5;
            cursor: pointer;
            stroke: #333;
            stroke-width: 1px;
            fill: #fff;
            transition: fill 0.2s, stroke 0.2s;
        }

        .node circle {
            fill: #e0f7fa;
            stroke: #00796b;
        }

        body.dark-mode .node circle {
            fill: var(--node-fill-dark);
            stroke: var(--node-stroke-dark);
        }

        .node:hover circle {
            fill: #b2ebf2;
            stroke: #004d40;
        }

        body.dark-mode .node:hover circle {
            fill: var(--node-hover-fill-dark);
            stroke: var(--node-hover-stroke-dark);
        }

        .node text {
            font-size: 12px;
            dominant-baseline: middle;
            paint-order: stroke;
            stroke: #fff;
            stroke-width: 4px;
            stroke-linejoin: round;
        }

        .node text tspan {
            paint-order: stroke;
            stroke: #fff;
            stroke-width: 4px;
            stroke-linejoin: round;
        }

        .node text .label {
            fill: #222;
            stroke: none;
        }

        body.dark-mode .node text {
            fill: var(--text-dark) !important;
            stroke: var(--bg-dark) !important;
        }

        body.dark-mode .node text .label {
            fill: var(--text-dark) !important;
            stroke: none !important;
        }

        .tooltip {
            position: fixed;
            pointer-events: auto;
            background: #fff;
            border: 1px solid #ddd;
            padding: 8px 10px;
            border-radius: 6px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, .08);
            max-width: 320px;
            font-size: 13px;
            z-index: 1000;
        }

        .popup-help {
            position: fixed;
            pointer-events: auto;
            background: #fff;
            border: 1px solid #ddd;
            padding: 8px 10px;
            border-radius: 6px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, .08);
            max-width: 320px;
            font-size: 13px;
            z-index: 1001;
        }

        body.dark-mode .tooltip,
        body.dark-mode .popup-help {
            background: var(--tooltip-bg-dark) !important;
            border: 1px solid var(--tooltip-border-dark) !important;
            color: var(--text-dark) !important;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.32) !important;
        }

        /* Tooltip / popup links: use the shared --link-accent variable so we can
           tune contrast separately for light vs dark modes. Keep underline for affordance. */
        .tooltip a,
        .popup-help a {
            color: var(--link-accent) !important;
            text-decoration: underline;
        }

        .tooltip a:hover,
        .popup-help a:hover {
            /* slightly stronger on hover; still derived from the accent variable where appropriate */
            color: var(--node-hover-stroke-dark) !important;
        }

        /* Modal links should use the shared link accent so they look correct in dark mode */
        .modal-content a {
            color: var(--link-accent) !important;
            text-decoration: underline;
        }

        .modal-content a:hover {
            opacity: 0.92;
        }

        body.dark-mode .modal-content a {
            color: var(--link-accent) !important;
        }

        .node.clickable text {
            fill: #0074d9;
            cursor: pointer;
            text-decoration: none;
        }

        .node.clickable:hover text {
            fill: #005fa3;
            text-decoration: none;
        }

        /* stronger visual ring for selected node (set via data-selected attribute) */
        g.node[data-selected="true"] circle {
            /* default (dark-mode friendly) selection ring */
            stroke: #00E6B2 !important;
            stroke-width: 2.6px !important;
            transition: stroke 180ms, stroke-width 180ms;
        }

        /* subtle halo around selected node group to increase contrast without changing fill (dark-mode) */
        g.node[data-selected="true"] {
            filter: drop-shadow(0 6px 10px rgba(0, 230, 178, 0.06));
        }

        /* Light-mode specific selection styling: use a slightly darker, high-contrast ring
           and a faint cool-blue halo so the ring reads well on a white background. */
        body:not(.dark-mode) g.node[data-selected="true"] circle {
            stroke: #0074d9 !important;
            /* blue that matches other light-mode accents */
            stroke-width: 2.6px !important;
            transition: stroke 180ms, stroke-width 180ms;
        }

        body:not(.dark-mode) g.node[data-selected="true"] {
            filter: drop-shadow(0 6px 10px rgba(0, 116, 217, 0.06));
        }

        /* ESV credit footnote (small, unobtrusive, respects dark mode) */
        .esv-credit {
            position: fixed;
            left: 12px;
            bottom: 8px;
            z-index: 2000;
            font-size: 12px;
            line-height: 1.2;
            padding: 6px 8px;
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.92);
            color: #333;
            border: 1px solid #e6e6e6;
            opacity: 0.95;
            pointer-events: none;
            max-width: calc(100vw - 40px);
        }

        body.dark-mode .esv-credit {
            background: rgba(24, 26, 32, 0.7);
            color: var(--text-secondary-dark);
            border: 1px solid rgba(255, 255, 255, 0.04);
        }
    </style>
</head>

<body class="dark-mode">
    <div id="topbar">
        <strong style="font-size:18px; letter-spacing:0.5px; margin-right:16px;">Tidy Tree</strong>
        <button id="factsAboutBtn" aria-haspopup="dialog">4+1 Facts</button>
        <button id="controlsToggle" aria-expanded="false">Controls <span class="controls-icon" aria-hidden="true"><svg
                    viewBox="0 0 24 24" focusable="false" aria-hidden="true">
                    <path d="M6 9l6 6 6-6"></path>
                </svg></span></button>
        <div id="controls" style="display:flex; align-items:center; gap:12px;">
            <label style="display:none;"><input type="checkbox" id="wrap"> Wrap labels</label>
            <label><input type="checkbox" id="clusterToggle"> Cluster layout</label>
            <label style="display:none;">Node size: <input type="range" id="nodesize" min="10" max="100"
                    value="20"></label>
            <label style="display:none;">Vertical spacing: <input type="range" id="nodesizeY" min="10" max="150"
                    value="60"></label>
            <label style="display:none;">Horizontal spacing: <input type="range" id="nodesizeX" min="10" max="300"
                    value="180"></label>
            <div class="control-pair">
                <button id="collapseAll">Collapse All</button>
                <button id="expandAll">Expand All</button>
            </div>
            <div class="control-pair">
                <button id="collapseOneLevel">Collapse One Level</button>
                <button id="expandOneLevel">Expand One Level</button>
            </div>
            <label id="darkModeLabel" for="darkModeToggle"><input type="checkbox" id="darkModeToggle"> Dark mode</label>
        </div>
    </div>
    <div id="chart"></div>

    <!-- bottom sheet for mobile node details -->
    <div id="bottomSheet" class="bottom-sheet" role="dialog" aria-hidden="true"></div>

    <!-- modal backdrop for Minimal Facts background -->
    <div id="factsModal" class="modal-backdrop" role="dialog" aria-hidden="true" aria-modal="true"
        aria-labelledby="factsModalTitle">
        <div class="modal-content" tabindex="-1" role="document">
            <button class="modal-close" aria-label="Close">×</button>
            <h2 id="factsModalTitle">The "Minimal Facts" (4 + 1)</h2>
            <div class="modal-body">
                <p>The “Minimal Facts” approach, developed by Gary Habermas and expanded with Michael Licona in <em>The
                        Case for the Resurrection of Jesus</em>, identifies a handful of historical claims about Jesus
                    that meet two criteria:</p>
                <ul>
                    <li>They are supported by strong historical evidence.</li>
                    <li>They are accepted by the majority of scholars writing on the subject, including many who are not
                        Christians.</li>
                </ul>
                <p>The standard list is:</p>
                <ol>
                    <li><strong>Jesus died by crucifixion.</strong><br>Jesus of Nazareth was executed under the Roman
                        governor Pontius Pilate.</li>
                    <li><strong>Jesus’ disciples believed that he rose and appeared to them.</strong><br>They were
                        convinced they had real post-mortem encounters with him.</li>
                    <li><strong>The church persecutor Paul was suddenly changed.</strong><br>Saul of Tarsus, once an
                        enemy of the early Christian movement, became its leading missionary after what he described as
                        a resurrection appearance.</li>
                    <li><strong>The skeptic James, the brother of Jesus, was suddenly changed.</strong><br>Initially an
                        unbeliever, James became the leader of the Jerusalem church following what he took to be an
                        encounter with the risen Jesus.</li>
                    <li><strong>The empty tomb (the “+1”).</strong><br>Many scholars accept that Jesus’ tomb was found
                        empty by women followers, though this point is debated more than the four above.</li>
                </ol>
                <p><em>There is broad scholarly agreement on these core facts. The resurrection of Jesus best explains
                        them, as competing theories such as hallucination or conspiracy quickly collapse under scrutiny.
                        Objections usually arise not from the evidence itself but from worldview assumptions that rule
                        out the possibility of God and miracles in advance.</em></p>

                <!-- Callout as a P (not div) to satisfy strict modal-body selectors -->
                <p class="callout"
                    style="margin:12px 0; padding:10px; background:rgba(0,0,0,0.04); border-left:4px solid #666; font-size:14px;">
                    <strong>How this site helps:</strong> This website lets readers explore the supporting
                    evidence directly. By clicking through an interactive tree structure, users can locate early sources
                    that testify to the death, burial, and resurrection of Jesus. The layout reflects the approach in
                    <em>The Case for the Resurrection of Jesus</em>, with some additions — for example, sources cited
                    for
                    the burial connect naturally to the resurrection claims, which themselves imply the discovery of the
                    empty tomb.
                </p>

                <hr style="margin-top:12px; margin-bottom:12px; border:none; border-top:1px solid rgba(0,0,0,0.06);">
                <div class="modal-credit" style="font-size:13px; color:inherit;">
                    <div>Scripture quotations are from the ESV® Bible (The Holy Bible, English Standard Version®),
                        copyright © 2001, 2007, 2011, 2016 by Crossway. Used by permission. All rights reserved.</div>
                    <div style="margin-top:6px;">The "Minimal Facts" approach is adapted from: Gary R. Habermas and
                        Michael R. Licona, <em><a
                                href="https://en.wikipedia.org/wiki/The_Case_for_the_Resurrection_of_Jesus"
                                target="_blank" rel="noopener">The Case for the Resurrection of Jesus</a></em> (B&amp;H
                        Academic, 2004).
                    </div>
                    <div style="margin-top:6px;">
                        Development note: Large Language Models (principally ChatGPT) and GitHub Copilot were used to
                        assist
                        in the development of text and code for this site.
                    </div>
                </div>
            </div>
        </div>

    </div>

    <!-- D3 v7 -->
    <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
    <script>
        async function init() {
            let response = await fetch('data/ResurrectionDisciplesBelievedItActs01.json');
            let data = await response.json();

            // === 2) Basic settings ===
            const container = document.getElementById('chart');
            let width = container.clientWidth;
            let height = container.clientHeight;

            // Compute chart height based on topbar height so content isn't hidden under it on small screens
            function computeChartHeight() {
                const topbar = document.getElementById('topbar');
                const rect = topbar ? topbar.getBoundingClientRect() : { height: 48 };
                const hh = Math.max(48, rect.height);
                const chartEl = document.getElementById('chart');
                
                // For mobile screens, keep the chart below the topbar
                chartEl.style.height = `calc(100vh - ${hh}px)`;
                chartEl.style.marginTop = `${hh}px`; // Adjust margin to account for fixed topbar
                
                // On larger screens, make sure topbar doesn't exceed reasonable height
                if (window.innerWidth > 600) {
                    topbar.style.maxHeight = '60px'; // Prevent excessive height on desktop
                }
                
                width = chartEl.clientWidth;
                height = chartEl.clientHeight;
                svg.attr('width', width).attr('height', height)
                    .on('end interrupt', () => { try { revealHoverAtPointer(); } catch (e) { } });
            }

            // Create bottom-sheet element for mobile node details
            const bottomSheet = document.getElementById('bottomSheet');
            // Helper: use visualViewport when available so we position stuff relative
            // to the *visible* viewport (this fixes Safari on iOS where the
            // bottom URL/search bar reduces the visual viewport height).
            function getViewportRect() {
                if (window.visualViewport) {
                    return {
                        top: window.visualViewport.offsetTop || 0,
                        left: window.visualViewport.offsetLeft || 0,
                        width: window.visualViewport.width,
                        height: window.visualViewport.height
                    };
                }
                return { top: 0, left: 0, width: window.innerWidth, height: window.innerHeight };
            }

            // Return the desired center in screen coordinates for the visible portion
            // of the chart area. This uses the intersection between the chart's
            // bounding rect and the visual viewport so iOS Safari's bottom URL
            // sheet / chrome is correctly accounted for.
            function getDesiredScreenCenter() {
                const chartRect = container.getBoundingClientRect();
                const vp = getViewportRect();
                // Compute horizontal center clamped to chart area
                const centerX = chartRect.left + (chartRect.width / 2);

                // Compute the visible vertical span of the chart within the visual viewport
                const visibleTop = Math.max(chartRect.top, vp.top);
                // If the bottom sheet is open, reduce the visible bottom by its height so
                // centering keeps nodes above the sheet. Also keep a small margin.
                const sheetHeight = (typeof bottomSheet !== 'undefined' && bottomSheet && bottomSheet.classList.contains('open')) ? (bottomSheet.getBoundingClientRect().height || 0) : 0;
                const margin = 12;
                const visibleBottom = Math.min(chartRect.bottom, vp.top + vp.height - sheetHeight - margin);
                let visibleHeight = visibleBottom - visibleTop;
                if (visibleHeight <= 0) {
                    // fallback to visual viewport center if there's no overlap
                    return { centerX, centerY: vp.top + (vp.height / 2) };
                }
                // Apply a small upward bias on small screens so the focused node sits
                // comfortably above mobile chrome (URL bar / bottom sheet).
                const isSmall = isMobileLike();
                const upwardBias = isSmall ? 24 : 0; // px
                let centerY = visibleTop + (visibleHeight / 2) - upwardBias;
                // Clamp into the visible area
                const minY = vp.top + 8;
                const maxY = vp.top + vp.height - 8;
                centerY = Math.min(Math.max(centerY, minY), maxY);
                return { centerX, centerY };
            }

            // Improved mobile detection helper:
            // Treat a device as "mobile-like" if it matches the small-width media
            // query OR if it has a coarse pointer (touch) and the visual viewport's
            // smaller dimension is phone-sized. This handles iPhone landscape where
            // the width can be >600px but the device is still a phone and should
            // use mobile behaviors (bottom-sheet tooltips).
            function isMobileLike() {
                try {
                    const smallWidth = (window.matchMedia && window.matchMedia('(max-width: 600px)').matches);
                    const coarsePointer = (window.matchMedia && window.matchMedia('(pointer: coarse)').matches) || (navigator.maxTouchPoints && navigator.maxTouchPoints > 0);
                    const vp = getViewportRect();
                    const smallerDim = Math.min(vp.width || window.innerWidth, vp.height || window.innerHeight);
                    // treat as mobile-like when either smallWidth, or a touch device with
                    // a phone-sized smaller dimension (conservative threshold)
                    return smallWidth || (coarsePointer && smallerDim < 520);
                } catch (e) {
                    return (window.matchMedia && window.matchMedia('(max-width: 600px)').matches);
                }
            }
            // Fraction of horizontal width to bias centering toward the right on mobile
            // Increase this to move the tree slightly to the right so left-most labels
            // remain visible on small/tall viewports (tuned empirically).
            const MOBILE_BIAS_FRAC = 0.18;
            function openBottomSheet(html, node) {
                // Prevent subtitle-only hover opens from overwriting a full "sheet-title" view.
                // If the sheet is already open and currently showing a .sheet-title, and the
                // incoming html does not include a .sheet-title, keep the existing content.
                try {
                    const incomingHasTitle = (typeof html === 'string') && html.indexOf('sheet-title') !== -1;
                    const existingHasTitle = bottomSheet && bottomSheet.classList.contains('open') && bottomSheet.querySelector && bottomSheet.querySelector('.bottom-content .sheet-title');
                    if (existingHasTitle && !incomingHasTitle) {
                        // preserve existing full-content sheet (do not override with subtitle-only)
                        return;
                    }
                } catch (e) { /* non-fatal */ }
                // hide other transient UI
                tooltip.style('opacity', 0);
                popupHelp.style('opacity', 0).style('pointer-events', 'none');
                bottomSheet.innerHTML = `<button class="close-btn" aria-label="Close">×</button><div class="bottom-content">${html}</div>`;
                bottomSheet.classList.add('open');
                bottomSheet.setAttribute('aria-hidden', 'false');

                // Ensure the first block of content doesn't sit underneath the close button
                // Only add padding when the first block is short (one or two lines).
                function adjustSheetHeaderPadding() {
                    try {
                        const btn = bottomSheet.querySelector('.close-btn');
                        const content = bottomSheet.querySelector('.bottom-content');
                        if (!content) return;
                        // find first element child inside bottom-content, fallback to content itself
                        let first = Array.from(content.childNodes).find(n => n.nodeType === 1);
                        if (!first) first = content;
                        // reset prior padding so measurement is accurate
                        first.style.paddingRight = '';
                        // measure and decide
                        const rect = first.getBoundingClientRect();
                        const lineHeight = parseFloat(window.getComputedStyle(first).lineHeight) || 18;
                        // treat 'short' as up to two lines tall
                        if (rect.height <= (lineHeight * 2.2) && btn) {
                            const gap = 12; // px spacing between text and button
                            const pad = (btn.offsetWidth || 32) + gap;
                            first.style.paddingRight = pad + 'px';
                        }
                    } catch (e) { /* non-fatal */ }
                }
                // Run once now, and re-run on a short delay to allow rendering/styling to settle
                setTimeout(adjustSheetHeaderPadding, 40);
                setTimeout(adjustSheetHeaderPadding, 280);
                // If the window resizes while sheet is open, recompute
                const resizeHandlerForSheet = () => { if (bottomSheet.classList.contains('open')) adjustSheetHeaderPadding(); };
                __sheetResizeHandler = resizeHandlerForSheet;
                window.addEventListener('resize', resizeHandlerForSheet);
                // After the sheet is open, ensure the clicked node isn't obscured on small screens.
                const isSmall = isMobileLike();
                setTimeout(() => {
                    // scrollIntoView as before to bring sheet into view
                    bottomSheet.scrollIntoView({ behavior: 'smooth', block: 'end' });

                    // If a node was provided and we're on a small screen, check if it will be
                    // covered by the sheet. If so, pan the svg up so the node sits above the sheet.
                    if (isSmall && node && svg && typeof d3 !== 'undefined') {
                        try {
                            const sheetRect = bottomSheet.getBoundingClientRect();
                            const margin = 12; // spacing above sheet
                            // Compute node screen coords (similar to updatePopupHelpPosition)
                            const transform = d3.zoomTransform(svg.node());
                            const transformed = transform.apply([node.y, node.x]);
                            const point = svg.node().createSVGPoint();
                            point.x = transformed[0];
                            point.y = transformed[1];
                            const ctm = svg.node().getScreenCTM();
                            if (ctm) {
                                const screenPoint = point.matrixTransform(ctm);
                                const nodeScreenY = screenPoint.y;
                                const vp = getViewportRect();
                                const availableTop = vp.top + vp.height - sheetRect.height - margin;
                                if (nodeScreenY > availableTop) {
                                    const dy = availableTop - nodeScreenY; // negative value will move content up
                                    const newTransform = d3.zoomIdentity.translate(transform.x, transform.y + dy).scale(transform.k);
                                    svg.interrupt();
                                    hideTransientUI();
                                    svg.transition().duration(320).call(zoom.transform, newTransform)
                                        .on('end interrupt', () => { try { revealHoverAtPointer(); } catch (e) { } });
                                }
                            }
                        } catch (e) {
                            console.warn('openBottomSheet: failed to reposition for node visibility', e);
                        }
                    }

                    const btn = bottomSheet.querySelector('.close-btn');
                    if (btn) { btn.focus({ preventScroll: true }); btn.addEventListener('click', closeBottomSheet, { once: true }); }
                }, 60);
            }
            // keep a reference to the resize handler so we can remove it when closing
            let __sheetResizeHandler = null;
            function closeBottomSheet() {
                bottomSheet.classList.remove('open');
                bottomSheet.setAttribute('aria-hidden', 'true');
                try {
                    // clear any padding we added to the first element
                    const content = bottomSheet.querySelector('.bottom-content');
                    if (content) {
                        const first = Array.from(content.childNodes).find(n => n.nodeType === 1);
                        if (first) first.style.paddingRight = '';
                    }
                    if (__sheetResizeHandler) {
                        window.removeEventListener('resize', __sheetResizeHandler);
                        __sheetResizeHandler = null;
                    }
                } catch (e) { /* non-fatal */ }
            }
            bottomSheet.addEventListener('click', (e) => {
                // allow clicking outside content to close if needed; a close button could be added
                if (e.target === bottomSheet) closeBottomSheet();
            });

            // Controls toggle for small screens
            const controlsToggle = document.getElementById('controlsToggle');
            const controls = document.getElementById('controls');
            function updateControlsVisibility() {
                const isSmall = isMobileLike();
                // rely on CSS for toggle visibility to avoid inline style flashing
                if (!isSmall) { controls.classList.add('open'); controls.style.display = 'flex'; }
                else { controls.classList.remove('open'); controls.style.display = 'none'; }
                // Ensure the toggle's aria-expanded reflects the actual state so the
                // chevron icon rotates correctly (desktop shows controls by default).
                try {
                    controlsToggle.setAttribute('aria-expanded', !isSmall ? 'true' : 'false');
                } catch (e) { /* non-fatal */ }
            }
            // Apply small, conservative UI tweaks for mobile-like devices so controls and footer
            // don't overlap the chart. Pin the toggle only on portrait mobile devices.
            function applyMobileLikeUI() {
                try {
                    const mobile = isMobileLike();
                    const isPortrait = (window.visualViewport ? (window.visualViewport.height > window.visualViewport.width) : (window.innerHeight > window.innerWidth));
                    // hide footer credit on mobile-like screens to avoid covering content
                    const esv = document.querySelector('.esv-credit');
                    if (esv) esv.style.display = mobile ? 'none' : '';

                    // ensure controls toggle is reachable: pin it to safe area on portrait mobile
                    const ctrl = document.getElementById('controlsToggle');
                    if (!ctrl) return;
                    if (mobile && isPortrait) {
                        ctrl.style.display = 'inline-block';
                        ctrl.style.position = 'fixed';
                        ctrl.style.left = '12px';
                        // vertical position will be computed and centered
                        positionControlsToggle();
                        ctrl.style.zIndex = 9000;
                    } else {
                        // reset inline positioning
                        ctrl.style.position = '';
                        ctrl.style.left = '';
                        ctrl.style.top = '';
                        ctrl.style.zIndex = '';
                        ctrl.style.display = '';
                    }
                } catch (e) { /* non-fatal */ }
            }
            // Position the fixed controls toggle vertically centered to the topbar
            function positionControlsToggle() {
                try {
                    const btn = document.getElementById('controlsToggle');
                    const topbar = document.getElementById('topbar');
                    if (!btn || !topbar) return;
                    // measure and compute centered top relative to viewport
                    const tbRect = topbar.getBoundingClientRect();
                    const btnRect = btn.getBoundingClientRect();
                    // center within topbar
                    const centeredTop = tbRect.top + Math.max(0, (tbRect.height - btnRect.height) / 2);
                    // ensure the value is within the visual viewport if available
                    const vpOffset = (window.visualViewport && window.visualViewport.offsetTop) ? window.visualViewport.offsetTop : 0;
                    const finalTop = Math.max(centeredTop, vpOffset + 6);
                    btn.style.top = finalTop + 'px';
                } catch (e) { /* non-fatal */ }
            }
            // Compute and set the CSS variable that reserves space for the fixed toggle.
            function updateControlsReserve() {
                try {
                    const root = document.documentElement;
                    const btn = document.getElementById('controlsToggle');
                    if (!btn) {
                        root.style.removeProperty('--controls-reserve');
                        return;
                    }
                    // Measure the rendered width and include horizontal margins via computed style.
                    const rect = btn.getBoundingClientRect();
                    const cs = window.getComputedStyle(btn);
                    const marginLeft = parseFloat(cs.marginLeft) || 0;
                    const marginRight = parseFloat(cs.marginRight) || 0;
                    // Add a slightly larger safety gap to avoid overlap on devices with shadow/blur
                    const safety = 28;
                    const reserve = Math.ceil(rect.width + marginLeft + marginRight + safety);
                    root.style.setProperty('--controls-reserve', reserve + 'px');
                } catch (e) { /* non-fatal */ }
            }

            // Update reserve on relevant events
            window.addEventListener('resize', updateControlsReserve);
            window.addEventListener('orientationchange', updateControlsReserve);
            window.addEventListener('resize', positionControlsToggle);
            window.addEventListener('orientationchange', positionControlsToggle);
            // Also re-run mobile UI adjustments when orientation/size changes
            window.addEventListener('resize', applyMobileLikeUI);
            window.addEventListener('orientationchange', applyMobileLikeUI);
            // call initially after a short delay to ensure styles computed
            setTimeout(updateControlsReserve, 220);
            controlsToggle.addEventListener('click', () => {
                const open = controls.classList.toggle('open');
                controls.style.display = open ? 'flex' : 'none';
                controlsToggle.setAttribute('aria-expanded', open ? 'true' : 'false');
                // position controls right below topbar on small screens
                const isSmall = isMobileLike();
                if (isSmall && open) {
                    // anchor the panel to the controls toggle so it appears directly under the button
                    const toggleRect = controlsToggle.getBoundingClientRect();
                    controls.style.position = 'fixed';
                    // Compute base left from the toggle. On small devices in landscape
                    // the toggle may sit near the left edge or under UI chrome — add a
                    // small extra offset in that case so the panel doesn't collide with
                    // the rounded viewport edges / browser chrome (iPhone notch/home).
                    let leftPos = Math.max(8, toggleRect.left);
                    try {
                        if (window.matchMedia && window.matchMedia('(orientation: landscape)').matches) {
                            // shift slightly to the right in landscape on small screens
                            leftPos -= 64; // tuned empirically; conservative value
                        }
                    } catch (e) { /* non-fatal */ }
                    controls.style.left = leftPos + 'px';
                    controls.style.top = (toggleRect.bottom + 6) + 'px';
                    // Translucent, blurred floating panel with subtle accent gradient
                    controls.style.background = 'linear-gradient(90deg, rgba(0,191,174,0.08), rgba(0,116,217,0.08)), var(--panel-light-translucent)';
                    controls.style.padding = '8px';
                    controls.style.borderRadius = '10px';
                    controls.style.boxShadow = '0 8px 24px rgba(0,0,0,0.4)';
                    controls.style.maxWidth = 'calc(100vw - 32px)';
                    // limit height so it doesn't sit on top of the tree; allow internal scrolling
                    controls.style.maxHeight = '38vh';
                    controls.style.overflow = 'auto';
                    controls.style.zIndex = 8600;
                    controls.style.backdropFilter = 'blur(10px) saturate(80%)';
                } else {
                    // reset inline positioning
                    controls.style.position = '';
                    controls.style.left = '';
                    controls.style.top = '';
                    controls.style.background = '';
                    controls.style.padding = '';
                    controls.style.borderRadius = '';
                    controls.style.boxShadow = '';
                    controls.style.maxWidth = '';
                    controls.style.zIndex = '';
                }
                // Fallback: some browsers (mobile Safari when zoomed) can render the
                // control panel invisible due to odd hit-testing or CSS. If the
                // controls are still not visible after toggling, force a fixed,
                // visible panel anchored to the toggle as a safe fallback.
                setTimeout(() => {
                    try {
                        const cs = window.getComputedStyle(controls);
                        const rect = controls.getBoundingClientRect();
                        const hidden = (!controls || cs.display === 'none' || rect.width === 0 || rect.height === 0 || controls.offsetParent === null);
                        if (open && hidden) {
                            const toggleRect = controlsToggle.getBoundingClientRect();
                            const isDark = document.body && document.body.classList && document.body.classList.contains('dark-mode');
                            controls.style.position = 'fixed';
                            controls.style.left = Math.max(8, toggleRect.left) + 'px';
                            controls.style.top = (toggleRect.bottom + 6) + 'px';
                            controls.style.display = 'flex';
                            // Use appropriate background/border for dark-mode so content is visible
                            if (isDark) {
                                controls.style.background = 'linear-gradient(90deg, rgba(0,191,174,0.08), rgba(0,116,217,0.08)), var(--panel-dark-translucent)';
                                controls.style.color = 'var(--text-dark)';
                                controls.style.border = '1px solid rgba(255,255,255,0.06)';
                            } else {
                                controls.style.background = 'linear-gradient(90deg, rgba(0,191,174,0.08), rgba(0,116,217,0.08)), var(--panel-light-translucent)';
                                controls.style.color = '';
                                controls.style.border = '1px solid rgba(0,0,0,0.06)';
                            }
                            controls.style.backdropFilter = 'blur(10px) saturate(80%)';
                            controls.style.padding = '8px';
                            controls.style.borderRadius = '10px';
                            controls.style.boxShadow = '0 8px 24px rgba(0,0,0,0.4)';
                            controls.style.maxWidth = 'calc(100vw - 32px)';
                            controls.style.maxHeight = '48vh';
                            controls.style.overflow = 'auto';
                            controls.style.zIndex = 9999;
                            // Ensure children are laid out and visible
                            controls.style.alignItems = 'center';
                            controls.style.gap = '8px';
                        }
                    } catch (e) { /* non-fatal */ }
                }, 60);
            });
            updateControlsVisibility();
            // initial application of mobile-like UI tweaks
            applyMobileLikeUI();
            // ensure the CSS reserve is populated early and position the toggle
            if (typeof updateControlsReserve === 'function') updateControlsReserve();
            if (typeof positionControlsToggle === 'function') positionControlsToggle();

            const svg = d3.select("#chart").append("svg")
                .attr("width", width).attr("height", height)
                .attr('role', 'img')
                .attr('aria-label', 'Tidy tree visualization');

            // Create a main group for zoom/pan
            const g = svg.append("g");
            // Create links and nodes groups in correct order
            const linkGroup = g.append("g").attr("class", "links");
            const nodeGroup = g.append("g").attr("class", "nodes");

            // allow broader zoom on touch devices for easier pinch-zooming
            const zoom = d3.zoom().scaleExtent([0.3, 4]).on("zoom", (event) => {
                g.attr("transform", event.transform);
                updatePopupHelpPosition();
            });
            svg.call(zoom);

            // Auto-close the controls on mobile when the user taps the chart area.
            // We programmatically click the controls toggle so the aria state and
            // icon animation behave the same as a user click.
            try {
                // Smarter auto-close: only treat quick taps as requests to close the controls.
                // Ignore pointer interactions that move more than `tapThresholdPx` (i.e. swipes/drags).
                const tapThresholdPx = 10;
                container.addEventListener('pointerdown', (event) => {
                    try {
                        if (!isMobileLike()) return;
                        const isOpen = controls.classList.contains('open') || controlsToggle.getAttribute('aria-expanded') === 'true';
                        if (!isOpen) return;
                        // Don't start if the pointerdown originated on the controls or toggle itself
                        if (event.target && event.target.closest && (event.target.closest('#controls') || event.target.closest('#controlsToggle'))) return;

                        const startX = event.clientX;
                        const startY = event.clientY;
                        const pid = event.pointerId;
                        let moved = false;

                        function onMove(ev) {
                            if (ev.pointerId !== pid) return;
                            if (Math.hypot(ev.clientX - startX, ev.clientY - startY) > tapThresholdPx) moved = true;
                        }

                        function onUp(ev) {
                            if (ev.pointerId !== pid) return;
                            cleanup();
                            if (moved) return; // it was a swipe/drag, ignore
                            try {
                                // ensure the final target also wasn't inside controls
                                if (ev.target && ev.target.closest && (ev.target.closest('#controls') || ev.target.closest('#controlsToggle'))) return;
                                controlsToggle.click();
                            } catch (e) { /* non-fatal */ }
                        }

                        function onCancel(ev) {
                            if (ev.pointerId !== pid) return; cleanup();
                        }

                        function cleanup() {
                            try { document.removeEventListener('pointermove', onMove, { passive: true }); } catch (e) { }
                            try { document.removeEventListener('pointerup', onUp, true); } catch (e) { }
                            try { document.removeEventListener('pointercancel', onCancel, true); } catch (e) { }
                        }

                        document.addEventListener('pointermove', onMove, { passive: true });
                        document.addEventListener('pointerup', onUp, true);
                        document.addEventListener('pointercancel', onCancel, true);

                    } catch (e) { /* non-fatal */ }
                }, { passive: true });
            } catch (e) { /* non-fatal */ }

            // ensure chart height computed initially (now that svg exists)
            computeChartHeight();

            // Handle resizing: keep SVG sized to container and re-layout tree
            function resizeHandler() {
                // recompute chart height using topbar
                computeChartHeight();
                updateControlsVisibility();
                // Recompute layout origin so root remains roughly centered vertically
                if (root) {
                    root.x0 = height / 2;
                }
                update(root);
                // Maintain a sensible transform after resize
                const currentTransform = d3.zoomTransform(svg.node());
                // if transform is identity, re-center root
                if (currentTransform.k === 1 && Math.abs(currentTransform.x) < 1 && Math.abs(currentTransform.y) < 1) {
                    // use visual viewport center vertically so resize-triggered recentering
                    // doesn't place content underneath mobile browser chrome
                    const _c = getDesiredScreenCenter();
                    svg.call(zoom.transform, d3.zoomIdentity.translate(Math.min(220, width * 0.25), _c.centerY).scale(1));
                }
                // Always schedule a gentle vertical recenter after resize/orientation flips
                // so the tree doesn't end up sitting below the short landscape viewport.
                try { scheduleRecenter(140); } catch (e) { /* non-fatal */ }
            }

            // Gentle vertical recenter after viewport changes (rotation, iOS chrome show/hide)
            let __recenterTimer = null;
            function scheduleRecenter(delay = 200) {
                try { clearTimeout(__recenterTimer); } catch (e) { }
                __recenterTimer = setTimeout(() => {
                    try { recenterForViewportChange(); } catch (e) { /* non-fatal */ }
                }, delay);
            }
            function recenterForViewportChange() {
                try {
                    if (!svg || !zoom || typeof d3 === 'undefined') return;
                    const t = d3.zoomTransform(svg.node());
                    // Prefer a currently selected node; fall back to root
                    let anchor = null;
                    try {
                        const sel = d3.select('g.node[data-selected="true"]');
                        anchor = (sel && !sel.empty()) ? sel.datum() : (typeof root !== 'undefined' ? root : null);
                    } catch (e) { anchor = (typeof root !== 'undefined' ? root : null); }
                    if (!anchor) return;

                    // Current screen coords of the anchor
                    const screen = t.apply([anchor.y, anchor.x]);
                    const desired = getDesiredScreenCenter();

                    // Adjust only Y; horizontal clamping is handled by ensureTreeVisible
                    const newT = d3.zoomIdentity.translate(t.x, t.y + (desired.centerY - screen[1])).scale(t.k);

                    try { if (typeof suppressAutoEnsure !== 'undefined') suppressAutoEnsure = true; } catch (e) { }
                    svg.interrupt();
                    hideTransientUI();
                    svg.transition().duration(240).call(zoom.transform, newT)
                        .on('end interrupt', () => {
                            try { ensureTreeVisible(); revealHoverAtPointer(); } catch (e) { /* non-fatal */ }
                            finally { try { if (typeof suppressAutoEnsure !== 'undefined') suppressAutoEnsure = false; } catch (e) { } }
                        });
                } catch (e) {
                    try { if (typeof suppressAutoEnsure !== 'undefined') suppressAutoEnsure = false; } catch (_e) { }
                }
            }

            // Debounced resize
            let resizeTimer = null;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimer);
                resizeTimer = setTimeout(resizeHandler, 150);
            });

            // Also update mobile-like UI on orientation/viewport changes (important on iOS)
            if (window.visualViewport) {
                window.visualViewport.addEventListener('resize', () => { 
                    applyMobileLikeUI();
                    // Recompute chart height when the visual viewport changes (e.g., when Safari UI shows/hides)
                    computeChartHeight();
                    try { scheduleRecenter(160); } catch (e) { /* non-fatal */ }
                });
            }
            window.addEventListener('orientationchange', () => { 
                setTimeout(() => {
                    applyMobileLikeUI();
                    computeChartHeight();
                    try { scheduleRecenter(180); } catch (e) { /* non-fatal */ }
                }, 80); 
            });

            // ensure chart height computed initially
            computeChartHeight();


            const tooltip = d3.select("body").append("div")
                .attr("class", "tooltip").style("opacity", 0);
            // Add a separate popup help element
            const popupHelp = d3.select("body").append("div")
                .attr("class", "popup-help").style("opacity", 0).style("position", "fixed");

            // Track last known pointer position so we can re-evaluate hover after programmatic moves
            let lastPointer = { x: null, y: null };
            try {
                document.addEventListener('pointermove', (e) => {
                    lastPointer.x = e.clientX; lastPointer.y = e.clientY;
                }, { passive: true });
            } catch (e) { /* non-fatal */ }

            // Helper to hide transient UI (tooltip or popup) before programmatic viewport moves
            function hideTransientUI() {
                try { tooltip.style('opacity', 0); } catch (e) { }
                try { popupHelp.style('opacity', 0).style('pointer-events', 'none'); } catch (e) { }
                try { document.removeEventListener('pointerdown', popupHelpOutsideClickHandler, true); } catch (e) { }
                popupHelpNode = null;
            }

            // After a programmatic pan/zoom, re-evaluate what's under the pointer and show
            // the appropriate tooltip/popup as if the pointer moved there. This keeps the
            // UI consistent when the chart recenters under a stationary mouse.
            function revealHoverAtPointer() {
                try {
                    if (lastPointer.x == null || lastPointer.y == null) return;
                    const el = document.elementFromPoint(lastPointer.x, lastPointer.y);
                    if (!el) return;
                    // Find the nearest ancestor group for a node
                    const g = el.closest && el.closest('g.node');
                    if (!g) return;
                    // Use d3 to obtain the datum
                    let d = null;
                    try { d = d3.select(g).datum(); } catch (e) { d = null; }
                    if (!d) return;
                    const isSmall = isMobileLike();
                    // If the bottom sheet is already open on mobile, keep it as-is so
                    // the selected node's details remain visible after recentering.
                    if (isSmall && bottomSheet && bottomSheet.classList.contains('open')) return;
                    // If there's a subtitle, surface it; otherwise hide transient UI
                    const txt = d.data && (d.data.subtitle || '');
                    if (!txt) {
                        // do not show empty tooltips; keep popup closed
                        hideTransientUI();
                        return;
                    }
                    if (isSmall) {
                        openBottomSheet(`<div style="padding:4px 2px;">${txt}</div>`, d);
                    } else {
                        tooltip.html(txt).style('opacity', 1).style('pointer-events', 'none');
                        clampToViewport(tooltip, lastPointer.x + 24, lastPointer.y + 24);
                    }
                } catch (e) { /* non-fatal */ }
            }

            // Helper to clamp a fixed-position element to the viewport (keeps a small margin)
            function clampToViewport(sel, desiredLeft, desiredTop) {
                const el = sel.node();
                const margin = 8;
                if (!el) return { left: desiredLeft, top: desiredTop };
                // Temporarily set to desired position so getBoundingClientRect reports correct size
                sel.style('left', desiredLeft + 'px').style('top', desiredTop + 'px');
                const rect = el.getBoundingClientRect();
                const vp = getViewportRect();
                const maxTop = Math.max(margin, vp.top + vp.height - rect.height - margin);
                // use chart width (clamped to visual viewport) for horizontal clamping so popups align with the svg area
                const maxLeft = Math.max(margin, (vp.left + Math.min(width, vp.width)) - rect.width - margin);
                const left = Math.min(Math.max(desiredLeft, margin), maxLeft);
                const top = Math.min(Math.max(desiredTop, margin), maxTop);
                sel.style('left', left + 'px').style('top', top + 'px');
                return { left, top };
            }

            // Minimal robust popup help tracking
            let popupHelpNode = null;

            function updatePopupHelpPosition() {
                if (!popupHelpNode) return;
                // Use tree layout coordinates
                let x = popupHelpNode.x;
                let y = popupHelpNode.y;
                // Get current transform
                const transform = d3.zoomTransform(svg.node());
                // Apply D3 transform to node coordinates
                const transformed = transform.apply([y, x]);
                // Convert SVG coordinates to screen coordinates
                const point = svg.node().createSVGPoint();
                point.x = transformed[0];
                point.y = transformed[1];
                const ctm = svg.node().getScreenCTM();
                if (ctm) {
                    const screenPoint = point.matrixTransform(ctm);
                    // Calculate desired position with offset
                    const vp = getViewportRect();
                    const desiredLeft = screenPoint.x + 24;
                    const desiredTop = screenPoint.y + 24;
                    // Clamp to viewport so popup doesn't go below the bottom (or off the right)
                    const popupEl = popupHelp.node();
                    if (popupEl) {
                        const rect = popupEl.getBoundingClientRect();
                        const margin = 8;
                        const maxTop = Math.max(margin, vp.top + vp.height - rect.height - margin);
                        // align popup clamping with the SVG/chart width rather than full window
                        const maxLeft = Math.max(margin, (vp.left + Math.min(width, vp.width)) - rect.width - margin);
                        const left = Math.min(Math.max(desiredLeft, margin), maxLeft);
                        const top = Math.min(Math.max(desiredTop, vp.top + margin), maxTop);
                        popupHelp.style("left", left + "px").style("top", top + "px");
                    } else {
                        popupHelp.style("left", (screenPoint.x + 24) + "px").style("top", (screenPoint.y + 24) + "px");
                    }
                }
            }

            // Ensure the rendered tree fits horizontally in the viewport by nudging the zoom transform
            // so the left/right visible node extents don't fall outside the screen on small devices.
            function ensureTreeVisible(margin = 24) {
                if (typeof suppressAutoEnsure !== 'undefined' && suppressAutoEnsure) return;
                try {
                    // on narrow phones give a larger margin to avoid nodes being too close to the edge
                    const small = isMobileLike();
                    if (small) margin = Math.max(margin, 48);
                    const nodes = root.descendants().filter(d => !(d.x == null || d.y == null));
                    if (!nodes || nodes.length === 0) return;
                    const transform = d3.zoomTransform(svg.node());
                    // compute screen X (horizontal) for each node (svg coords are [y,x])
                    let minScreenX = Infinity, maxScreenX = -Infinity;
                    nodes.forEach(d => {
                        const pt = transform.apply([d.y, d.x]);
                        const sx = pt[0];
                        if (sx < minScreenX) minScreenX = sx;
                        if (sx > maxScreenX) maxScreenX = sx;
                    });
                    const leftLimit = margin;
                    // use the chart width (container) as the horizontal limit
                    const rightLimit = width - margin;
                    let dx = 0;
                    if (maxScreenX > rightLimit) {
                        dx = rightLimit - maxScreenX; // negative value moves tree left
                    } else if (minScreenX < leftLimit) {
                        dx = leftLimit - minScreenX; // positive moves tree right
                    }
                    // Additionally, consider the text label bounding boxes. On mobile the
                    // node center may be visible while the label (which extends left)
                    // is clipped off-screen. Inspect rendered text elements and nudge
                    // the view so the left-most text bounding rect is at least `margin`
                    // pixels from the viewport's left edge.
                    try {
                        const nodeElems = nodeGroup.selectAll('g.node').nodes();
                        let minLabelLeft = Infinity;
                        nodeElems.forEach(gEl => {
                            try {
                                const textEl = gEl.querySelector && gEl.querySelector('text');
                                if (!textEl) return;
                                const rect = textEl.getBoundingClientRect();
                                if (rect.left < minLabelLeft) minLabelLeft = rect.left;
                            } catch (e) { /* ignore individual node read errors */ }
                        });
                        if (minLabelLeft !== Infinity) {
                            const vp = getViewportRect();
                            const desiredLeft = (vp.left || 0) + margin;
                            if (minLabelLeft < desiredLeft) {
                                // move content right by the pixel difference
                                const needed = desiredLeft - minLabelLeft;
                                dx = (dx || 0) + needed;
                            }
                        }
                    } catch (e) { /* non-fatal */ }
                    if (dx !== 0) {
                        const newTransform = d3.zoomIdentity.translate(transform.x + dx, transform.y).scale(transform.k);
                        hideTransientUI();
                        svg.transition().duration(300).call(zoom.transform, newTransform)
                            .on('end interrupt', () => { try { revealHoverAtPointer(); } catch (e) { } });
                    }
                } catch (e) {
                    // non-fatal
                    console.warn('ensureTreeVisible failed', e);
                }
            }

            // Collapsible tree helpers
            function collapse(d) {
                if (d.children) { d._children = d.children; d._children.forEach(collapse); d.children = null; }
            }
            function expand(d) {
                if (d._children) { d.children = d._children; d._children = null; }
            }

            const root = d3.hierarchy(data);
            // When true, prevent ensureTreeVisible from nudging the view while we perform
            // a deliberate centering animation (avoids competing transitions).
            let suppressAutoEnsure = false;
            root.x0 = height / 2;
            root.y0 = 0;
            // Collapse the 'Death', 'Burial', and 'Resurrection' nodes themselves so only those are visible under the root
            if (root.children) {
                root.children.forEach(child => {
                    if (["Death", "Burial", "Resurrection"].includes(child.data.name)) {
                        collapse(child);
                    } else {
                        collapse(child);
                    }
                });
            }

            // Default to cluster layout
            let treeLayout = d3.cluster();
            // initial nodeSize will be set from the UI controls below so spacing matches the visible defaults

            // Controls
            const nodeSizeYInput = document.getElementById('nodesizeY');
            const nodeSizeXInput = document.getElementById('nodesizeX');
            nodeSizeYInput.addEventListener('input', updateNodeSize);
            nodeSizeXInput.addEventListener('input', updateNodeSize);
            function updateNodeSize() {
                const y = +nodeSizeYInput.value;
                const x = +nodeSizeXInput.value;
                treeLayout.nodeSize([y, x]);
                update(root);
            }
            // const tree = d3.tree().nodeSize([120, 200]); // vertical spacing, horizontal spacing

            const nodeSizeInput = document.getElementById('nodesize');
            nodeSizeInput.addEventListener('input', () => {
                const v = +nodeSizeInput.value;
                treeLayout.nodeSize([v, v + 80]);
                update(root);
            });
            const wrapToggle = document.getElementById('wrap');

            // Initialize layout sizing to the denser defaults used previously
            // Detect iOS (covers Mobile Safari and Chrome on iOS) and treat it as a small/tall mobile
            // so we increase vertical spacing there as well. This avoids relying solely on
            // the computed chart height which can differ across browsers on iOS.
            const isIOS = (() => {
                const ua = navigator.userAgent || '';
                const platform = navigator.platform || '';
                // iPhone/iPad/iPod in UA, or iPad on modern iPadOS which reports MacIntel but has touch
                return /iPad|iPhone|iPod/.test(ua) || (platform === 'MacIntel' && navigator.maxTouchPoints > 1);
            })();
            // But increase vertical spacing on narrow/tall mobile screens (or iOS browsers)
            const initialVertical = (isIOS || (height && height < 700)) ? 28 : 22; // vertical spacing (larger on phones)
            // Slightly reduce horizontal spacing on narrow screens so the tree fits
            const initialHorizontal = (width && width < 480) ? 160 : 200; // horizontal spacing
            // Sync hidden UI controls to reflect these defaults so toggling preserves expected spacing
            if (nodeSizeYInput) nodeSizeYInput.value = initialVertical;
            if (nodeSizeXInput) nodeSizeXInput.value = initialHorizontal;
            if (nodeSizeInput) nodeSizeInput.value = initialVertical;
            treeLayout.nodeSize([initialVertical, initialHorizontal]);

            // Cluster toggle: set up once (not inside update) so it isn't reset on every render
            const clusterToggle = document.getElementById('clusterToggle');
            // Default to cluster layout (matches initial treeLayout)
            clusterToggle.checked = true;
            clusterToggle.addEventListener('change', function () {
                if (clusterToggle.checked) {
                    treeLayout = d3.cluster();
                } else {
                    treeLayout = d3.tree();
                }
                // Keep node size settings
                const y = +nodeSizeYInput.value;
                const x = +nodeSizeXInput.value;
                treeLayout.nodeSize([y, x]);
                update(root);
            });

            // Word wrap helper
            function wrapText(selection, width = 160) {
                selection.each(function (d) {
                    const text = d3.select(this);
                    const words = (text.text() || "").split(/\s+/).reverse();
                    let line = [], lineNumber = 0;
                    // Prefer the already-set x attribute (so wrapping honors dynamic offsets),
                    // otherwise fall back to the original +/-10 defaults.
                    const xAttr = text.attr('x');
                    const x = (xAttr != null && xAttr !== '') ? parseFloat(xAttr) : ((d.children || d._children) ? -10 : 10);
                    let tspan = text.text(null).append("tspan").attr("x", x).attr("dy", "0em");
                    let word, lineHeight = 1.1;
                    while (word = words.pop()) {
                        line.push(word);
                        tspan.text(line.join(" "));
                        if (tspan.node().getComputedTextLength() > width) {
                            line.pop();
                            tspan.text(line.join(" "));
                            line = [word];
                            tspan = text.append("tspan")
                                .attr("x", x)
                                .attr("dy", ++lineNumber * lineHeight + "em")
                                .text(word);
                        }
                    }
                });
            }

            // Color per node (inherit from ancestors if not set)
            function nodeColor(d) {
                let x = d;
                while (x) {
                    if (x.data && x.data.color) return x.data.color;
                    x = x.parent;
                }
                return "#6c6c6c";
            }

            function update(source) {
                treeLayout(root);
                const nodes = root.descendants();
                const links = root.links();
                // (cluster toggle is wired once at top-level to avoid being reset on each update)

                // nodes.forEach(d => d.y = d.depth * 180); // horizontal spacing per depth

                // LINKS (drawn first, behind nodes)
                const link = linkGroup.selectAll("path.link").data(links, d => d.target.id || (d.target.id = crypto.randomUUID()));
                link.enter().append("path")
                    .attr("class", "link")
                    .attr("d", d3.linkHorizontal().x(d => source.y0).y(d => source.x0))
                    .merge(link)
                    .transition().duration(350)
                    .attr("d", d3.linkHorizontal().x(d => d.y).y(d => d.x));
                link.exit().transition().duration(250)
                    .attr("d", d3.linkHorizontal().x(d => source.y).y(d => source.x))
                    .remove();

                // NODES (drawn above links)
                const node = nodeGroup.selectAll("g.node").data(nodes, d => d.id || (d.id = crypto.randomUUID()));

                // Shared activation logic for nodes (click or tap)
                function handleNodeActivate(event, d) {
                    const isSmall = isMobileLike();
                    try {
                        // mark only the activated node's group with data-selected="true"
                        d3.selectAll('g.node').attr('data-selected', 'false');
                        d3.selectAll('g.node').filter(n => n === d).attr('data-selected', 'true');
                    } catch (e) { /* ignore if d3 not present */ }
                    if (!d.children && !d._children && d.data.source && (d.data.source.highlightedUrl || d.data.source.url)) {
                        // Prefer a highlightedUrl when authors provided one in the source group; fall back to url
                        const href = d.data.source.highlightedUrl || d.data.source.url;
                        // Build a leaf-specific content block so we can style date/details/link
                        // separately without affecting non-leaf popup-help UI.
                        let html = `<div class="sheet-title">${d.data.name}</div>`;
                        html += `<div class="leaf-content">`;
                        if (d.data.date) html += `<div class="leaf-date">${d.data.date}</div>`;
                        if (d.data.details) html += `<div class="leaf-details">${d.data.details}</div>`;
                        html += `<div class="leaf-link"><a href='${href}' target='_blank' style='color:var(--link-accent);text-decoration:underline'>${d.data.source.title || "View Source"}</a></div>`;
                        html += `</div>`;
                        if (isSmall) {
                            openBottomSheet(html, d);
                        } else {
                            popupHelp.html(html)
                                .style("opacity", 1)
                                .style("pointer-events", "auto");
                            popupHelpNode = d;
                            updatePopupHelpPosition();
                            setTimeout(() => {
                                document.addEventListener('pointerdown', popupHelpOutsideClickHandler, true);
                            }, 0);
                        }
                    } else {
                        // Determine whether this interaction will expand or collapse the node
                        const willExpand = !d.children && d._children;
                        if (willExpand) {
                            // Only expand the clicked node's immediate children.
                            // Previously we expanded all descendants via expandAllRecursive;
                            // remove that so a click only toggles the immediate level.
                            expand(d);
                        } else {
                            collapse(d);
                        }

                        // Perform the update and then, on small screens, center the newly-exposed
                        // deepest-level nodes (after an expand) or center on the parent (after a collapse).
                        // Suppress automatic ensureTreeVisible nudges while we do our manual centering.
                        suppressAutoEnsure = true;
                        update(d);

                        // Always run centering code after the update/transition. On small screens we
                        // preserve the existing full-centering behavior. On larger screens we apply
                        // a softer, clamped nudge so the viewport moves toward the selected area
                        // without fully recentring (less jarring on desktop).
                        const isSmall = isMobileLike();
                        setTimeout(() => {
                            try {
                                const transform = d3.zoomTransform(svg.node());
                                if (isSmall) {
                                    // original mobile behavior: center fully on the target
                                    if (willExpand) {
                                        const desc = d.descendants();
                                        if (!desc || desc.length === 0) { suppressAutoEnsure = false; return; }
                                        let maxDepth = -Infinity;
                                        desc.forEach(n => { if (n.depth > maxDepth) maxDepth = n.depth; });
                                        const deepest = desc.filter(n => n.depth === maxDepth);
                                        if (!deepest || deepest.length === 0) { suppressAutoEnsure = false; return; }
                                        const avgX = d3.mean(deepest, n => n.x);
                                        const avgY = d3.mean(deepest, n => n.y);
                                        const screen = transform.apply([avgY, avgX]);
                                        // use chart width for horizontal centering
                                        const center = getDesiredScreenCenter();
                                        // Bias horizontally on portrait mobile so labels that extend
                                        // left of the node remain visible after centering.
                                        const vp = getViewportRect();
                                        const isPortrait = (vp.height || window.innerHeight) > (vp.width || window.innerWidth);
                                        const biasFrac = (isPortrait && isMobileLike()) ? MOBILE_BIAS_FRAC : 0; // fraction of width to nudge right
                                        const desiredScreenX = width * (0.5 + biasFrac);
                                        const dx = desiredScreenX - screen[0];
                                        const dy = center.centerY - screen[1];
                                        const newTransform = d3.zoomIdentity.translate(transform.x + dx, transform.y + dy).scale(transform.k);
                                        svg.interrupt();
                                        hideTransientUI();
                                        svg.transition().duration(360).call(zoom.transform, newTransform)
                                            .on('end interrupt', () => { try { revealHoverAtPointer(); } catch (e) { } finally { suppressAutoEnsure = false; } });
                                    } else {
                                        const avgX = d.x;
                                        const avgY = d.y;
                                        const screen = transform.apply([avgY, avgX]);
                                        // use chart width for horizontal centering
                                        const center = getDesiredScreenCenter();
                                        const vp = getViewportRect();
                                        const isPortrait = (vp.height || window.innerHeight) > (vp.width || window.innerWidth);
                                        const biasFrac = (isPortrait && isMobileLike()) ? MOBILE_BIAS_FRAC : 0;
                                        const desiredScreenX = width * (0.5 + biasFrac);
                                        const dx = desiredScreenX - screen[0];
                                        const dy = center.centerY - screen[1];
                                        const newTransform = d3.zoomIdentity.translate(transform.x + dx, transform.y + dy).scale(transform.k);
                                        svg.interrupt();
                                        hideTransientUI();
                                        svg.transition().duration(360).call(zoom.transform, newTransform)
                                            .on('end interrupt', () => { try { revealHoverAtPointer(); } catch (e) { } finally { suppressAutoEnsure = false; } });
                                    }
                                } else {
                                    // Desktop/large-screen behavior: apply a fraction of the computed delta
                                    // and clamp to reasonable maximums so motion is subtle.
                                    const duration = 260;
                                    const fraction = 1.0; // apply full computed shift on desktop (match mobile)
                                    if (willExpand) {
                                        const desc = d.descendants();
                                        if (!desc || desc.length === 0) { suppressAutoEnsure = false; return; }
                                        let maxDepth = -Infinity;
                                        desc.forEach(n => { if (n.depth > maxDepth) maxDepth = n.depth; });
                                        const deepest = desc.filter(n => n.depth === maxDepth);
                                        if (!deepest || deepest.length === 0) { suppressAutoEnsure = false; return; }
                                        const avgX = d3.mean(deepest, n => n.x);
                                        const avgY = d3.mean(deepest, n => n.y);
                                        const screen = transform.apply([avgY, avgX]);
                                        // use the computed chart `width` (container) rather than the full window
                                        let dx = ((width / 2) - screen[0]) * fraction;
                                        let dy = (getDesiredScreenCenter().centerY - screen[1]) * fraction;
                                        const maxMoveX = width * 0.35;
                                        const maxMoveY = height * 0.35;
                                        dx = Math.max(-maxMoveX, Math.min(maxMoveX, dx));
                                        dy = Math.max(-maxMoveY, Math.min(maxMoveY, dy));
                                        const newTransform = d3.zoomIdentity.translate(transform.x + dx, transform.y + dy).scale(transform.k);
                                        svg.interrupt();
                                        hideTransientUI();
                                        svg.transition().duration(duration).call(zoom.transform, newTransform)
                                            .on('end interrupt', () => { try { revealHoverAtPointer(); } catch (e) { } finally { suppressAutoEnsure = false; } });
                                    } else {
                                        const avgX = d.x;
                                        const avgY = d.y;
                                        const screen = transform.apply([avgY, avgX]);
                                        // use chart `width` for horizontal centering
                                        let dx = ((width / 2) - screen[0]) * fraction;
                                        let dy = (getDesiredScreenCenter().centerY - screen[1]) * fraction;
                                        const maxMoveX = width * 0.35;
                                        const maxMoveY = height * 0.35;
                                        dx = Math.max(-maxMoveX, Math.min(maxMoveX, dx));
                                        dy = Math.max(-maxMoveY, Math.min(maxMoveY, dy));
                                        const newTransform = d3.zoomIdentity.translate(transform.x + dx, transform.y + dy).scale(transform.k);
                                        svg.interrupt();
                                        hideTransientUI();
                                        svg.transition().duration(duration).call(zoom.transform, newTransform)
                                            .on('end interrupt', () => { try { revealHoverAtPointer(); } catch (e) { } finally { suppressAutoEnsure = false; } });
                                    }
                                }
                            } catch (e) {
                                console.warn('centering after expand/collapse failed', e);
                                suppressAutoEnsure = false;
                            }
                        }, isSmall ? 380 : 220);

                        popupHelp.style("opacity", 0)
                            .style("pointer-events", "none");
                        document.removeEventListener('pointerdown', popupHelpOutsideClickHandler, true);
                        popupHelpNode = null;
                        // For toggles, only surface the bottom-sheet/popup on mobile-like devices.
                        // Desktop/large-screen toggles should not open additional popups to avoid
                        // stacking multiple tooltip boxes.
                        try {
                            const infoHtml = `<div class="sheet-title">${d.data.name}</div>` +
                                (d.data.subtitle ? `<div style="margin-top:6px;">${d.data.subtitle}</div>` : (d.data.details ? `<div style="margin-top:6px;">${d.data.details}</div>` : ``));
                            if (isSmall) {
                                openBottomSheet(infoHtml, d);
                            }
                        } catch (e) { /* non-fatal */ }
                    }
                }

                // tap detection: small movement + short time -> treat as tap
                const pointerStarts = new Map();

                const nodeEnter = node.enter().append("g")
                    .attr("class", d => (!d.children && !d._children && d.data.source && d.data.source.url) ? "node clickable" : "node")
                    .attr("transform", d => `translate(${source.y0},${source.x0})`)
                    .on('pointerdown', (event, d) => {
                        try { if (event.isPrimary) pointerStarts.set(event.pointerId, { x: event.clientX, y: event.clientY, t: Date.now() }); } catch (e) { /* ignore */ }
                    })
                    .on('pointerup', (event, d) => {
                        const s = pointerStarts.get(event.pointerId);
                        if (s) {
                            const dx = event.clientX - s.x;
                            const dy = event.clientY - s.y;
                            const dist = Math.hypot(dx, dy);
                            const dt = Date.now() - s.t;
                            pointerStarts.delete(event.pointerId);
                            if (dist < 8 && dt < 400) {
                                // mark tapped to avoid duplicate click handling
                                d._handledTap = Date.now();
                                handleNodeActivate(event, d);
                                event.preventDefault();
                                return;
                            }
                        }
                    })
                    .on('pointercancel', (event) => { pointerStarts.delete(event.pointerId); })
                    .on('click', (event, d) => {
                        // avoid duplicate when pointerup already handled the tap
                        if (d._handledTap && (Date.now() - d._handledTap) < 600) { d._handledTap = 0; return; }
                        handleNodeActivate(event, d);
                    })
                    .on("pointerenter", (event, d) => {
                        // show subtitle on hover/enter (pointer-aware)
                        const txt = d.data.subtitle || "";
                        if (!txt) return;
                        const isSmall = isMobileLike();
                        if (isSmall) {
                            // On small/touch devices the tooltip often appears under the finger.
                            // Use the bottom sheet to surface subtitle info instead.
                            const html = `<div style="padding:4px 2px;">${txt}</div>`;
                            openBottomSheet(html, d);
                            return;
                        }
                        tooltip.html(txt)
                            .style("opacity", 1)
                            .style("pointer-events", "none");
                        clampToViewport(tooltip, event.clientX + 24, event.clientY + 24);
                    })
                    .on("pointermove", (event) => {
                        const isSmall = isMobileLike();
                        if (!isSmall) clampToViewport(tooltip, event.clientX + 24, event.clientY + 24);
                    })
                    .on("pointerleave", () => {
                        tooltip.style("opacity", 0);
                    });
                // Remove mouseleave handler so tooltip doesn't disappear immediately

                // Helper to hide popup help only when clicking outside
                function popupHelpOutsideClickHandler(e) {
                    const popupEl = popupHelp.node();
                    if (popupHelp.style("opacity") === "1" && (!popupEl || (e.target !== popupEl && !popupEl.contains(e.target)))) {
                        popupHelp.style("opacity", 0)
                            .style("pointer-events", "none");
                        document.removeEventListener('pointerdown', popupHelpOutsideClickHandler, true);
                        // Quickfix: dispatch mouseleave to node under popup
                        if (popupHelpNode) {
                            // Find the corresponding SVG node group
                            const nodeGroup = d3.selectAll('g.node').filter(d => d === popupHelpNode);
                            nodeGroup.select('text').each(function () {
                                const evt = new MouseEvent('mouseleave', { bubbles: true });
                                this.dispatchEvent(evt);
                            });
                        }
                        popupHelpNode = null;
                    }
                }

                // Adjust node radius for small touch screens to improve tap targets
                const isSmall = isMobileLike();
                const targetRadius = isSmall ? 8 : 6;
                // Compute a label offset that keeps text a comfortable distance from the node.
                // This scales with the node radius so larger nodes on small screens push labels further out.
                const labelOffset = targetRadius + 8; // px gap from node edge to first text baseline

                nodeEnter.append("circle")
                    .attr("r", 1e-6)
                    .attr("fill", d => (d._children ? nodeColor(d) : "#fff"))
                    .attr("stroke", d => nodeColor(d));

                const labels = nodeEnter.append("text")
                    .attr("dy", "0em")
                    .attr("x", d => (d.children || d._children) ? -labelOffset : labelOffset)
                    .attr("text-anchor", d => (d.children || d._children) ? "end" : "start")
                    .html(d => d.data.link
                        ? `<a href="${d.data.link}" target="_blank" style="fill:var(--link-accent);text-decoration:underline">${d.data.name}</a>`
                        : d.data.name);

                function applyLabelWrapping() {
                    g.selectAll("g.node text").each(function (d) {
                        const text = d3.select(this);
                        text.text(d.data.name);
                        if (wrapToggle.checked) wrapText(text, 160);
                    });
                }
                applyLabelWrapping();
                wrapToggle.onchange = applyLabelWrapping;

                // UPDATE + TRANSITIONS
                const nodeUpdate = nodeEnter.merge(node);
                nodeUpdate.transition().duration(350)
                    .attr("transform", d => `translate(${d.y},${d.x})`)
                    .on("end", () => { updatePopupHelpPosition(); });
                nodeUpdate.select("circle").transition().duration(350)
                    .attr("r", targetRadius)
                    .attr("fill", d => (d._children ? nodeColor(d) : "#fff"))
                    .attr("stroke", d => nodeColor(d));
                nodeUpdate.select("text").transition().duration(350)
                    .attr("x", d => (d.children || d._children) ? -labelOffset : labelOffset)
                    .attr("text-anchor", d => (d.children || d._children) ? "end" : "start");

                const nodeExit = node.exit().transition().duration(250)
                    .attr("transform", d => `translate(${source.y},${source.x})`)
                    .remove();
                nodeExit.select("circle").attr("r", 1e-6);

                // Stash positions for smooth transitions next time
                nodes.forEach(d => { d.x0 = d.x; d.y0 = d.y; });
                // Make sure the tree fits the viewport (esp. on narrow phones where right nodes can be off-screen)
                ensureTreeVisible();
            }

            update(root);

            // Center root nicely
            // Shift right so root node is visible. Use the same centering helpers that
            // programmatic actions (like Collapse All / Expand All) use so desktop
            // initial centering matches later behavior.
            const smallScreen = isMobileLike();
            const initialTranslateX = smallScreen ? Math.min(140, Math.max(48, width * MOBILE_BIAS_FRAC)) : 220;
            // Apply a sensible starting transform, then run the smoother centering
            // Use visual viewport vertical center so initial centering accounts for mobile browser chrome
            const _initialCenter = getDesiredScreenCenter();
            svg.call(zoom.transform, d3.zoomIdentity.translate(initialTranslateX, _initialCenter.centerY).scale(1));
            // After layout settles, run centering that focuses on the deepest visible nodes
            setTimeout(() => {
                try {
                    if (smallScreen) {
                        try { centerAfterUpdate(root); } catch (e) { /* ignore */ }
                    } else {
                        try { centerSmooth(root); } catch (e) { /* ignore */ }
                    }
                } catch (e) { /* non-fatal */ }
                // Ensure nodes fit the viewport after centering
                ensureTreeVisible();
            }, 140);

            // Collapse or expand all nodes
            function collapseAll(d) {
                if (d.children) {
                    d.children.forEach(collapseAll);
                    collapse(d);
                }
            }
            function expandAll(d) {
                if (d._children) {
                    expand(d);
                    d.children.forEach(expandAll);
                } else if (d.children) {
                    d.children.forEach(expandAll);
                }
            }

            // Centering helper used after programmatic updates (buttons/state changes)
            // target can be a single node or an array of nodes. If null, center on root.
            const debugCentering = false; // set true to enable console.logs for centering/debug
            function centerAfterUpdate(target, opts = {}) {
                try {
                    const isSmall = isMobileLike();
                    const transform = d3.zoomTransform(svg.node());
                    // Choose nodes to center on
                    let nodes = null;
                    if (!target) {
                        nodes = [root];
                    } else if (Array.isArray(target)) {
                        nodes = target;
                    } else {
                        // single node: if it has visible descendants prefer the deepest ones
                        const desc = (target && typeof target.descendants === 'function') ? target.descendants() : null;
                        if (desc && desc.length > 0) {
                            let maxDepth = -Infinity;
                            desc.forEach(n => { if (n.depth > maxDepth) maxDepth = n.depth; });
                            const deepest = desc.filter(n => n.depth === maxDepth);
                            nodes = (deepest && deepest.length > 0) ? deepest : [target];
                        } else {
                            nodes = [target];
                        }
                    }

                    // compute average coordinates in layout space
                    const avgX = d3.mean(nodes, n => n.x);
                    const avgY = d3.mean(nodes, n => n.y);

                    if (isSmall) {
                        // full-centering behavior (preserve original mobile UX)
                        const screen = transform.apply([avgY, avgX]);
                        if (debugCentering) console.log('centerAfterUpdate mobile avg', { avgX, avgY, screen });
                        // use chart width for horizontal centering and visual viewport for vertical
                        const vp = getViewportRect();
                        const isPortrait = (vp.height || window.innerHeight) > (vp.width || window.innerWidth);
                        const biasFrac = (isPortrait && isMobileLike()) ? MOBILE_BIAS_FRAC : 0;
                        const desiredScreenX = width * (0.5 + biasFrac);
                        const dx = desiredScreenX - screen[0];
                        const dy = getDesiredScreenCenter().centerY - screen[1];
                        const newTransform = d3.zoomIdentity.translate(transform.x + dx, transform.y + dy).scale(transform.k);
                        suppressAutoEnsure = true;
                        svg.interrupt();
                        hideTransientUI();
                        svg.transition().duration(360).call(zoom.transform, newTransform)
                            .on('end interrupt', () => { try { revealHoverAtPointer(); } catch (e) { } finally { suppressAutoEnsure = false; } });
                    } else {
                        // gentle, clamped nudge on larger screens
                        if (debugCentering) console.log('centerAfterUpdate desktop avg', { avgX, avgY });
                        const fraction = (opts.fraction != null) ? opts.fraction : 0.45;
                        const duration = (opts.duration != null) ? opts.duration : 260;
                        const screen = transform.apply([avgY, avgX]);
                        // use chart width for horizontal centering
                        let dx = ((width / 2) - screen[0]) * fraction;
                        let dy = (getDesiredScreenCenter().centerY - screen[1]) * fraction;
                        const maxMoveX = width * 0.35;
                        const maxMoveY = height * 0.35;
                        dx = Math.max(-maxMoveX, Math.min(maxMoveX, dx));
                        dy = Math.max(-maxMoveY, Math.min(maxMoveY, dy));
                        const newTransform = d3.zoomIdentity.translate(transform.x + dx, transform.y + dy).scale(transform.k);
                        if (debugCentering) console.log('centerAfterUpdate transform', { dx, dy, newTransform });
                        suppressAutoEnsure = true;
                        svg.interrupt();
                        hideTransientUI();
                        svg.transition().duration(duration).call(zoom.transform, newTransform)
                            .on('end interrupt', () => { try { revealHoverAtPointer(); } catch (e) { } finally { suppressAutoEnsure = false; } });
                    }
                } catch (e) {
                    console.warn('centerAfterUpdate failed', e);
                    suppressAutoEnsure = false;
                }
            }

            // Immediate centering (no animation) used for desktop programmatic actions
            function centerImmediate(target) {
                try {
                    const transform = d3.zoomTransform(svg.node());
                    // select nodes to center on (reuse logic from centerAfterUpdate)
                    let nodes = null;
                    if (!target) nodes = [root];
                    else if (Array.isArray(target)) nodes = target;
                    else {
                        const desc = (target && typeof target.descendants === 'function') ? target.descendants() : null;
                        if (desc && desc.length > 0) {
                            let maxDepth = -Infinity;
                            desc.forEach(n => { if (n.depth > maxDepth) maxDepth = n.depth; });
                            const deepest = desc.filter(n => n.depth === maxDepth);
                            nodes = (deepest && deepest.length > 0) ? deepest : [target];
                        } else {
                            nodes = [target];
                        }
                    }
                    const avgX = d3.mean(nodes, n => n.x);
                    const avgY = d3.mean(nodes, n => n.y);
                    // compute desired dx/dy to center on avg
                    const screen = transform.apply([avgY, avgX]);
                    // use chart width for horizontal centering and visual viewport for vertical
                    const vp = getViewportRect();
                    const isPortrait = (vp.height || window.innerHeight) > (vp.width || window.innerWidth);
                    const biasFrac = (isPortrait && isMobileLike()) ? MOBILE_BIAS_FRAC : 0;
                    const desiredScreenX = width * (0.5 + biasFrac);
                    const dx = desiredScreenX - screen[0];
                    const dy = getDesiredScreenCenter().centerY - screen[1];
                    const newTransform = d3.zoomIdentity.translate(transform.x + dx, transform.y + dy).scale(transform.k);
                    // apply immediately
                    suppressAutoEnsure = true;
                    svg.interrupt();
                    hideTransientUI();
                    svg.call(zoom.transform, newTransform);
                    try { revealHoverAtPointer(); } catch (e) { }
                    suppressAutoEnsure = false;
                } catch (e) { console.warn('centerImmediate failed', e); suppressAutoEnsure = false; }
            }

            // Smooth centering (animated) used for desktop programmatic actions
            function centerSmooth(target, opts = {}) {
                const duration = (opts && opts.duration) ? opts.duration : 420;
                try {
                    const transform = d3.zoomTransform(svg.node());
                    // select nodes to center on (reuse logic from centerAfterUpdate)
                    let nodes = null;
                    if (!target) nodes = [root];
                    else if (Array.isArray(target)) nodes = target;
                    else {
                        const desc = (target && typeof target.descendants === 'function') ? target.descendants() : null;
                        if (desc && desc.length > 0) {
                            let maxDepth = -Infinity;
                            desc.forEach(n => { if (n.depth > maxDepth) maxDepth = n.depth; });
                            const deepest = desc.filter(n => n.depth === maxDepth);
                            nodes = (deepest && deepest.length > 0) ? deepest : [target];
                        } else {
                            nodes = [target];
                        }
                    }
                    const avgX = d3.mean(nodes, n => n.x);
                    const avgY = d3.mean(nodes, n => n.y);
                    const screen = transform.apply([avgY, avgX]);
                    // use chart width for horizontal centering and visual viewport for vertical
                    const dx = (width / 2) - screen[0];
                    const dy = getDesiredScreenCenter().centerY - screen[1];
                    const newTransform = d3.zoomIdentity.translate(transform.x + dx, transform.y + dy).scale(transform.k);
                    suppressAutoEnsure = true;
                    svg.interrupt();
                    hideTransientUI();
                    svg.transition().duration(duration).call(zoom.transform, newTransform)
                        .on('end interrupt', () => { try { revealHoverAtPointer(); } catch (e) { } finally { suppressAutoEnsure = false; } });
                } catch (e) { console.warn('centerSmooth failed', e); suppressAutoEnsure = false; }
            }



            document.getElementById('collapseAll').onclick = () => {
                root.children && root.children.forEach(collapseAll);
                update(root);
                // update tracked index
                currentExpansionIndex = findMatchingStateIndex();
                // center after collapse all: on small screens keep immediate/animated behavior,
                // on desktop wait briefly for layout transitions to finish then center so a
                // single click is sufficient.
                if (smallScreen) {
                    try { centerAfterUpdate(root); } catch (e) { /* ignore */ }
                } else {
                    setTimeout(() => { try { centerSmooth(root); } catch (e) { /* ignore */ } }, 380);
                }
            };
            document.getElementById('expandAll').onclick = () => {
                // Ensure we expand the entire tree even when nodes are collapsed into `_children`.
                // Call the recursive helper on the root itself instead of iterating `root.children`.
                try { expandAll(root); } catch (e) { /* ignore */ }
                update(root);
                // update tracked index
                currentExpansionIndex = findMatchingStateIndex();
                // center after expand all: on small screens keep immediate/animated behavior,
                // on desktop wait briefly for layout transitions to finish then center so a
                // single click is sufficient.
                if (smallScreen) {
                    try { centerAfterUpdate(root); } catch (e) { /* ignore */ }
                } else {
                    setTimeout(() => { try { centerSmooth(root); } catch (e) { /* ignore */ } }, 380);
                }
            };

            // State machine for one-level expand/collapse
            // We'll precompute a list of expansion "states" (sets of node keys that are expanded)
            // starting from root-only up to fully-expanded. Then collapse/expand one level
            // simply moves the current index and applies the corresponding state to the live tree.

            // Helper to get a stable key for a node: use the ancestor path (ids or names) so
            // keys are stable and unique across simulated and live hierarchies.
            function nodeKey(d) {
                // build path from root -> ... -> node using data.id if present, otherwise data.name
                try {
                    const parts = d.ancestors().reverse().map(n => (n.data && (n.data.id ?? n.data.name)) || '').filter(Boolean);
                    return parts.join('/');
                } catch (e) {
                    // fallback for nodes that don't support ancestors(): use name or id
                    return d.data?.id ?? d.data?.name ?? d.id ?? String(d);
                }
            }

            let expansionStates = []; // array of Set(nodeKey) from root-only (index 0) to fully-expanded (last)
            let currentExpansionIndex = 1; // default to first level beyond root

            // Build simulated collapse sequence from fully expanded down to root-only, then reverse it.
            function buildExpansionStatesFromData(rawData) {
                // Use a deep-cloned hierarchy so we don't touch the live `root`
                const simRoot = d3.hierarchy(JSON.parse(JSON.stringify(rawData)));

                function getExpandedKeys(n) {
                    return new Set(n.descendants().filter(d => d.children && d.children.length > 0).map(nodeKey));
                }

                const states = [];
                // Start with fully expanded state
                states.push(getExpandedKeys(simRoot));

                // Simulate repeated "collapse one level" operations until nothing left to collapse
                while (true) {
                    const candidates = simRoot.descendants().filter(d => d.children && d.children.length > 0);
                    if (candidates.length === 0) break;
                    const toCollapse = candidates.filter(d => d.children.every(c => !c.children || c.children.length === 0));
                    if (toCollapse.length === 0) break;
                    toCollapse.forEach(d => { d._children = d.children; d.children = null; });
                    states.push(getExpandedKeys(simRoot));
                }

                // states currently goes from fully-expanded -> ... -> root-only, reverse it
                return states.reverse();
            }

            // Apply an expansion state (set of node keys that should be expanded) to the live `root`
            function applyExpansionStateToLiveRoot(expandedSet) {
                root.descendants().forEach(d => {
                    const key = nodeKey(d);
                    if (expandedSet.has(key)) {
                        if (d._children) { d.children = d._children; d._children = null; }
                        // if it already has children do nothing
                    } else {
                        if (d.children) { d._children = d.children; d.children = null; }
                    }
                });
                // Prevent the automatic ensureTreeVisible from scheduling its own transform
                // while we intend to run a deliberate centering animation below.
                suppressAutoEnsure = true;
                update(root);
                // After a programmatic state change, softly center on the deepest visible nodes
                try {
                    const visible = root.descendants().filter(n => !(n.x == null || n.y == null));
                    if (visible && visible.length > 0) {
                        let maxDepth = -Infinity;
                        visible.forEach(n => { if (n.depth > maxDepth) maxDepth = n.depth; });
                        const deepest = visible.filter(n => n.depth === maxDepth);
                        if (debugCentering) {
                            const avgX = d3.mean(deepest, n => n.x);
                            const avgY = d3.mean(deepest, n => n.y);
                            console.log('applyExpansionStateToLiveRoot: visible', visible.length, 'deepest', deepest.length, { avgX, avgY });
                        }
                        // For programmatic 'expand one level' actions, wait for update() transitions
                        // to finish and then apply an immediate recenter on desktop to avoid
                        // requiring multiple clicks; on small screens keep the animated centering.
                        if (smallScreen) {
                            try { centerAfterUpdate(deepest, { fraction: 1.0, duration: 360 }); } catch (e) { /* ignore */ }
                        } else {
                            setTimeout(() => { try { centerSmooth(deepest); } catch (e) { /* ignore */ } }, 380);
                        }
                    }
                } catch (e) { /* non-fatal */ }
                // Defensive: ensure the suppression is cleared if centering didn't run for some reason
                setTimeout(() => { suppressAutoEnsure = false; }, 700);
            }

            // Build expansion states from the original raw data
            expansionStates = buildExpansionStatesFromData(data);

            // Determine which state the current live root matches (so we can set the current index correctly)
            function findMatchingStateIndex() {
                const liveExpanded = new Set(root.descendants().filter(d => d.children && d.children.length > 0).map(nodeKey));
                if (!expansionStates || expansionStates.length === 0) return 0;
                if (expansionStates.length === 1) return 0;

                // Choose the state with the largest intersection with liveExpanded
                let bestIndex = 0;
                let bestScore = -1;
                for (let i = 0; i < expansionStates.length; i++) {
                    const s = expansionStates[i];
                    let common = 0;
                    s.forEach(k => { if (liveExpanded.has(k)) common++; });
                    if (common > bestScore) { bestScore = common; bestIndex = i; }
                }

                // If nothing matches (bestScore === 0), prefer the first-level state if it exists
                if (bestScore === 0 && expansionStates.length > 1) return Math.min(1, expansionStates.length - 1);
                return bestIndex;
            }

            currentExpansionIndex = findMatchingStateIndex();

            // COLLAPSE ONE LEVEL
            document.getElementById('collapseOneLevel').onclick = () => {
                if (expansionStates.length === 0) return;
                currentExpansionIndex = Math.max(0, currentExpansionIndex - 1);
                applyExpansionStateToLiveRoot(expansionStates[currentExpansionIndex]);
            };


            // // Collapse only visible nodes with children whose children are all leaves or collapsed
            // document.getElementById('collapseOneLevel').onclick = () => {
            //     // Find all visible nodes with children
            //     const candidates = root.descendants().filter(d => d.children && d.children.length > 0);
            //     // Only collapse those whose children are all leaves or already collapsed
            //     candidates.forEach(d => {
            //         const allChildrenAreLeavesOrCollapsed = d.children.every(
            //             c => !c.children || c.children.length === 0
            //         );
            //         if (allChildrenAreLeavesOrCollapsed) {
            //             collapse(d);
            //         }
            //     });
            //     update(root);
            // };

            // // Expand only hidden (collapsed) nodes whose hidden children are all leaves or collapsed
            // document.getElementById('expandOneLevel').onclick = () => {
            //     // Find all nodes that are currently collapsed (have _children)
            //     // const candidates = root.descendants().filter(d => d._children && d._children.length > 0);

            //     // Only expand those whose hidden children are all leaves or already collapsed
            //     candidates.forEach(d => {
            //         const allHiddenChildrenAreLeavesOrCollapsed = d._children.every(
            //             c => !c.children || c.children.length === 0
            //         );
            //         if (allHiddenChildrenAreLeavesOrCollapsed) {
            //             expand(d);  // assumes your expand(d) does: d.children = d._children; d._children = null;
            //         }
            //     });

            //     update(root);
            // };

            document.getElementById('expandOneLevel').onclick = () => {
                if (expansionStates.length === 0) return;
                currentExpansionIndex = Math.min(expansionStates.length - 1, currentExpansionIndex + 1);
                applyExpansionStateToLiveRoot(expansionStates[currentExpansionIndex]);
            };

            // By default, only root and first-level children are expanded
            update(root);
        }

        // Place helper at top-level scope so it's available everywhere
        // Ensure expand is defined at top-level scope before expandAllRecursive
        function collapse(d) {
            if (d.children) { d._children = d.children; d._children.forEach(collapse); d.children = null; }
        }
        function expand(d) {
            if (d._children) { d.children = d._children; d._children = null; }
        }
        function expandAllRecursive(d) {
            if (d._children) {
                expand(d);
                if (d.children) d.children.forEach(expandAllRecursive);
            } else if (d.children) {
                d.children.forEach(expandAllRecursive);
            }
        }

        init();

        // Dark mode toggle - single toggle in controls panel for all screen sizes
        const darkModeToggle = document.getElementById('darkModeToggle');
        // When theme changes while controls panel is open, immediately update its background/border
        function syncControlsPanelTheme() {
            try {
                const controlsEl = document.getElementById('controls');
                if (!controlsEl) return;
                // Consider it open if it has the open class or is displayed as flex
                const isOpen = controlsEl.classList.contains('open') || window.getComputedStyle(controlsEl).display === 'flex';
                if (!isOpen) return;
                const isDark = document.body.classList.contains('dark-mode');
                if (isDark) {
                    controlsEl.style.background = 'linear-gradient(90deg, rgba(0,191,174,0.08), rgba(0,116,217,0.08)), var(--panel-dark-translucent)';
                    controlsEl.style.color = 'var(--text-dark)';
                    controlsEl.style.border = '1px solid rgba(255,255,255,0.06)';
                } else {
                    controlsEl.style.background = 'linear-gradient(90deg, rgba(0,191,174,0.08), rgba(0,116,217,0.08)), var(--panel-light-translucent)';
                    controlsEl.style.color = '';
                    controlsEl.style.border = '1px solid rgba(0,0,0,0.06)';
                }
                controlsEl.style.backdropFilter = 'blur(10px) saturate(80%)';
            } catch (e) { /* non-fatal */ }
        }
        
        // Set initial state
        if (darkModeToggle) {
            darkModeToggle.checked = true;
            document.body.classList.add('dark-mode');
            
            // Add event listener
            darkModeToggle.addEventListener('change', function () {
                document.body.classList.toggle('dark-mode', darkModeToggle.checked);
                // If the controls panel is open, update its background immediately
                syncControlsPanelTheme();
            });
        }

        // Minimal Facts modal behavior
        (function () {
            const factsBtn = document.getElementById('factsAboutBtn');
            const modal = document.getElementById('factsModal');
            const closeBtn = modal && modal.querySelector('.modal-close');
            let lastFocused = null;

            function openModal() {
                if (!modal) return;
                lastFocused = document.activeElement;
                modal.classList.add('open');
                modal.setAttribute('aria-hidden', 'false');
                // ensure modal content is scrolled to top and focused so iOS doesn't
                // leave the dialog scrolled halfway underneath the browser chrome
                try {
                    const content = modal.querySelector('.modal-content');
                    if (content) {
                        content.scrollTop = 0;
                        // focus the content region (not the button) to avoid jumping
                        content.focus({ preventScroll: true });
                        // also move visual viewport to top of modal on next frame
                        requestAnimationFrame(() => { content.scrollIntoView({ block: 'start', behavior: 'instant' }); });
                    }
                } catch (e) { /* non-fatal */ }
                // focus first focusable inside modal (close button)
                if (closeBtn) closeBtn.focus();
                document.addEventListener('keydown', keyHandler);
            }
            function closeModal() {
                if (!modal) return;
                modal.classList.remove('open');
                modal.setAttribute('aria-hidden', 'true');
                document.removeEventListener('keydown', keyHandler);
                if (lastFocused && typeof lastFocused.focus === 'function') lastFocused.focus();
            }
            function keyHandler(e) {
                if (e.key === 'Escape') { closeModal(); }
                // simple focus trap: keep focus inside modal when open
                if (e.key === 'Tab' && modal.classList.contains('open')) {
                    const focusables = modal.querySelectorAll('a[href], button:not([disabled]), textarea, input, select');
                    if (!focusables || focusables.length === 0) { e.preventDefault(); return; }
                    const first = focusables[0];
                    const last = focusables[focusables.length - 1];
                    if (e.shiftKey && document.activeElement === first) { last.focus(); e.preventDefault(); }
                    else if (!e.shiftKey && document.activeElement === last) { first.focus(); e.preventDefault(); }
                }
            }
            if (factsBtn) factsBtn.addEventListener('click', openModal);
            if (closeBtn) closeBtn.addEventListener('click', closeModal);
            if (modal) modal.addEventListener('click', (e) => { if (e.target === modal) closeModal(); });
        })();
    </script>

    <!-- footer credit removed (moved into About modal) -->

</body>

</html>