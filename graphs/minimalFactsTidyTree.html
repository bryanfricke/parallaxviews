<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <title>Tidy Tree</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
        #topbar {
            display: flex;
            align-items: center;
            gap: 16px;
            padding: 8px 24px;
            background: var(--bg-light);
            border-bottom: 1px solid #e0e0e0;
            min-height: 48px;
        }
        body.dark-mode #topbar {
            background: var(--bg-dark);
            border-bottom: 1px solid var(--link-dark);
        }
        #topbar label, #topbar button {
            margin: 0 4px;
        }
        #topbar label {
            font-weight: 500;
            color: inherit;
            display: flex;
            align-items: center;
            gap: 4px;
        }
        #topbar button {
            background: linear-gradient(90deg, #00BFAE 0%, #0074d9 100%);
            color: #fff;
            border: none;
            border-radius: 6px;
            padding: 8px 14px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0,0,0,0.06);
            transition: background 0.2s, box-shadow 0.2s, color 0.2s;
        }
        #topbar button:hover, #topbar button:focus {
            background: linear-gradient(90deg, #00E6B2 0%, #005fa3 100%);
            color: #fff;
            box-shadow: 0 4px 16px rgba(0,0,0,0.10);
        }
        body.dark-mode #topbar button {
            background: linear-gradient(90deg, var(--accent-dark) 0%, #005fa3 100%);
            color: var(--text-dark);
        }
        body.dark-mode #topbar button:hover, body.dark-mode #topbar button:focus {
            background: linear-gradient(90deg, var(--node-hover-stroke-dark) 0%, #003d5c 100%);
            color: var(--text-dark);
        }
        #topbar input[type="checkbox"] {
            accent-color: #00BFAE;
            width: 16px;
            height: 16px;
            margin-right: 4px;
        }
        body.dark-mode #topbar input[type="checkbox"] {
            accent-color: var(--accent-dark);
        }
        #topbar > * {
            margin-right: 8px;
        }
        #topbar > *:last-child {
            margin-right: 0;
        }
        :root {
            --bg-light: #fff;
            --bg-dark: #181A20;
            --panel-dark: #23272F;
            --node-fill-dark: #263238;
            --node-stroke-dark: #00BFAE;
            --node-hover-fill-dark: #374151;
            --node-hover-stroke-dark: #00E6B2;
            --link-dark: #3B4252;
            --text-dark: #E0E7EF;
            --text-secondary-dark: #A0AEC0;
            --accent-dark: #00BFAE;
            --tooltip-bg-dark: #23272F;
            --tooltip-border-dark: #00BFAE;
        }

        body {
            margin: 0;
            font: 14px/1.4 system-ui, sans-serif;
            overflow: hidden;
            background: var(--bg-light);
            color: #222;
            transition: background 0.3s, color 0.3s;
        }

        body.dark-mode {
            background: var(--bg-dark);
            color: var(--text-dark);
        }

        body.dark-mode #topbar {
            background: var(--bg-dark);
            border-bottom: 1px solid var(--link-dark);
            color: var(--text-dark);
        }

        #chart {
            width: 100vw;
            height: calc(100vh - 48px);
            overflow: hidden;
            background: var(--bg-light);
        }

        body.dark-mode #chart {
            background: var(--bg-dark);
        }

        svg {
            width: 100%;
            height: 100%;
            display: block;
            background: transparent;
            touch-action: none; /* allow d3-zoom to handle gestures on mobile */
        }

        /* Small-screen adjustments */
        @media (max-width: 600px) {
            #topbar {
                flex-wrap: wrap;
                gap: 8px;
                padding: 8px 12px;
                overflow-x: auto; /* allow horizontal scroll if too many controls */
                -webkit-overflow-scrolling: touch;
            }
            #topbar button { min-width: 110px; }
            #topbar > * { margin-right: 8px; }
            #topbar strong { font-size: 16px; }
            #topbar button {
                padding: 8px 10px;
                font-size: 15px;
                min-height: 40px;
            }
            .tooltip, .popup-help {
                max-width: calc(100vw - 24px);
                font-size: 15px;
                padding: 10px;
            }
            .esv-credit {
                left: 8px;
                right: 8px;
                bottom: 8px;
                max-width: none;
                font-size: 12px;
            }
        }

        .link {
            fill: none;
            stroke: #ccc;
            stroke-width: 1.5px;
        }

        body.dark-mode .link {
            stroke: var(--link-dark);
        }

        .node circle {
            r: 5;
            cursor: pointer;
            stroke: #333;
            stroke-width: 1px;
            fill: #fff;
            transition: fill 0.2s, stroke 0.2s;
        }

        .node circle {
            fill: #e0f7fa;
            stroke: #00796b;
        }

        body.dark-mode .node circle {
            fill: var(--node-fill-dark);
            stroke: var(--node-stroke-dark);
        }

        .node:hover circle {
            fill: #b2ebf2;
            stroke: #004d40;
        }

        body.dark-mode .node:hover circle {
            fill: var(--node-hover-fill-dark);
            stroke: var(--node-hover-stroke-dark);
        }

        .node text {
            font-size: 12px;
            dominant-baseline: middle;
            paint-order: stroke;
            stroke: #fff;
            stroke-width: 4px;
            stroke-linejoin: round;
        }

        .node text tspan {
            paint-order: stroke;
            stroke: #fff;
            stroke-width: 4px;
            stroke-linejoin: round;
        }

        .node text .label {
            fill: #222;
            stroke: none;
        }

        body.dark-mode .node text {
            fill: var(--text-dark) !important;
            stroke: var(--bg-dark) !important;
        }

        body.dark-mode .node text .label {
            fill: var(--text-dark) !important;
            stroke: none !important;
        }

        .tooltip {
            position: fixed;
            pointer-events: auto;
            background: #fff;
            border: 1px solid #ddd;
            padding: 8px 10px;
            border-radius: 6px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, .08);
            max-width: 320px;
            font-size: 13px;
            z-index: 1000;
        }

        .popup-help {
            position: fixed;
            pointer-events: auto;
            background: #fff;
            border: 1px solid #ddd;
            padding: 8px 10px;
            border-radius: 6px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, .08);
            max-width: 320px;
            font-size: 13px;
            z-index: 1001;
        }

        body.dark-mode .tooltip,
        body.dark-mode .popup-help {
            background: var(--tooltip-bg-dark) !important;
            border: 1px solid var(--tooltip-border-dark) !important;
            color: var(--text-dark) !important;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.32) !important;
        }

        body.dark-mode .tooltip a,
        body.dark-mode .popup-help a {
            color: var(--accent-dark) !important;
            text-decoration: underline;
        }

        body.dark-mode .tooltip a:hover,
        body.dark-mode .popup-help a:hover {
            color: var(--node-hover-stroke-dark) !important;
        }

        .node.clickable text {
            fill: #0074d9;
            cursor: pointer;
            text-decoration: none;
        }

        .node.clickable:hover text {
            fill: #005fa3;
            text-decoration: none;
        }
        /* ESV credit footnote (small, unobtrusive, respects dark mode) */
        .esv-credit {
            position: fixed;
            left: 12px;
            bottom: 8px;
            z-index: 2000;
            font-size: 12px;
            line-height: 1.2;
            padding: 6px 8px;
            border-radius: 6px;
            background: rgba(255,255,255,0.92);
            color: #333;
            border: 1px solid #e6e6e6;
            opacity: 0.95;
            pointer-events: none;
            max-width: calc(100vw - 40px);
        }

        body.dark-mode .esv-credit {
            background: rgba(24,26,32,0.7);
            color: var(--text-secondary-dark);
            border: 1px solid rgba(255,255,255,0.04);
        }
    </style>
</head>

<body class="dark-mode">
    <div id="topbar">
        <strong style="font-size:18px; letter-spacing:0.5px; margin-right:16px;">Tidy Tree</strong>
        <label style="display:none;"><input type="checkbox" id="wrap"> Wrap labels</label>
        <label><input type="checkbox" id="clusterToggle"> Cluster layout</label>
        <label style="display:none;">Node size: <input type="range" id="nodesize" min="10" max="100" value="20"></label>
        <label style="display:none;">Vertical spacing: <input type="range" id="nodesizeY" min="10" max="150" value="60"></label>
        <label style="display:none;">Horizontal spacing: <input type="range" id="nodesizeX" min="10" max="300" value="180"></label>
        <button id="collapseAll">Collapse All</button>
        <button id="expandAll">Expand All</button>
        <button id="collapseOneLevel">Collapse One Level</button>
        <button id="expandOneLevel">Expand One Level</button>
        <label style="margin-left:auto;"><input type="checkbox" id="darkModeToggle"> Dark mode</label>
    </div>
    <div id="chart"></div>

    <!-- D3 v7 -->
    <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
    <script>
        async function init() {
            let response = await fetch('data/ResurrectionDisciplesBelievedItActs01.json');
            let data = await response.json();

            // === 2) Basic settings ===
            const container = document.getElementById('chart');
            let width = container.clientWidth;
            let height = container.clientHeight;

            const svg = d3.select("#chart").append("svg")
                .attr("width", width).attr("height", height)
                .attr('role', 'img')
                .attr('aria-label', 'Tidy tree visualization');

            // Create a main group for zoom/pan
            const g = svg.append("g");
            // Create links and nodes groups in correct order
            const linkGroup = g.append("g").attr("class", "links");
            const nodeGroup = g.append("g").attr("class", "nodes");

            // allow broader zoom on touch devices for easier pinch-zooming
            const zoom = d3.zoom().scaleExtent([0.3, 4]).on("zoom", (event) => {
                g.attr("transform", event.transform);
                updatePopupHelpPosition();
            });
            svg.call(zoom);

            // Handle resizing: keep SVG sized to container and re-layout tree
            function resizeHandler() {
                width = container.clientWidth;
                height = container.clientHeight;
                svg.attr('width', width).attr('height', height);
                // Recompute layout origin so root remains roughly centered vertically
                if (root) {
                    root.x0 = height / 2;
                }
                update(root);
                // Maintain a sensible transform after resize
                const currentTransform = d3.zoomTransform(svg.node());
                // if transform is identity, re-center root
                if (currentTransform.k === 1 && Math.abs(currentTransform.x) < 1 && Math.abs(currentTransform.y) < 1) {
                    svg.call(zoom.transform, d3.zoomIdentity.translate(Math.min(220, width * 0.25), height / 2).scale(1));
                }
            }

            // Debounced resize
            let resizeTimer = null;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimer);
                resizeTimer = setTimeout(resizeHandler, 150);
            });


            const tooltip = d3.select("body").append("div")
                .attr("class", "tooltip").style("opacity", 0);
            // Add a separate popup help element
            const popupHelp = d3.select("body").append("div")
                .attr("class", "popup-help").style("opacity", 0).style("position", "fixed");

            // Helper to clamp a fixed-position element to the viewport (keeps a small margin)
            function clampToViewport(sel, desiredLeft, desiredTop) {
                const el = sel.node();
                const margin = 8;
                if (!el) return { left: desiredLeft, top: desiredTop };
                // Temporarily set to desired position so getBoundingClientRect reports correct size
                sel.style('left', desiredLeft + 'px').style('top', desiredTop + 'px');
                const rect = el.getBoundingClientRect();
                const maxTop = Math.max(margin, window.innerHeight - rect.height - margin);
                const maxLeft = Math.max(margin, window.innerWidth - rect.width - margin);
                const left = Math.min(Math.max(desiredLeft, margin), maxLeft);
                const top = Math.min(Math.max(desiredTop, margin), maxTop);
                sel.style('left', left + 'px').style('top', top + 'px');
                return { left, top };
            }

            // Minimal robust popup help tracking
            let popupHelpNode = null;

            function updatePopupHelpPosition() {
                if (!popupHelpNode) return;
                // Use tree layout coordinates
                let x = popupHelpNode.x;
                let y = popupHelpNode.y;
                // Get current transform
                const transform = d3.zoomTransform(svg.node());
                // Apply D3 transform to node coordinates
                const transformed = transform.apply([y, x]);
                // Convert SVG coordinates to screen coordinates
                const point = svg.node().createSVGPoint();
                point.x = transformed[0];
                point.y = transformed[1];
                const ctm = svg.node().getScreenCTM();
                if (ctm) {
                    const screenPoint = point.matrixTransform(ctm);
                    // Calculate desired position with offset
                    const desiredLeft = screenPoint.x + 24;
                    const desiredTop = screenPoint.y + 24;
                    // Clamp to viewport so popup doesn't go below the bottom (or off the right)
                    const popupEl = popupHelp.node();
                    if (popupEl) {
                        const rect = popupEl.getBoundingClientRect();
                        const margin = 8;
                        const maxTop = Math.max(margin, window.innerHeight - rect.height - margin);
                        const maxLeft = Math.max(margin, window.innerWidth - rect.width - margin);
                        const left = Math.min(Math.max(desiredLeft, margin), maxLeft);
                        const top = Math.min(Math.max(desiredTop, margin), maxTop);
                        popupHelp.style("left", left + "px").style("top", top + "px");
                    } else {
                        popupHelp.style("left", (screenPoint.x + 24) + "px").style("top", (screenPoint.y + 24) + "px");
                    }
                }
            }

            // Collapsible tree helpers
            function collapse(d) {
                if (d.children) { d._children = d.children; d._children.forEach(collapse); d.children = null; }
            }
            function expand(d) {
                if (d._children) { d.children = d._children; d._children = null; }
            }

            const root = d3.hierarchy(data);
            root.x0 = height / 2;
            root.y0 = 0;
            // Collapse the 'Death', 'Burial', and 'Resurrection' nodes themselves so only those are visible under the root
            if (root.children) {
                root.children.forEach(child => {
                    if (["Death", "Burial", "Resurrection"].includes(child.data.name)) {
                        collapse(child);
                    } else {
                        collapse(child);
                    }
                });
            }

            // Default to cluster layout
            let treeLayout = d3.cluster();
            // initial nodeSize will be set from the UI controls below so spacing matches the visible defaults

            // Controls
            const nodeSizeYInput = document.getElementById('nodesizeY');
            const nodeSizeXInput = document.getElementById('nodesizeX');
            nodeSizeYInput.addEventListener('input', updateNodeSize);
            nodeSizeXInput.addEventListener('input', updateNodeSize);
            function updateNodeSize() {
                const y = +nodeSizeYInput.value;
                const x = +nodeSizeXInput.value;
                treeLayout.nodeSize([y, x]);
                update(root);
            }
            // const tree = d3.tree().nodeSize([120, 200]); // vertical spacing, horizontal spacing

            const nodeSizeInput = document.getElementById('nodesize');
            nodeSizeInput.addEventListener('input', () => {
                const v = +nodeSizeInput.value;
                treeLayout.nodeSize([v, v + 80]);
                update(root);
            });
            const wrapToggle = document.getElementById('wrap');

            // Initialize layout sizing to the denser defaults used previously
            const initialVertical = 17; // vertical spacing (denser)
            const initialHorizontal = 200; // horizontal spacing
            // Sync hidden UI controls to reflect these defaults so toggling preserves expected spacing
            if (nodeSizeYInput) nodeSizeYInput.value = initialVertical;
            if (nodeSizeXInput) nodeSizeXInput.value = initialHorizontal;
            if (nodeSizeInput) nodeSizeInput.value = initialVertical;
            treeLayout.nodeSize([initialVertical, initialHorizontal]);

            // Cluster toggle: set up once (not inside update) so it isn't reset on every render
            const clusterToggle = document.getElementById('clusterToggle');
            // Default to cluster layout (matches initial treeLayout)
            clusterToggle.checked = true;
            clusterToggle.addEventListener('change', function () {
                if (clusterToggle.checked) {
                    treeLayout = d3.cluster();
                } else {
                    treeLayout = d3.tree();
                }
                // Keep node size settings
                const y = +nodeSizeYInput.value;
                const x = +nodeSizeXInput.value;
                treeLayout.nodeSize([y, x]);
                update(root);
            });

            // Word wrap helper
            function wrapText(selection, width = 160) {
                selection.each(function (d) {
                    const text = d3.select(this);
                    const words = (text.text() || "").split(/\s+/).reverse();
                    let line = [], lineNumber = 0;
                    // Set x based on node type
                    const x = (d.children || d._children) ? -10 : 10;
                    let tspan = text.text(null).append("tspan").attr("x", x).attr("dy", "0em");
                    let word, lineHeight = 1.1;
                    while (word = words.pop()) {
                        line.push(word);
                        tspan.text(line.join(" "));
                        if (tspan.node().getComputedTextLength() > width) {
                            line.pop();
                            tspan.text(line.join(" "));
                            line = [word];
                            tspan = text.append("tspan")
                                .attr("x", x)
                                .attr("dy", ++lineNumber * lineHeight + "em")
                                .text(word);
                        }
                    }
                });
            }

            // Color per node (inherit from ancestors if not set)
            function nodeColor(d) {
                let x = d;
                while (x) {
                    if (x.data && x.data.color) return x.data.color;
                    x = x.parent;
                }
                return "#6c6c6c";
            }

            function update(source) {
                treeLayout(root);
                const nodes = root.descendants();
                const links = root.links();
                // (cluster toggle is wired once at top-level to avoid being reset on each update)

                // nodes.forEach(d => d.y = d.depth * 180); // horizontal spacing per depth

                // LINKS (drawn first, behind nodes)
                const link = linkGroup.selectAll("path.link").data(links, d => d.target.id || (d.target.id = crypto.randomUUID()));
                link.enter().append("path")
                    .attr("class", "link")
                    .attr("d", d3.linkHorizontal().x(d => source.y0).y(d => source.x0))
                    .merge(link)
                    .transition().duration(350)
                    .attr("d", d3.linkHorizontal().x(d => d.y).y(d => d.x));
                link.exit().transition().duration(250)
                    .attr("d", d3.linkHorizontal().x(d => source.y).y(d => source.x))
                    .remove();

                // NODES (drawn above links)
                const node = nodeGroup.selectAll("g.node").data(nodes, d => d.id || (d.id = crypto.randomUUID()));

                const nodeEnter = node.enter().append("g")
                    .attr("class", d => {
                        if (!d.children && !d._children && d.data.source && d.data.source.url) {
                            return "node clickable";
                        }
                        return "node";
                    })
                    .attr("transform", d => `translate(${source.y0},${source.x0})`)
                    .on("pointerdown", (event, d) => {
                        // Normalize pointerdown for taps vs clicks. We still treat it like a click handler.
                        if (!d.children && !d._children && d.data.source && d.data.source.url) {
                            let html = `<strong>${d.data.name}</strong>`;
                            if (d.data.date) html += `<div style='margin-top:4px; font-weight:bold;'>${d.data.date}</div>`;
                            if (d.data.details) html += `<div style='margin-top:6px;'>${d.data.details}</div>`;
                            html += `<div style='margin-top:10px;'><a href='${d.data.source.url}' target='_blank' style='color:blue;text-decoration:underline;'>${d.data.source.title || "View Source"}</a></div>`;
                                    popupHelp.html(html)
                                        .style("opacity", 1)
                                        .style("pointer-events", "auto");
                                    popupHelpNode = d;
                                    updatePopupHelpPosition();
                            setTimeout(() => {
                                document.addEventListener('mousedown', popupHelpOutsideClickHandler, true);
                            }, 0);
                        } else {
                            if (!d.children && d._children) {
                                expand(d);
                                if (d.children) d.children.forEach(expandAllRecursive);
                            } else {
                                collapse(d);
                            }
                            update(d);
                            popupHelp.style("opacity", 0)
                                .style("pointer-events", "none");
                            document.removeEventListener('mousedown', popupHelpOutsideClickHandler, true);
                            popupHelpNode = null;
                        }
                    })
                    .on("pointerenter", (event, d) => {
                        // show subtitle on hover/enter (pointer-aware)
                        const txt = d.data.subtitle || "";
                        if (!txt) return;
                        tooltip.html(txt)
                            .style("opacity", 1)
                            .style("pointer-events", "none");
                        clampToViewport(tooltip, event.clientX + 24, event.clientY + 24);
                    })
                    .on("pointermove", (event) => {
                        clampToViewport(tooltip, event.clientX + 24, event.clientY + 24);
                    })
                    .on("pointerleave", () => {
                        tooltip.style("opacity", 0);
                    });
                // Remove mouseleave handler so tooltip doesn't disappear immediately

                // Helper to hide popup help only when clicking outside
                function popupHelpOutsideClickHandler(e) {
                    const popupEl = popupHelp.node();
                    if (popupHelp.style("opacity") === "1" && (!popupEl || (e.target !== popupEl && !popupEl.contains(e.target)))) {
                        popupHelp.style("opacity", 0)
                            .style("pointer-events", "none");
                        document.removeEventListener('mousedown', popupHelpOutsideClickHandler, true);
                        // Quickfix: dispatch mouseleave to node under popup
                        if (popupHelpNode) {
                            // Find the corresponding SVG node group
                            const nodeGroup = d3.selectAll('g.node').filter(d => d === popupHelpNode);
                            nodeGroup.select('text').each(function () {
                                const evt = new MouseEvent('mouseleave', { bubbles: true });
                                this.dispatchEvent(evt);
                            });
                        }
                        popupHelpNode = null;
                    }
                }

                // Adjust node radius for small touch screens to improve tap targets
                const isSmall = window.matchMedia && window.matchMedia('(max-width: 600px)').matches;
                const targetRadius = isSmall ? 8 : 6;

                nodeEnter.append("circle")
                    .attr("r", 1e-6)
                    .attr("fill", d => (d._children ? nodeColor(d) : "#fff"))
                    .attr("stroke", d => nodeColor(d));

                const labels = nodeEnter.append("text")
                    .attr("dy", "0em")
                    .attr("x", d => (d.children || d._children) ? -10 : 10)
                    .attr("text-anchor", d => (d.children || d._children) ? "end" : "start")
                    .html(d => d.data.link
                        ? `<a href="${d.data.link}" target="_blank" style="fill:blue;text-decoration:underline">${d.data.name}</a>`
                        : d.data.name);

                function applyLabelWrapping() {
                    g.selectAll("g.node text").each(function (d) {
                        const text = d3.select(this);
                        text.text(d.data.name);
                        if (wrapToggle.checked) wrapText(text, 160);
                    });
                }
                applyLabelWrapping();
                wrapToggle.onchange = applyLabelWrapping;

                // UPDATE + TRANSITIONS
                const nodeUpdate = nodeEnter.merge(node);
                nodeUpdate.transition().duration(350)
                    .attr("transform", d => `translate(${d.y},${d.x})`)
                    .on("end", () => { updatePopupHelpPosition(); });
                nodeUpdate.select("circle").transition().duration(350)
                    .attr("r", targetRadius)
                    .attr("fill", d => (d._children ? nodeColor(d) : "#fff"))
                    .attr("stroke", d => nodeColor(d));
                nodeUpdate.select("text").transition().duration(350)
                    .attr("x", d => (d.children || d._children) ? -10 : 10)
                    .attr("text-anchor", d => (d.children || d._children) ? "end" : "start");

                const nodeExit = node.exit().transition().duration(250)
                    .attr("transform", d => `translate(${source.y},${source.x})`)
                    .remove();
                nodeExit.select("circle").attr("r", 1e-6);

                // Stash positions for smooth transitions next time
                nodes.forEach(d => { d.x0 = d.x; d.y0 = d.y; });
            }

            update(root);

            // Center root nicely
            // Shift right so root node is visible
            svg.call(zoom.transform, d3.zoomIdentity.translate(220, height / 2).scale(1));

            // Collapse or expand all nodes
            function collapseAll(d) {
                if (d.children) {
                    d.children.forEach(collapseAll);
                    collapse(d);
                }
            }
            function expandAll(d) {
                if (d._children) {
                    expand(d);
                    d.children.forEach(expandAll);
                } else if (d.children) {
                    d.children.forEach(expandAll);
                }
            }

            document.getElementById('collapseAll').onclick = () => {
                root.children && root.children.forEach(collapseAll);
                update(root);
                // update tracked index
                currentExpansionIndex = findMatchingStateIndex();
            };
            document.getElementById('expandAll').onclick = () => {
                root.children && root.children.forEach(expandAll);
                update(root);
                // update tracked index
                currentExpansionIndex = findMatchingStateIndex();
            };

            // State machine for one-level expand/collapse
            // We'll precompute a list of expansion "states" (sets of node keys that are expanded)
            // starting from root-only up to fully-expanded. Then collapse/expand one level
            // simply moves the current index and applies the corresponding state to the live tree.

            // Helper to get a stable key for a node: use the ancestor path (ids or names) so
            // keys are stable and unique across simulated and live hierarchies.
            function nodeKey(d) {
                // build path from root -> ... -> node using data.id if present, otherwise data.name
                try {
                    const parts = d.ancestors().reverse().map(n => (n.data && (n.data.id ?? n.data.name)) || '').filter(Boolean);
                    return parts.join('/');
                } catch (e) {
                    // fallback for nodes that don't support ancestors(): use name or id
                    return d.data?.id ?? d.data?.name ?? d.id ?? String(d);
                }
            }

            let expansionStates = []; // array of Set(nodeKey) from root-only (index 0) to fully-expanded (last)
            let currentExpansionIndex = 1; // default to first level beyond root

            // Build simulated collapse sequence from fully expanded down to root-only, then reverse it.
            function buildExpansionStatesFromData(rawData) {
                // Use a deep-cloned hierarchy so we don't touch the live `root`
                const simRoot = d3.hierarchy(JSON.parse(JSON.stringify(rawData)));

                function getExpandedKeys(n) {
                    return new Set(n.descendants().filter(d => d.children && d.children.length > 0).map(nodeKey));
                }

                const states = [];
                // Start with fully expanded state
                states.push(getExpandedKeys(simRoot));

                // Simulate repeated "collapse one level" operations until nothing left to collapse
                while (true) {
                    const candidates = simRoot.descendants().filter(d => d.children && d.children.length > 0);
                    if (candidates.length === 0) break;
                    const toCollapse = candidates.filter(d => d.children.every(c => !c.children || c.children.length === 0));
                    if (toCollapse.length === 0) break;
                    toCollapse.forEach(d => { d._children = d.children; d.children = null; });
                    states.push(getExpandedKeys(simRoot));
                }

                // states currently goes from fully-expanded -> ... -> root-only, reverse it
                return states.reverse();
            }

            // Apply an expansion state (set of node keys that should be expanded) to the live `root`
            function applyExpansionStateToLiveRoot(expandedSet) {
                root.descendants().forEach(d => {
                    const key = nodeKey(d);
                    if (expandedSet.has(key)) {
                        if (d._children) { d.children = d._children; d._children = null; }
                        // if it already has children do nothing
                    } else {
                        if (d.children) { d._children = d.children; d.children = null; }
                    }
                });
                update(root);
            }

            // Build expansion states from the original raw data
            expansionStates = buildExpansionStatesFromData(data);

            // Determine which state the current live root matches (so we can set the current index correctly)
            function findMatchingStateIndex() {
                const liveExpanded = new Set(root.descendants().filter(d => d.children && d.children.length > 0).map(nodeKey));
                if (!expansionStates || expansionStates.length === 0) return 0;
                if (expansionStates.length === 1) return 0;

                // Choose the state with the largest intersection with liveExpanded
                let bestIndex = 0;
                let bestScore = -1;
                for (let i = 0; i < expansionStates.length; i++) {
                    const s = expansionStates[i];
                    let common = 0;
                    s.forEach(k => { if (liveExpanded.has(k)) common++; });
                    if (common > bestScore) { bestScore = common; bestIndex = i; }
                }

                // If nothing matches (bestScore === 0), prefer the first-level state if it exists
                if (bestScore === 0 && expansionStates.length > 1) return Math.min(1, expansionStates.length - 1);
                return bestIndex;
            }

            currentExpansionIndex = findMatchingStateIndex();

            // COLLAPSE ONE LEVEL
            document.getElementById('collapseOneLevel').onclick = () => {
                if (expansionStates.length === 0) return;
                currentExpansionIndex = Math.max(0, currentExpansionIndex - 1);
                applyExpansionStateToLiveRoot(expansionStates[currentExpansionIndex]);
            };


            // // Collapse only visible nodes with children whose children are all leaves or collapsed
            // document.getElementById('collapseOneLevel').onclick = () => {
            //     // Find all visible nodes with children
            //     const candidates = root.descendants().filter(d => d.children && d.children.length > 0);
            //     // Only collapse those whose children are all leaves or already collapsed
            //     candidates.forEach(d => {
            //         const allChildrenAreLeavesOrCollapsed = d.children.every(
            //             c => !c.children || c.children.length === 0
            //         );
            //         if (allChildrenAreLeavesOrCollapsed) {
            //             collapse(d);
            //         }
            //     });
            //     update(root);
            // };

            // // Expand only hidden (collapsed) nodes whose hidden children are all leaves or collapsed
            // document.getElementById('expandOneLevel').onclick = () => {
            //     // Find all nodes that are currently collapsed (have _children)
            //     // const candidates = root.descendants().filter(d => d._children && d._children.length > 0);

            //     // Only expand those whose hidden children are all leaves or already collapsed
            //     candidates.forEach(d => {
            //         const allHiddenChildrenAreLeavesOrCollapsed = d._children.every(
            //             c => !c.children || c.children.length === 0
            //         );
            //         if (allHiddenChildrenAreLeavesOrCollapsed) {
            //             expand(d);  // assumes your expand(d) does: d.children = d._children; d._children = null;
            //         }
            //     });

            //     update(root);
            // };

            document.getElementById('expandOneLevel').onclick = () => {
                if (expansionStates.length === 0) return;
                currentExpansionIndex = Math.min(expansionStates.length - 1, currentExpansionIndex + 1);
                applyExpansionStateToLiveRoot(expansionStates[currentExpansionIndex]);
            };

            // By default, only root and first-level children are expanded
            update(root);
        }

        // Place helper at top-level scope so it's available everywhere
        // Ensure expand is defined at top-level scope before expandAllRecursive
        function collapse(d) {
            if (d.children) { d._children = d.children; d._children.forEach(collapse); d.children = null; }
        }
        function expand(d) {
            if (d._children) { d.children = d._children; d._children = null; }
        }
        function expandAllRecursive(d) {
            if (d._children) {
                expand(d);
                if (d.children) d.children.forEach(expandAllRecursive);
            } else if (d.children) {
                d.children.forEach(expandAllRecursive);
            }
        }

        init();

        // Dark mode toggle
        const darkModeToggle = document.getElementById('darkModeToggle');
        darkModeToggle.checked = true;
        document.body.classList.add('dark-mode');
        darkModeToggle.addEventListener('change', function () {
            document.body.classList.toggle('dark-mode', darkModeToggle.checked);
        });
    </script>

    <!-- ESV credit: Crossway recommended short credit for using ESV text -->
    <div class="esv-credit" aria-hidden="true">
        <div>Scripture quotations are from the ESV® Bible (The Holy Bible, English Standard Version®), copyright © 2001, 2007, 2011, 2016 by Crossway. Used by permission. All rights reserved.</div>
    <div>The "Minimal Facts" approach is adapted from: Gary R. Habermas and Michael R. Licona, <em>The Case for the Resurrection of Jesus</em> (B&amp;H Academic, 2004).</div>
    </div>

</body>

</html>