<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <title>Tidy Tree</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
        #topbar {
            display: flex;
            align-items: center;
            gap: 16px;
            padding: 8px 24px;
            background: var(--bg-light);
            border-bottom: 1px solid #e0e0e0;
            min-height: 48px;
        }
        body.dark-mode #topbar {
            background: var(--bg-dark);
            border-bottom: 1px solid var(--link-dark);
        }
        #topbar label, #topbar button {
            margin: 0 4px;
        }
        #topbar label {
            font-weight: 500;
            color: inherit;
            display: flex;
            align-items: center;
            gap: 4px;
        }
        #topbar button {
            background: linear-gradient(90deg, #00BFAE 0%, #0074d9 100%);
            color: #fff;
            border: none;
            border-radius: 6px;
            padding: 8px 14px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0,0,0,0.06);
            transition: background 0.2s, box-shadow 0.2s, color 0.2s;
        }
        #topbar button:hover, #topbar button:focus {
            background: linear-gradient(90deg, #00E6B2 0%, #005fa3 100%);
            color: #fff;
            box-shadow: 0 4px 16px rgba(0,0,0,0.10);
        }
        body.dark-mode #topbar button {
            background: linear-gradient(90deg, var(--accent-dark) 0%, #005fa3 100%);
            color: var(--text-dark);
        }
        body.dark-mode #topbar button:hover, body.dark-mode #topbar button:focus {
            background: linear-gradient(90deg, var(--node-hover-stroke-dark) 0%, #003d5c 100%);
            color: var(--text-dark);
        }
        #topbar input[type="checkbox"] {
            accent-color: #00BFAE;
            width: 16px;
            height: 16px;
            margin-right: 4px;
        }
        body.dark-mode #topbar input[type="checkbox"] {
            accent-color: var(--accent-dark);
        }
        #topbar > * {
            margin-right: 8px;
        }
        #topbar > *:last-child {
            margin-right: 0;
        }
        :root {
            --bg-light: #fff;
            --bg-dark: #181A20;
            --panel-dark: #23272F;
            --node-fill-dark: #263238;
            --node-stroke-dark: #00BFAE;
            --node-hover-fill-dark: #374151;
            --node-hover-stroke-dark: #00E6B2;
            --link-dark: #3B4252;
            --text-dark: #E0E7EF;
            --text-secondary-dark: #A0AEC0;
            --accent-dark: #00BFAE;
            --tooltip-bg-dark: #23272F;
            --tooltip-border-dark: #00BFAE;
        }

        body {
            margin: 0;
            font: 14px/1.4 system-ui, sans-serif;
            overflow: hidden;
            background: var(--bg-light);
            color: #222;
            transition: background 0.3s, color 0.3s;
        }

        body.dark-mode {
            background: var(--bg-dark);
            color: var(--text-dark);
        }

        body.dark-mode #topbar {
            background: var(--bg-dark);
            border-bottom: 1px solid var(--link-dark);
            color: var(--text-dark);
        }

        #chart {
            width: 100vw;
            height: calc(100vh - 48px);
            overflow: hidden;
            background: var(--bg-light);
        }

        body.dark-mode #chart {
            background: var(--bg-dark);
        }

        svg {
            width: 100%;
            height: 100%;
            display: block;
            background: transparent;
            touch-action: none; /* allow d3-zoom to handle gestures on mobile */
        }

        /* Small-screen adjustments */
        @media (max-width: 600px) {
            #topbar {
                flex-wrap: wrap;
                gap: 8px;
                padding: 8px 12px;
                overflow-x: auto; /* allow horizontal scroll if too many controls */
                -webkit-overflow-scrolling: touch;
            }
            #topbar button { min-width: 110px; }
            #topbar > * { margin-right: 8px; }
            #topbar strong { font-size: 16px; }
            #topbar button {
                padding: 8px 10px;
                font-size: 15px;
                min-height: 40px;
            }
            .tooltip, .popup-help {
                max-width: calc(100vw - 24px);
                font-size: 15px;
                padding: 10px;
            }
            .esv-credit {
                left: 8px;
                right: 8px;
                bottom: 8px;
                max-width: none;
                font-size: 12px;
            }
            /* hide the footer on small screens to avoid overlaying the chart and bottom-sheet */
            .esv-credit { display: none; }
            /* Controls toggle and bottom-sheet */
            /* make toggle fixed so it doesn't get scrolled/hidden on small screens */
            #controlsToggle { display: inline-block !important; position: fixed !important; left: 12px; top: calc(env(safe-area-inset-top, 0px) + 8px); z-index: 9000; }
            #controls { display: none; width: 100%; }
            #controls.open { display: flex; flex-wrap: wrap; gap: 8px; }
            .bottom-sheet { background: var(--bg-dark); color: var(--text-dark); }
            /* when JS positions the controls as fixed, improve scrolling and backdrop */
            #controls[style] {
                -webkit-overflow-scrolling: touch;
                scrollbar-width: thin;
                background-clip: padding-box;
                backdrop-filter: blur(6px) saturate(80%);
            }
        }

        /* hide the large page title on small screens (we show controls instead) */
        @media (max-width: 600px) {
            #topbar strong { display: none; }
            /* compact mobile controls panel will be positioned by JS to avoid overlapping the divider */
        }

        /* keep topbar above floating bottom-sheet */
        #topbar { position: relative; z-index: 5000; }

        /* bottom-sheet base styles (works on all sizes but optimized for mobile) */
        .bottom-sheet {
            position: fixed;
            left: 0;
            right: 0;
            bottom: -100%;
            background: var(--bg-dark);
            color: var(--text-dark);
            border-top-left-radius: 12px;
            border-top-right-radius: 12px;
            box-shadow: 0 -8px 24px rgba(0,0,0,0.32);
            padding: 16px;
            z-index: 2500;
            transition: bottom 260ms ease;
            max-height: 70vh;
            overflow: auto;
        }
        .bottom-sheet.open { bottom: 0; }
        .bottom-sheet .close-btn {
            /* nudge the control slightly outside the rounded sheet so it doesn't overlap
               the first lines of content while remaining visually attached */
            position: absolute;
            right: -6px; /* move slightly outside */
            top: -6px;   /* lift above the sheet edge */
            background: rgba(0,0,0,0.12);
            border: none;
            color: var(--text-dark);
            font-size: 20px;
            padding: 6px;
            border-radius: 8px;
            cursor: pointer;
            min-width: 32px;
            min-height: 32px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.12);
        }

        /* Remove the iOS blue focus ring / highlight for the close button in the bottom sheet.
           Keep this narrowly scoped to the close button since focus rings are useful elsewhere
           for keyboard users. On touch devices the blue ring is visual noise. */
        .bottom-sheet .close-btn {
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            -webkit-tap-highlight-color: transparent;
        }
        /* Keep tappable appearance but do not show an additional glow on focus */
        .bottom-sheet .close-btn:focus {
            outline: none;
            box-shadow: none;
        }

        .link {
            fill: none;
            stroke: #ccc;
            stroke-width: 1.5px;
        }

        body.dark-mode .link {
            stroke: var(--link-dark);
        }

        .node circle {
            r: 5;
            cursor: pointer;
            stroke: #333;
            stroke-width: 1px;
            fill: #fff;
            transition: fill 0.2s, stroke 0.2s;
        }

        .node circle {
            fill: #e0f7fa;
            stroke: #00796b;
        }

        body.dark-mode .node circle {
            fill: var(--node-fill-dark);
            stroke: var(--node-stroke-dark);
        }

        .node:hover circle {
            fill: #b2ebf2;
            stroke: #004d40;
        }

        body.dark-mode .node:hover circle {
            fill: var(--node-hover-fill-dark);
            stroke: var(--node-hover-stroke-dark);
        }

        .node text {
            font-size: 12px;
            dominant-baseline: middle;
            paint-order: stroke;
            stroke: #fff;
            stroke-width: 4px;
            stroke-linejoin: round;
        }

        .node text tspan {
            paint-order: stroke;
            stroke: #fff;
            stroke-width: 4px;
            stroke-linejoin: round;
        }

        .node text .label {
            fill: #222;
            stroke: none;
        }

        body.dark-mode .node text {
            fill: var(--text-dark) !important;
            stroke: var(--bg-dark) !important;
        }

        body.dark-mode .node text .label {
            fill: var(--text-dark) !important;
            stroke: none !important;
        }

        .tooltip {
            position: fixed;
            pointer-events: auto;
            background: #fff;
            border: 1px solid #ddd;
            padding: 8px 10px;
            border-radius: 6px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, .08);
            max-width: 320px;
            font-size: 13px;
            z-index: 1000;
        }

        .popup-help {
            position: fixed;
            pointer-events: auto;
            background: #fff;
            border: 1px solid #ddd;
            padding: 8px 10px;
            border-radius: 6px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, .08);
            max-width: 320px;
            font-size: 13px;
            z-index: 1001;
        }

        body.dark-mode .tooltip,
        body.dark-mode .popup-help {
            background: var(--tooltip-bg-dark) !important;
            border: 1px solid var(--tooltip-border-dark) !important;
            color: var(--text-dark) !important;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.32) !important;
        }

        body.dark-mode .tooltip a,
        body.dark-mode .popup-help a {
            color: var(--accent-dark) !important;
            text-decoration: underline;
        }

        body.dark-mode .tooltip a:hover,
        body.dark-mode .popup-help a:hover {
            color: var(--node-hover-stroke-dark) !important;
        }

        .node.clickable text {
            fill: #0074d9;
            cursor: pointer;
            text-decoration: none;
        }

        .node.clickable:hover text {
            fill: #005fa3;
            text-decoration: none;
        }
        /* stronger visual ring for selected node (set via data-selected attribute) */
        g.node[data-selected="true"] circle {
            /* default (dark-mode friendly) selection ring */
            stroke: #00E6B2 !important;
            stroke-width: 2.6px !important;
            transition: stroke 180ms, stroke-width 180ms;
        }
        /* subtle halo around selected node group to increase contrast without changing fill (dark-mode) */
        g.node[data-selected="true"] {
            filter: drop-shadow(0 6px 10px rgba(0,230,178,0.06));
        }

        /* Light-mode specific selection styling: use a slightly darker, high-contrast ring
           and a faint cool-blue halo so the ring reads well on a white background. */
        body:not(.dark-mode) g.node[data-selected="true"] circle {
            stroke: #0074d9 !important; /* blue that matches other light-mode accents */
            stroke-width: 2.6px !important;
            transition: stroke 180ms, stroke-width 180ms;
        }
        body:not(.dark-mode) g.node[data-selected="true"] {
            filter: drop-shadow(0 6px 10px rgba(0,116,217,0.06));
        }
        /* ESV credit footnote (small, unobtrusive, respects dark mode) */
        .esv-credit {
            position: fixed;
            left: 12px;
            bottom: 8px;
            z-index: 2000;
            font-size: 12px;
            line-height: 1.2;
            padding: 6px 8px;
            border-radius: 6px;
            background: rgba(255,255,255,0.92);
            color: #333;
            border: 1px solid #e6e6e6;
            opacity: 0.95;
            pointer-events: none;
            max-width: calc(100vw - 40px);
        }

        body.dark-mode .esv-credit {
            background: rgba(24,26,32,0.7);
            color: var(--text-secondary-dark);
            border: 1px solid rgba(255,255,255,0.04);
        }
    </style>
</head>

<body class="dark-mode">
    <div id="topbar">
    <strong style="font-size:18px; letter-spacing:0.5px; margin-right:16px;">Tidy Tree</strong>
    <button id="controlsToggle" aria-expanded="false">Controls ▾</button>
        <div id="controls" style="display:flex; align-items:center; gap:12px;">
            <label style="display:none;"><input type="checkbox" id="wrap"> Wrap labels</label>
            <label><input type="checkbox" id="clusterToggle"> Cluster layout</label>
            <label style="display:none;">Node size: <input type="range" id="nodesize" min="10" max="100" value="20"></label>
            <label style="display:none;">Vertical spacing: <input type="range" id="nodesizeY" min="10" max="150" value="60"></label>
            <label style="display:none;">Horizontal spacing: <input type="range" id="nodesizeX" min="10" max="300" value="180"></label>
            <button id="collapseAll">Collapse All</button>
            <button id="expandAll">Expand All</button>
            <button id="collapseOneLevel">Collapse One Level</button>
            <button id="expandOneLevel">Expand One Level</button>
        </div>
        <label style="margin-left:auto;"><input type="checkbox" id="darkModeToggle"> Dark mode</label>
    </div>
    <div id="chart"></div>

    <!-- bottom sheet for mobile node details -->
    <div id="bottomSheet" class="bottom-sheet" role="dialog" aria-hidden="true"></div>

    <!-- D3 v7 -->
    <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
    <script>
        async function init() {
            let response = await fetch('data/ResurrectionDisciplesBelievedItActs01.json');
            let data = await response.json();

            // === 2) Basic settings ===
            const container = document.getElementById('chart');
            let width = container.clientWidth;
            let height = container.clientHeight;

                // Compute chart height based on topbar height so content isn't hidden under it on small screens
                function computeChartHeight() {
                    const topbar = document.getElementById('topbar');
                    const rect = topbar ? topbar.getBoundingClientRect() : { height: 48 };
                    const hh = Math.max(48, rect.height);
                    const chartEl = document.getElementById('chart');
                    chartEl.style.height = `calc(100vh - ${hh}px)`;
                    width = chartEl.clientWidth;
                    height = chartEl.clientHeight;
                    svg.attr('width', width).attr('height', height);
                }

                // Create bottom-sheet element for mobile node details
                const bottomSheet = document.getElementById('bottomSheet');
                function openBottomSheet(html, node) {
                    // hide other transient UI
                    tooltip.style('opacity', 0);
                    popupHelp.style('opacity', 0).style('pointer-events', 'none');
                    bottomSheet.innerHTML = `<button class="close-btn" aria-label="Close">×</button><div class="bottom-content">${html}</div>`;
                    bottomSheet.classList.add('open');
                    bottomSheet.setAttribute('aria-hidden', 'false');

                    // After the sheet is open, ensure the clicked node isn't obscured on small screens.
                    const isSmall = window.matchMedia && window.matchMedia('(max-width: 600px)').matches;
                    setTimeout(() => {
                        // scrollIntoView as before to bring sheet into view
                        bottomSheet.scrollIntoView({ behavior: 'smooth', block: 'end' });

                        // If a node was provided and we're on a small screen, check if it will be
                        // covered by the sheet. If so, pan the svg up so the node sits above the sheet.
                        if (isSmall && node && svg && typeof d3 !== 'undefined') {
                            try {
                                const sheetRect = bottomSheet.getBoundingClientRect();
                                const margin = 12; // spacing above sheet
                                // Compute node screen coords (similar to updatePopupHelpPosition)
                                const transform = d3.zoomTransform(svg.node());
                                const transformed = transform.apply([node.y, node.x]);
                                const point = svg.node().createSVGPoint();
                                point.x = transformed[0];
                                point.y = transformed[1];
                                const ctm = svg.node().getScreenCTM();
                                if (ctm) {
                                    const screenPoint = point.matrixTransform(ctm);
                                    const nodeScreenY = screenPoint.y;
                                    const availableTop = window.innerHeight - sheetRect.height - margin;
                                    if (nodeScreenY > availableTop) {
                                        const dy = availableTop - nodeScreenY; // negative value will move content up
                                        const newTransform = d3.zoomIdentity.translate(transform.x, transform.y + dy).scale(transform.k);
                                        svg.interrupt();
                                        svg.transition().duration(320).call(zoom.transform, newTransform);
                                    }
                                }
                            } catch (e) {
                                console.warn('openBottomSheet: failed to reposition for node visibility', e);
                            }
                        }

                        const btn = bottomSheet.querySelector('.close-btn');
                        if (btn) { btn.focus({ preventScroll: true }); btn.addEventListener('click', closeBottomSheet, { once: true }); }
                    }, 60);
                }
                function closeBottomSheet() {
                    bottomSheet.classList.remove('open');
                    bottomSheet.setAttribute('aria-hidden', 'true');
                }
                bottomSheet.addEventListener('click', (e)=>{
                    // allow clicking outside content to close if needed; a close button could be added
                    if (e.target === bottomSheet) closeBottomSheet();
                });

                // Controls toggle for small screens
                const controlsToggle = document.getElementById('controlsToggle');
                const controls = document.getElementById('controls');
                function updateControlsVisibility() {
                    const isSmall = window.matchMedia && window.matchMedia('(max-width: 600px)').matches;
                    // rely on CSS for toggle visibility to avoid inline style flashing
                    if (!isSmall) { controls.classList.add('open'); controls.style.display = 'flex'; }
                    else { controls.classList.remove('open'); controls.style.display = 'none'; }
                }
                controlsToggle.addEventListener('click', ()=>{
                    const open = controls.classList.toggle('open');
                    controls.style.display = open ? 'flex' : 'none';
                    controlsToggle.setAttribute('aria-expanded', open ? 'true' : 'false');
                    // position controls right below topbar on small screens
                    const isSmall = window.matchMedia && window.matchMedia('(max-width: 600px)').matches;
                    if (isSmall && open) {
                        // anchor the panel to the controls toggle so it appears directly under the button
                        const toggleRect = controlsToggle.getBoundingClientRect();
                        controls.style.position = 'fixed';
                        controls.style.left = Math.max(8, toggleRect.left) + 'px';
                        controls.style.top = (toggleRect.bottom + 6) + 'px';
                        controls.style.background = 'linear-gradient(90deg, rgba(0,191,174,0.04), rgba(0,116,217,0.04))';
                        controls.style.padding = '8px';
                        controls.style.borderRadius = '10px';
                        controls.style.boxShadow = '0 8px 24px rgba(0,0,0,0.4)';
                        controls.style.maxWidth = 'calc(100vw - 32px)';
                        // limit height so it doesn't sit on top of the tree; allow internal scrolling
                        controls.style.maxHeight = '38vh';
                        controls.style.overflow = 'auto';
                        controls.style.zIndex = 8600;
                    } else {
                        // reset inline positioning
                        controls.style.position = '';
                        controls.style.left = '';
                        controls.style.top = '';
                        controls.style.background = '';
                        controls.style.padding = '';
                        controls.style.borderRadius = '';
                        controls.style.boxShadow = '';
                        controls.style.maxWidth = '';
                        controls.style.zIndex = '';
                    }
                });
                updateControlsVisibility();

            const svg = d3.select("#chart").append("svg")
                .attr("width", width).attr("height", height)
                .attr('role', 'img')
                .attr('aria-label', 'Tidy tree visualization');

            // Create a main group for zoom/pan
            const g = svg.append("g");
            // Create links and nodes groups in correct order
            const linkGroup = g.append("g").attr("class", "links");
            const nodeGroup = g.append("g").attr("class", "nodes");

            // allow broader zoom on touch devices for easier pinch-zooming
            const zoom = d3.zoom().scaleExtent([0.3, 4]).on("zoom", (event) => {
                g.attr("transform", event.transform);
                updatePopupHelpPosition();
            });
            svg.call(zoom);

            // ensure chart height computed initially (now that svg exists)
            computeChartHeight();

            // Handle resizing: keep SVG sized to container and re-layout tree
            function resizeHandler() {
                // recompute chart height using topbar
                computeChartHeight();
                updateControlsVisibility();
                // Recompute layout origin so root remains roughly centered vertically
                if (root) {
                    root.x0 = height / 2;
                }
                update(root);
                // Maintain a sensible transform after resize
                const currentTransform = d3.zoomTransform(svg.node());
                // if transform is identity, re-center root
                if (currentTransform.k === 1 && Math.abs(currentTransform.x) < 1 && Math.abs(currentTransform.y) < 1) {
                    svg.call(zoom.transform, d3.zoomIdentity.translate(Math.min(220, width * 0.25), height / 2).scale(1));
                }
            }

            // Debounced resize
            let resizeTimer = null;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimer);
                resizeTimer = setTimeout(resizeHandler, 150);
            });

            // ensure chart height computed initially
            computeChartHeight();


            const tooltip = d3.select("body").append("div")
                .attr("class", "tooltip").style("opacity", 0);
            // Add a separate popup help element
            const popupHelp = d3.select("body").append("div")
                .attr("class", "popup-help").style("opacity", 0).style("position", "fixed");

            // Helper to clamp a fixed-position element to the viewport (keeps a small margin)
            function clampToViewport(sel, desiredLeft, desiredTop) {
                const el = sel.node();
                const margin = 8;
                if (!el) return { left: desiredLeft, top: desiredTop };
                // Temporarily set to desired position so getBoundingClientRect reports correct size
                sel.style('left', desiredLeft + 'px').style('top', desiredTop + 'px');
                const rect = el.getBoundingClientRect();
                const maxTop = Math.max(margin, window.innerHeight - rect.height - margin);
                // use chart width for horizontal clamping so popups align with the svg area
                const maxLeft = Math.max(margin, width - rect.width - margin);
                const left = Math.min(Math.max(desiredLeft, margin), maxLeft);
                const top = Math.min(Math.max(desiredTop, margin), maxTop);
                sel.style('left', left + 'px').style('top', top + 'px');
                return { left, top };
            }

            // Minimal robust popup help tracking
            let popupHelpNode = null;

            function updatePopupHelpPosition() {
                if (!popupHelpNode) return;
                // Use tree layout coordinates
                let x = popupHelpNode.x;
                let y = popupHelpNode.y;
                // Get current transform
                const transform = d3.zoomTransform(svg.node());
                // Apply D3 transform to node coordinates
                const transformed = transform.apply([y, x]);
                // Convert SVG coordinates to screen coordinates
                const point = svg.node().createSVGPoint();
                point.x = transformed[0];
                point.y = transformed[1];
                const ctm = svg.node().getScreenCTM();
                if (ctm) {
                    const screenPoint = point.matrixTransform(ctm);
                    // Calculate desired position with offset
                    const desiredLeft = screenPoint.x + 24;
                    const desiredTop = screenPoint.y + 24;
                    // Clamp to viewport so popup doesn't go below the bottom (or off the right)
                    const popupEl = popupHelp.node();
                    if (popupEl) {
                        const rect = popupEl.getBoundingClientRect();
                        const margin = 8;
                        const maxTop = Math.max(margin, window.innerHeight - rect.height - margin);
                        // align popup clamping with the SVG/chart width rather than full window
                        const maxLeft = Math.max(margin, width - rect.width - margin);
                        const left = Math.min(Math.max(desiredLeft, margin), maxLeft);
                        const top = Math.min(Math.max(desiredTop, margin), maxTop);
                        popupHelp.style("left", left + "px").style("top", top + "px");
                    } else {
                        popupHelp.style("left", (screenPoint.x + 24) + "px").style("top", (screenPoint.y + 24) + "px");
                    }
                }
            }

            // Ensure the rendered tree fits horizontally in the viewport by nudging the zoom transform
            // so the left/right visible node extents don't fall outside the screen on small devices.
        function ensureTreeVisible(margin = 24) {
                if (typeof suppressAutoEnsure !== 'undefined' && suppressAutoEnsure) return;
                try {
            // on narrow phones give a larger margin to avoid nodes being too close to the edge
            const small = window.matchMedia && window.matchMedia('(max-width: 600px)').matches;
            if (small) margin = Math.max(margin, 48);
                    const nodes = root.descendants().filter(d => !(d.x == null || d.y == null));
                    if (!nodes || nodes.length === 0) return;
                    const transform = d3.zoomTransform(svg.node());
                    // compute screen X (horizontal) for each node (svg coords are [y,x])
                    let minScreenX = Infinity, maxScreenX = -Infinity;
                    nodes.forEach(d => {
                        const pt = transform.apply([d.y, d.x]);
                        const sx = pt[0];
                        if (sx < minScreenX) minScreenX = sx;
                        if (sx > maxScreenX) maxScreenX = sx;
                    });
                    const leftLimit = margin;
                    // use the chart width (container) as the horizontal limit
                    const rightLimit = width - margin;
                    let dx = 0;
                    if (maxScreenX > rightLimit) {
                        dx = rightLimit - maxScreenX; // negative value moves tree left
                    } else if (minScreenX < leftLimit) {
                        dx = leftLimit - minScreenX; // positive moves tree right
                    }
                    if (dx !== 0) {
                        const newTransform = d3.zoomIdentity.translate(transform.x + dx, transform.y).scale(transform.k);
                        svg.transition().duration(300).call(zoom.transform, newTransform);
                    }
                } catch (e) {
                    // non-fatal
                    console.warn('ensureTreeVisible failed', e);
                }
            }

            // Collapsible tree helpers
            function collapse(d) {
                if (d.children) { d._children = d.children; d._children.forEach(collapse); d.children = null; }
            }
            function expand(d) {
                if (d._children) { d.children = d._children; d._children = null; }
            }

            const root = d3.hierarchy(data);
            // When true, prevent ensureTreeVisible from nudging the view while we perform
            // a deliberate centering animation (avoids competing transitions).
            let suppressAutoEnsure = false;
            root.x0 = height / 2;
            root.y0 = 0;
            // Collapse the 'Death', 'Burial', and 'Resurrection' nodes themselves so only those are visible under the root
            if (root.children) {
                root.children.forEach(child => {
                    if (["Death", "Burial", "Resurrection"].includes(child.data.name)) {
                        collapse(child);
                    } else {
                        collapse(child);
                    }
                });
            }

            // Default to cluster layout
            let treeLayout = d3.cluster();
            // initial nodeSize will be set from the UI controls below so spacing matches the visible defaults

            // Controls
            const nodeSizeYInput = document.getElementById('nodesizeY');
            const nodeSizeXInput = document.getElementById('nodesizeX');
            nodeSizeYInput.addEventListener('input', updateNodeSize);
            nodeSizeXInput.addEventListener('input', updateNodeSize);
            function updateNodeSize() {
                const y = +nodeSizeYInput.value;
                const x = +nodeSizeXInput.value;
                treeLayout.nodeSize([y, x]);
                update(root);
            }
            // const tree = d3.tree().nodeSize([120, 200]); // vertical spacing, horizontal spacing

            const nodeSizeInput = document.getElementById('nodesize');
            nodeSizeInput.addEventListener('input', () => {
                const v = +nodeSizeInput.value;
                treeLayout.nodeSize([v, v + 80]);
                update(root);
            });
            const wrapToggle = document.getElementById('wrap');

            // Initialize layout sizing to the denser defaults used previously
            // Detect iOS (covers Mobile Safari and Chrome on iOS) and treat it as a small/tall mobile
            // so we increase vertical spacing there as well. This avoids relying solely on
            // the computed chart height which can differ across browsers on iOS.
            const isIOS = (() => {
                const ua = navigator.userAgent || '';
                const platform = navigator.platform || '';
                // iPhone/iPad/iPod in UA, or iPad on modern iPadOS which reports MacIntel but has touch
                return /iPad|iPhone|iPod/.test(ua) || (platform === 'MacIntel' && navigator.maxTouchPoints > 1);
            })();
            // But increase vertical spacing on narrow/tall mobile screens (or iOS browsers)
            const initialVertical = (isIOS || (height && height < 700)) ? 28 : 17; // vertical spacing (larger on phones)
            // Slightly reduce horizontal spacing on narrow screens so the tree fits
            const initialHorizontal = (width && width < 480) ? 160 : 200; // horizontal spacing
            // Sync hidden UI controls to reflect these defaults so toggling preserves expected spacing
            if (nodeSizeYInput) nodeSizeYInput.value = initialVertical;
            if (nodeSizeXInput) nodeSizeXInput.value = initialHorizontal;
            if (nodeSizeInput) nodeSizeInput.value = initialVertical;
            treeLayout.nodeSize([initialVertical, initialHorizontal]);

            // Cluster toggle: set up once (not inside update) so it isn't reset on every render
            const clusterToggle = document.getElementById('clusterToggle');
            // Default to cluster layout (matches initial treeLayout)
            clusterToggle.checked = true;
            clusterToggle.addEventListener('change', function () {
                if (clusterToggle.checked) {
                    treeLayout = d3.cluster();
                } else {
                    treeLayout = d3.tree();
                }
                // Keep node size settings
                const y = +nodeSizeYInput.value;
                const x = +nodeSizeXInput.value;
                treeLayout.nodeSize([y, x]);
                update(root);
            });

            // Word wrap helper
            function wrapText(selection, width = 160) {
                selection.each(function (d) {
                    const text = d3.select(this);
                    const words = (text.text() || "").split(/\s+/).reverse();
                    let line = [], lineNumber = 0;
                    // Set x based on node type
                    const x = (d.children || d._children) ? -10 : 10;
                    let tspan = text.text(null).append("tspan").attr("x", x).attr("dy", "0em");
                    let word, lineHeight = 1.1;
                    while (word = words.pop()) {
                        line.push(word);
                        tspan.text(line.join(" "));
                        if (tspan.node().getComputedTextLength() > width) {
                            line.pop();
                            tspan.text(line.join(" "));
                            line = [word];
                            tspan = text.append("tspan")
                                .attr("x", x)
                                .attr("dy", ++lineNumber * lineHeight + "em")
                                .text(word);
                        }
                    }
                });
            }

            // Color per node (inherit from ancestors if not set)
            function nodeColor(d) {
                let x = d;
                while (x) {
                    if (x.data && x.data.color) return x.data.color;
                    x = x.parent;
                }
                return "#6c6c6c";
            }

            function update(source) {
                treeLayout(root);
                const nodes = root.descendants();
                const links = root.links();
                // (cluster toggle is wired once at top-level to avoid being reset on each update)

                // nodes.forEach(d => d.y = d.depth * 180); // horizontal spacing per depth

                // LINKS (drawn first, behind nodes)
                const link = linkGroup.selectAll("path.link").data(links, d => d.target.id || (d.target.id = crypto.randomUUID()));
                link.enter().append("path")
                    .attr("class", "link")
                    .attr("d", d3.linkHorizontal().x(d => source.y0).y(d => source.x0))
                    .merge(link)
                    .transition().duration(350)
                    .attr("d", d3.linkHorizontal().x(d => d.y).y(d => d.x));
                link.exit().transition().duration(250)
                    .attr("d", d3.linkHorizontal().x(d => source.y).y(d => source.x))
                    .remove();

                // NODES (drawn above links)
                const node = nodeGroup.selectAll("g.node").data(nodes, d => d.id || (d.id = crypto.randomUUID()));

                // Shared activation logic for nodes (click or tap)
                function handleNodeActivate(event, d) {
                    const isSmall = window.matchMedia && window.matchMedia('(max-width: 600px)').matches;
                    try {
                        // mark only the activated node's group with data-selected="true"
                        d3.selectAll('g.node').attr('data-selected', 'false');
                        d3.selectAll('g.node').filter(n => n === d).attr('data-selected', 'true');
                    } catch (e) { /* ignore if d3 not present */ }
                    if (!d.children && !d._children && d.data.source && d.data.source.url) {
                        let html = `<strong>${d.data.name}</strong>`;
                        if (d.data.date) html += `<div style='margin-top:4px; font-weight:bold;'>${d.data.date}</div>`;
                        if (d.data.details) html += `<div style='margin-top:6px;'>${d.data.details}</div>`;
                        html += `<div style='margin-top:10px;'><a href='${d.data.source.url}' target='_blank' style='color:var(--accent-dark);text-decoration:underline'>${d.data.source.title || "View Source"}</a></div>`;
                        if (isSmall) {
                            openBottomSheet(html, d);
                        } else {
                            popupHelp.html(html)
                                .style("opacity", 1)
                                .style("pointer-events", "auto");
                            popupHelpNode = d;
                            updatePopupHelpPosition();
                            setTimeout(() => {
                                document.addEventListener('pointerdown', popupHelpOutsideClickHandler, true);
                            }, 0);
                        }
                    } else {
                        // Determine whether this interaction will expand or collapse the node
                        const willExpand = !d.children && d._children;
                        if (willExpand) {
                            // Only expand the clicked node's immediate children.
                            // Previously we expanded all descendants via expandAllRecursive;
                            // remove that so a click only toggles the immediate level.
                            expand(d);
                        } else {
                            collapse(d);
                        }

                        // Perform the update and then, on small screens, center the newly-exposed
                        // deepest-level nodes (after an expand) or center on the parent (after a collapse).
                        // Suppress automatic ensureTreeVisible nudges while we do our manual centering.
                        suppressAutoEnsure = true;
                        update(d);

                        // Always run centering code after the update/transition. On small screens we
                        // preserve the existing full-centering behavior. On larger screens we apply
                        // a softer, clamped nudge so the viewport moves toward the selected area
                        // without fully recentring (less jarring on desktop).
                        const isSmall = window.matchMedia && window.matchMedia('(max-width: 600px)').matches;
                        setTimeout(() => {
                            try {
                                const transform = d3.zoomTransform(svg.node());
                                if (isSmall) {
                                    // original mobile behavior: center fully on the target
                                    if (willExpand) {
                                        const desc = d.descendants();
                                        if (!desc || desc.length === 0) { suppressAutoEnsure = false; return; }
                                        let maxDepth = -Infinity;
                                        desc.forEach(n => { if (n.depth > maxDepth) maxDepth = n.depth; });
                                        const deepest = desc.filter(n => n.depth === maxDepth);
                                        if (!deepest || deepest.length === 0) { suppressAutoEnsure = false; return; }
                                        const avgX = d3.mean(deepest, n => n.x);
                                        const avgY = d3.mean(deepest, n => n.y);
                                        const screen = transform.apply([avgY, avgX]);
                                        // use chart width for horizontal centering
                                        const dx = (width / 2) - screen[0];
                                        const dy = (height / 2) - screen[1];
                                        const newTransform = d3.zoomIdentity.translate(transform.x + dx, transform.y + dy).scale(transform.k);
                                        svg.interrupt();
                                        svg.transition().duration(360).call(zoom.transform, newTransform)
                                            .on('end interrupt', () => { suppressAutoEnsure = false; });
                                    } else {
                                        const avgX = d.x;
                                        const avgY = d.y;
                                        const screen = transform.apply([avgY, avgX]);
                                        // use chart width for horizontal centering
                                        const dx = (width / 2) - screen[0];
                                        const dy = (height / 2) - screen[1];
                                        const newTransform = d3.zoomIdentity.translate(transform.x + dx, transform.y + dy).scale(transform.k);
                                        svg.interrupt();
                                        svg.transition().duration(360).call(zoom.transform, newTransform)
                                            .on('end interrupt', () => { suppressAutoEnsure = false; });
                                    }
                                } else {
                                    // Desktop/large-screen behavior: apply a fraction of the computed delta
                                    // and clamp to reasonable maximums so motion is subtle.
                                    const duration = 260;
                                        const fraction = 1.0; // apply full computed shift on desktop (match mobile)
                                    if (willExpand) {
                                        const desc = d.descendants();
                                        if (!desc || desc.length === 0) { suppressAutoEnsure = false; return; }
                                        let maxDepth = -Infinity;
                                        desc.forEach(n => { if (n.depth > maxDepth) maxDepth = n.depth; });
                                        const deepest = desc.filter(n => n.depth === maxDepth);
                                        if (!deepest || deepest.length === 0) { suppressAutoEnsure = false; return; }
                                        const avgX = d3.mean(deepest, n => n.x);
                                        const avgY = d3.mean(deepest, n => n.y);
                                        const screen = transform.apply([avgY, avgX]);
                                        // use the computed chart `width` (container) rather than the full window
                                        let dx = ((width / 2) - screen[0]) * fraction;
                                        let dy = ((height / 2) - screen[1]) * fraction;
                                        const maxMoveX = width * 0.35;
                                        const maxMoveY = height * 0.35;
                                        dx = Math.max(-maxMoveX, Math.min(maxMoveX, dx));
                                        dy = Math.max(-maxMoveY, Math.min(maxMoveY, dy));
                                        const newTransform = d3.zoomIdentity.translate(transform.x + dx, transform.y + dy).scale(transform.k);
                                        svg.interrupt();
                                        svg.transition().duration(duration).call(zoom.transform, newTransform)
                                            .on('end interrupt', () => { suppressAutoEnsure = false; });
                                    } else {
                                        const avgX = d.x;
                                        const avgY = d.y;
                                        const screen = transform.apply([avgY, avgX]);
                                        // use chart `width` for horizontal centering
                                        let dx = ((width / 2) - screen[0]) * fraction;
                                        let dy = ((height / 2) - screen[1]) * fraction;
                                        const maxMoveX = width * 0.35;
                                        const maxMoveY = height * 0.35;
                                        dx = Math.max(-maxMoveX, Math.min(maxMoveX, dx));
                                        dy = Math.max(-maxMoveY, Math.min(maxMoveY, dy));
                                        const newTransform = d3.zoomIdentity.translate(transform.x + dx, transform.y + dy).scale(transform.k);
                                        svg.interrupt();
                                        svg.transition().duration(duration).call(zoom.transform, newTransform)
                                            .on('end interrupt', () => { suppressAutoEnsure = false; });
                                    }
                                }
                            } catch (e) {
                                console.warn('centering after expand/collapse failed', e);
                                suppressAutoEnsure = false;
                            }
                        }, isSmall ? 380 : 220);

                        popupHelp.style("opacity", 0)
                            .style("pointer-events", "none");
                        document.removeEventListener('pointerdown', popupHelpOutsideClickHandler, true);
                        popupHelpNode = null;
                    }
                }

                // tap detection: small movement + short time -> treat as tap
                const pointerStarts = new Map();

                const nodeEnter = node.enter().append("g")
                    .attr("class", d => (!d.children && !d._children && d.data.source && d.data.source.url) ? "node clickable" : "node")
                    .attr("transform", d => `translate(${source.y0},${source.x0})`)
                    .on('pointerdown', (event, d) => {
                        try { if (event.isPrimary) pointerStarts.set(event.pointerId, { x: event.clientX, y: event.clientY, t: Date.now() }); } catch (e) { /* ignore */ }
                    })
                    .on('pointerup', (event, d) => {
                        const s = pointerStarts.get(event.pointerId);
                        if (s) {
                            const dx = event.clientX - s.x;
                            const dy = event.clientY - s.y;
                            const dist = Math.hypot(dx, dy);
                            const dt = Date.now() - s.t;
                            pointerStarts.delete(event.pointerId);
                            if (dist < 8 && dt < 400) {
                                // mark tapped to avoid duplicate click handling
                                d._handledTap = Date.now();
                                handleNodeActivate(event, d);
                                event.preventDefault();
                                return;
                            }
                        }
                    })
                    .on('pointercancel', (event) => { pointerStarts.delete(event.pointerId); })
                    .on('click', (event, d) => {
                        // avoid duplicate when pointerup already handled the tap
                        if (d._handledTap && (Date.now() - d._handledTap) < 600) { d._handledTap = 0; return; }
                        handleNodeActivate(event, d);
                    })
                    .on("pointerenter", (event, d) => {
                        // show subtitle on hover/enter (pointer-aware)
                        const txt = d.data.subtitle || "";
                        if (!txt) return;
                        const isSmall = window.matchMedia && window.matchMedia('(max-width: 600px)').matches;
                        if (isSmall) {
                            // On small/touch devices the tooltip often appears under the finger.
                            // Use the bottom sheet to surface subtitle info instead.
                            const html = `<div style="padding:4px 2px;">${txt}</div>`;
                            openBottomSheet(html, d);
                            return;
                        }
                        tooltip.html(txt)
                            .style("opacity", 1)
                            .style("pointer-events", "none");
                        clampToViewport(tooltip, event.clientX + 24, event.clientY + 24);
                    })
                    .on("pointermove", (event) => {
                        const isSmall = window.matchMedia && window.matchMedia('(max-width: 600px)').matches;
                        if (!isSmall) clampToViewport(tooltip, event.clientX + 24, event.clientY + 24);
                    })
                    .on("pointerleave", () => {
                        tooltip.style("opacity", 0);
                    });
                // Remove mouseleave handler so tooltip doesn't disappear immediately

                // Helper to hide popup help only when clicking outside
                function popupHelpOutsideClickHandler(e) {
                    const popupEl = popupHelp.node();
                    if (popupHelp.style("opacity") === "1" && (!popupEl || (e.target !== popupEl && !popupEl.contains(e.target)))) {
                        popupHelp.style("opacity", 0)
                            .style("pointer-events", "none");
                        document.removeEventListener('pointerdown', popupHelpOutsideClickHandler, true);
                        // Quickfix: dispatch mouseleave to node under popup
                        if (popupHelpNode) {
                            // Find the corresponding SVG node group
                            const nodeGroup = d3.selectAll('g.node').filter(d => d === popupHelpNode);
                            nodeGroup.select('text').each(function () {
                                const evt = new MouseEvent('mouseleave', { bubbles: true });
                                this.dispatchEvent(evt);
                            });
                        }
                        popupHelpNode = null;
                    }
                }

                // Adjust node radius for small touch screens to improve tap targets
                const isSmall = window.matchMedia && window.matchMedia('(max-width: 600px)').matches;
                const targetRadius = isSmall ? 8 : 6;

                nodeEnter.append("circle")
                    .attr("r", 1e-6)
                    .attr("fill", d => (d._children ? nodeColor(d) : "#fff"))
                    .attr("stroke", d => nodeColor(d));

                const labels = nodeEnter.append("text")
                    .attr("dy", "0em")
                    .attr("x", d => (d.children || d._children) ? -10 : 10)
                    .attr("text-anchor", d => (d.children || d._children) ? "end" : "start")
                    .html(d => d.data.link
                        ? `<a href="${d.data.link}" target="_blank" style="fill:blue;text-decoration:underline">${d.data.name}</a>`
                        : d.data.name);

                function applyLabelWrapping() {
                    g.selectAll("g.node text").each(function (d) {
                        const text = d3.select(this);
                        text.text(d.data.name);
                        if (wrapToggle.checked) wrapText(text, 160);
                    });
                }
                applyLabelWrapping();
                wrapToggle.onchange = applyLabelWrapping;

                // UPDATE + TRANSITIONS
                const nodeUpdate = nodeEnter.merge(node);
                nodeUpdate.transition().duration(350)
                    .attr("transform", d => `translate(${d.y},${d.x})`)
                    .on("end", () => { updatePopupHelpPosition(); });
                nodeUpdate.select("circle").transition().duration(350)
                    .attr("r", targetRadius)
                    .attr("fill", d => (d._children ? nodeColor(d) : "#fff"))
                    .attr("stroke", d => nodeColor(d));
                nodeUpdate.select("text").transition().duration(350)
                    .attr("x", d => (d.children || d._children) ? -10 : 10)
                    .attr("text-anchor", d => (d.children || d._children) ? "end" : "start");

                const nodeExit = node.exit().transition().duration(250)
                    .attr("transform", d => `translate(${source.y},${source.x})`)
                    .remove();
                nodeExit.select("circle").attr("r", 1e-6);

                // Stash positions for smooth transitions next time
                nodes.forEach(d => { d.x0 = d.x; d.y0 = d.y; });
                // Make sure the tree fits the viewport (esp. on narrow phones where right nodes can be off-screen)
                ensureTreeVisible();
            }

            update(root);

            // Center root nicely
            // Shift right so root node is visible. Use the same centering helpers that
            // programmatic actions (like Collapse All / Expand All) use so desktop
            // initial centering matches later behavior.
            const smallScreen = window.matchMedia && window.matchMedia('(max-width: 600px)').matches;
            const initialTranslateX = smallScreen ? Math.min(120, Math.max(40, width * 0.12)) : 220;
            // Apply a sensible starting transform, then run the smoother centering
            svg.call(zoom.transform, d3.zoomIdentity.translate(initialTranslateX, height / 2).scale(1));
            // After layout settles, run centering that focuses on the deepest visible nodes
            setTimeout(() => {
                try {
                    if (smallScreen) {
                        try { centerAfterUpdate(root); } catch (e) { /* ignore */ }
                    } else {
                        try { centerSmooth(root); } catch (e) { /* ignore */ }
                    }
                } catch (e) { /* non-fatal */ }
                // Ensure nodes fit the viewport after centering
                ensureTreeVisible();
            }, 140);

            // Collapse or expand all nodes
            function collapseAll(d) {
                if (d.children) {
                    d.children.forEach(collapseAll);
                    collapse(d);
                }
            }
            function expandAll(d) {
                if (d._children) {
                    expand(d);
                    d.children.forEach(expandAll);
                } else if (d.children) {
                    d.children.forEach(expandAll);
                }
            }

            // Centering helper used after programmatic updates (buttons/state changes)
            // target can be a single node or an array of nodes. If null, center on root.
            const debugCentering = false; // set true to enable console.logs for centering/debug
            function centerAfterUpdate(target, opts = {}) {
                try {
                    const isSmall = window.matchMedia && window.matchMedia('(max-width: 600px)').matches;
                    const transform = d3.zoomTransform(svg.node());
                    // Choose nodes to center on
                    let nodes = null;
                    if (!target) {
                        nodes = [root];
                    } else if (Array.isArray(target)) {
                        nodes = target;
                    } else {
                        // single node: if it has visible descendants prefer the deepest ones
                        const desc = (target && typeof target.descendants === 'function') ? target.descendants() : null;
                        if (desc && desc.length > 0) {
                            let maxDepth = -Infinity;
                            desc.forEach(n => { if (n.depth > maxDepth) maxDepth = n.depth; });
                            const deepest = desc.filter(n => n.depth === maxDepth);
                            nodes = (deepest && deepest.length > 0) ? deepest : [target];
                        } else {
                            nodes = [target];
                        }
                    }

                    // compute average coordinates in layout space
                    const avgX = d3.mean(nodes, n => n.x);
                    const avgY = d3.mean(nodes, n => n.y);

                    if (isSmall) {
                        // full-centering behavior (preserve original mobile UX)
                        const screen = transform.apply([avgY, avgX]);
                        if (debugCentering) console.log('centerAfterUpdate mobile avg', { avgX, avgY, screen });
                        // use chart width for horizontal centering
                        const dx = (width / 2) - screen[0];
                        const dy = (height / 2) - screen[1];
                        const newTransform = d3.zoomIdentity.translate(transform.x + dx, transform.y + dy).scale(transform.k);
                        suppressAutoEnsure = true;
                        svg.interrupt();
                        svg.transition().duration(360).call(zoom.transform, newTransform)
                            .on('end interrupt', () => { suppressAutoEnsure = false; });
                    } else {
                        // gentle, clamped nudge on larger screens
                        if (debugCentering) console.log('centerAfterUpdate desktop avg', { avgX, avgY });
                        const fraction = (opts.fraction != null) ? opts.fraction : 0.45;
                        const duration = (opts.duration != null) ? opts.duration : 260;
                        const screen = transform.apply([avgY, avgX]);
                        // use chart width for horizontal centering
                        let dx = ((width / 2) - screen[0]) * fraction;
                        let dy = ((height / 2) - screen[1]) * fraction;
                        const maxMoveX = width * 0.35;
                        const maxMoveY = height * 0.35;
                        dx = Math.max(-maxMoveX, Math.min(maxMoveX, dx));
                        dy = Math.max(-maxMoveY, Math.min(maxMoveY, dy));
                        const newTransform = d3.zoomIdentity.translate(transform.x + dx, transform.y + dy).scale(transform.k);
                        if (debugCentering) console.log('centerAfterUpdate transform', { dx, dy, newTransform });
                        suppressAutoEnsure = true;
                        svg.interrupt();
                        svg.transition().duration(duration).call(zoom.transform, newTransform)
                            .on('end interrupt', () => { suppressAutoEnsure = false; });
                    }
                } catch (e) {
                    console.warn('centerAfterUpdate failed', e);
                    suppressAutoEnsure = false;
                }
            }

            // Immediate centering (no animation) used for desktop programmatic actions
            function centerImmediate(target) {
                try {
                    const transform = d3.zoomTransform(svg.node());
                    // select nodes to center on (reuse logic from centerAfterUpdate)
                    let nodes = null;
                    if (!target) nodes = [root];
                    else if (Array.isArray(target)) nodes = target;
                    else {
                        const desc = (target && typeof target.descendants === 'function') ? target.descendants() : null;
                        if (desc && desc.length > 0) {
                            let maxDepth = -Infinity;
                            desc.forEach(n => { if (n.depth > maxDepth) maxDepth = n.depth; });
                            const deepest = desc.filter(n => n.depth === maxDepth);
                            nodes = (deepest && deepest.length > 0) ? deepest : [target];
                        } else {
                            nodes = [target];
                        }
                    }
                    const avgX = d3.mean(nodes, n => n.x);
                    const avgY = d3.mean(nodes, n => n.y);
                    // compute desired dx/dy to center on avg
                    const screen = transform.apply([avgY, avgX]);
                    // use chart width for horizontal centering
                    const dx = (width / 2) - screen[0];
                    const dy = (height / 2) - screen[1];
                    const newTransform = d3.zoomIdentity.translate(transform.x + dx, transform.y + dy).scale(transform.k);
                    // apply immediately
                    suppressAutoEnsure = true;
                    svg.interrupt();
                    svg.call(zoom.transform, newTransform);
                    suppressAutoEnsure = false;
                } catch (e) { console.warn('centerImmediate failed', e); suppressAutoEnsure = false; }
            }

            // Smooth centering (animated) used for desktop programmatic actions
            function centerSmooth(target, opts = {}) {
                const duration = (opts && opts.duration) ? opts.duration : 420;
                try {
                    const transform = d3.zoomTransform(svg.node());
                    // select nodes to center on (reuse logic from centerAfterUpdate)
                    let nodes = null;
                    if (!target) nodes = [root];
                    else if (Array.isArray(target)) nodes = target;
                    else {
                        const desc = (target && typeof target.descendants === 'function') ? target.descendants() : null;
                        if (desc && desc.length > 0) {
                            let maxDepth = -Infinity;
                            desc.forEach(n => { if (n.depth > maxDepth) maxDepth = n.depth; });
                            const deepest = desc.filter(n => n.depth === maxDepth);
                            nodes = (deepest && deepest.length > 0) ? deepest : [target];
                        } else {
                            nodes = [target];
                        }
                    }
                    const avgX = d3.mean(nodes, n => n.x);
                    const avgY = d3.mean(nodes, n => n.y);
                    const screen = transform.apply([avgY, avgX]);
                    // use chart width for horizontal centering
                    const dx = (width / 2) - screen[0];
                    const dy = (height / 2) - screen[1];
                    const newTransform = d3.zoomIdentity.translate(transform.x + dx, transform.y + dy).scale(transform.k);
                    suppressAutoEnsure = true;
                    svg.interrupt();
                    svg.transition().duration(duration).call(zoom.transform, newTransform)
                        .on('end interrupt', () => { suppressAutoEnsure = false; });
                } catch (e) { console.warn('centerSmooth failed', e); suppressAutoEnsure = false; }
            }

            

            document.getElementById('collapseAll').onclick = () => {
                root.children && root.children.forEach(collapseAll);
                update(root);
                // update tracked index
                currentExpansionIndex = findMatchingStateIndex();
                // center after collapse all: on small screens keep immediate/animated behavior,
                // on desktop wait briefly for layout transitions to finish then center so a
                // single click is sufficient.
                if (smallScreen) {
                    try { centerAfterUpdate(root); } catch (e) { /* ignore */ }
                } else {
                    setTimeout(() => { try { centerSmooth(root); } catch (e) { /* ignore */ } }, 380);
                }
            };
            document.getElementById('expandAll').onclick = () => {
                // Ensure we expand the entire tree even when nodes are collapsed into `_children`.
                // Call the recursive helper on the root itself instead of iterating `root.children`.
                try { expandAll(root); } catch (e) { /* ignore */ }
                update(root);
                // update tracked index
                currentExpansionIndex = findMatchingStateIndex();
                // center after expand all: on small screens keep immediate/animated behavior,
                // on desktop wait briefly for layout transitions to finish then center so a
                // single click is sufficient.
                if (smallScreen) {
                    try { centerAfterUpdate(root); } catch (e) { /* ignore */ }
                } else {
                    setTimeout(() => { try { centerSmooth(root); } catch (e) { /* ignore */ } }, 380);
                }
            };

            // State machine for one-level expand/collapse
            // We'll precompute a list of expansion "states" (sets of node keys that are expanded)
            // starting from root-only up to fully-expanded. Then collapse/expand one level
            // simply moves the current index and applies the corresponding state to the live tree.

            // Helper to get a stable key for a node: use the ancestor path (ids or names) so
            // keys are stable and unique across simulated and live hierarchies.
            function nodeKey(d) {
                // build path from root -> ... -> node using data.id if present, otherwise data.name
                try {
                    const parts = d.ancestors().reverse().map(n => (n.data && (n.data.id ?? n.data.name)) || '').filter(Boolean);
                    return parts.join('/');
                } catch (e) {
                    // fallback for nodes that don't support ancestors(): use name or id
                    return d.data?.id ?? d.data?.name ?? d.id ?? String(d);
                }
            }

            let expansionStates = []; // array of Set(nodeKey) from root-only (index 0) to fully-expanded (last)
            let currentExpansionIndex = 1; // default to first level beyond root

            // Build simulated collapse sequence from fully expanded down to root-only, then reverse it.
            function buildExpansionStatesFromData(rawData) {
                // Use a deep-cloned hierarchy so we don't touch the live `root`
                const simRoot = d3.hierarchy(JSON.parse(JSON.stringify(rawData)));

                function getExpandedKeys(n) {
                    return new Set(n.descendants().filter(d => d.children && d.children.length > 0).map(nodeKey));
                }

                const states = [];
                // Start with fully expanded state
                states.push(getExpandedKeys(simRoot));

                // Simulate repeated "collapse one level" operations until nothing left to collapse
                while (true) {
                    const candidates = simRoot.descendants().filter(d => d.children && d.children.length > 0);
                    if (candidates.length === 0) break;
                    const toCollapse = candidates.filter(d => d.children.every(c => !c.children || c.children.length === 0));
                    if (toCollapse.length === 0) break;
                    toCollapse.forEach(d => { d._children = d.children; d.children = null; });
                    states.push(getExpandedKeys(simRoot));
                }

                // states currently goes from fully-expanded -> ... -> root-only, reverse it
                return states.reverse();
            }

            // Apply an expansion state (set of node keys that should be expanded) to the live `root`
            function applyExpansionStateToLiveRoot(expandedSet) {
                root.descendants().forEach(d => {
                    const key = nodeKey(d);
                    if (expandedSet.has(key)) {
                        if (d._children) { d.children = d._children; d._children = null; }
                        // if it already has children do nothing
                    } else {
                        if (d.children) { d._children = d.children; d.children = null; }
                    }
                });
        // Prevent the automatic ensureTreeVisible from scheduling its own transform
        // while we intend to run a deliberate centering animation below.
        suppressAutoEnsure = true;
        update(root);
                // After a programmatic state change, softly center on the deepest visible nodes
                try {
                    const visible = root.descendants().filter(n => !(n.x == null || n.y == null));
                    if (visible && visible.length > 0) {
                        let maxDepth = -Infinity;
                        visible.forEach(n => { if (n.depth > maxDepth) maxDepth = n.depth; });
                        const deepest = visible.filter(n => n.depth === maxDepth);
                        if (debugCentering) {
                            const avgX = d3.mean(deepest, n => n.x);
                            const avgY = d3.mean(deepest, n => n.y);
                            console.log('applyExpansionStateToLiveRoot: visible', visible.length, 'deepest', deepest.length, { avgX, avgY });
                        }
                        // For programmatic 'expand one level' actions, wait for update() transitions
                        // to finish and then apply an immediate recenter on desktop to avoid
                        // requiring multiple clicks; on small screens keep the animated centering.
                        if (smallScreen) {
                            try { centerAfterUpdate(deepest, { fraction: 1.0, duration: 360 }); } catch (e) { /* ignore */ }
                        } else {
                            setTimeout(() => { try { centerSmooth(deepest); } catch (e) { /* ignore */ } }, 380);
                        }
                    }
                } catch (e) { /* non-fatal */ }
                // Defensive: ensure the suppression is cleared if centering didn't run for some reason
                setTimeout(() => { suppressAutoEnsure = false; }, 700);
            }

            // Build expansion states from the original raw data
            expansionStates = buildExpansionStatesFromData(data);

            // Determine which state the current live root matches (so we can set the current index correctly)
            function findMatchingStateIndex() {
                const liveExpanded = new Set(root.descendants().filter(d => d.children && d.children.length > 0).map(nodeKey));
                if (!expansionStates || expansionStates.length === 0) return 0;
                if (expansionStates.length === 1) return 0;

                // Choose the state with the largest intersection with liveExpanded
                let bestIndex = 0;
                let bestScore = -1;
                for (let i = 0; i < expansionStates.length; i++) {
                    const s = expansionStates[i];
                    let common = 0;
                    s.forEach(k => { if (liveExpanded.has(k)) common++; });
                    if (common > bestScore) { bestScore = common; bestIndex = i; }
                }

                // If nothing matches (bestScore === 0), prefer the first-level state if it exists
                if (bestScore === 0 && expansionStates.length > 1) return Math.min(1, expansionStates.length - 1);
                return bestIndex;
            }

            currentExpansionIndex = findMatchingStateIndex();

            // COLLAPSE ONE LEVEL
            document.getElementById('collapseOneLevel').onclick = () => {
                if (expansionStates.length === 0) return;
                currentExpansionIndex = Math.max(0, currentExpansionIndex - 1);
                applyExpansionStateToLiveRoot(expansionStates[currentExpansionIndex]);
            };


            // // Collapse only visible nodes with children whose children are all leaves or collapsed
            // document.getElementById('collapseOneLevel').onclick = () => {
            //     // Find all visible nodes with children
            //     const candidates = root.descendants().filter(d => d.children && d.children.length > 0);
            //     // Only collapse those whose children are all leaves or already collapsed
            //     candidates.forEach(d => {
            //         const allChildrenAreLeavesOrCollapsed = d.children.every(
            //             c => !c.children || c.children.length === 0
            //         );
            //         if (allChildrenAreLeavesOrCollapsed) {
            //             collapse(d);
            //         }
            //     });
            //     update(root);
            // };

            // // Expand only hidden (collapsed) nodes whose hidden children are all leaves or collapsed
            // document.getElementById('expandOneLevel').onclick = () => {
            //     // Find all nodes that are currently collapsed (have _children)
            //     // const candidates = root.descendants().filter(d => d._children && d._children.length > 0);

            //     // Only expand those whose hidden children are all leaves or already collapsed
            //     candidates.forEach(d => {
            //         const allHiddenChildrenAreLeavesOrCollapsed = d._children.every(
            //             c => !c.children || c.children.length === 0
            //         );
            //         if (allHiddenChildrenAreLeavesOrCollapsed) {
            //             expand(d);  // assumes your expand(d) does: d.children = d._children; d._children = null;
            //         }
            //     });

            //     update(root);
            // };

            document.getElementById('expandOneLevel').onclick = () => {
                if (expansionStates.length === 0) return;
                currentExpansionIndex = Math.min(expansionStates.length - 1, currentExpansionIndex + 1);
                applyExpansionStateToLiveRoot(expansionStates[currentExpansionIndex]);
            };

            // By default, only root and first-level children are expanded
            update(root);
        }

        // Place helper at top-level scope so it's available everywhere
        // Ensure expand is defined at top-level scope before expandAllRecursive
        function collapse(d) {
            if (d.children) { d._children = d.children; d._children.forEach(collapse); d.children = null; }
        }
        function expand(d) {
            if (d._children) { d.children = d._children; d._children = null; }
        }
        function expandAllRecursive(d) {
            if (d._children) {
                expand(d);
                if (d.children) d.children.forEach(expandAllRecursive);
            } else if (d.children) {
                d.children.forEach(expandAllRecursive);
            }
        }

        init();

        // Dark mode toggle
        const darkModeToggle = document.getElementById('darkModeToggle');
        darkModeToggle.checked = true;
        document.body.classList.add('dark-mode');
        darkModeToggle.addEventListener('change', function () {
            document.body.classList.toggle('dark-mode', darkModeToggle.checked);
        });
    </script>

    <!-- ESV credit: Crossway recommended short credit for using ESV text -->
    <div class="esv-credit" aria-hidden="true">
        <div>Scripture quotations are from the ESV® Bible (The Holy Bible, English Standard Version®), copyright © 2001, 2007, 2011, 2016 by Crossway. Used by permission. All rights reserved.</div>
    <div>The "Minimal Facts" approach is adapted from: Gary R. Habermas and Michael R. Licona, <em>The Case for the Resurrection of Jesus</em> (B&amp;H Academic, 2004).</div>
    </div>

</body>

</html>