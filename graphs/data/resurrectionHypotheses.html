<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Historical Hypotheses — McCullagh Criteria (Radar • Heatmap • Facts)</title>
  <style>
    :root{
      --bg:#ffffff; --ink:#1f2937; --muted:#6b7280; --line:#e5e7eb; --accent:#334155;
    }
    html,body{height:100%;}
    body{margin:0; font:14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, sans-serif; color:var(--ink); background:var(--bg);}
    #topbar{position:sticky; top:0; z-index:10; background:var(--bg); border-bottom:1px solid var(--line); padding:10px 14px; display:flex; gap:16px; align-items:center; flex-wrap:wrap}
    #topbar .group{display:flex; align-items:center; gap:10px;}
    #topbar h1{font-size:16px; margin:0 10px 0 0; font-weight:600; color:var(--accent)}
    #hypotheses{display:flex; gap:10px; flex-wrap:wrap;}
    .pill{display:inline-flex; align-items:center; gap:6px; border:1px solid var(--line); padding:6px 10px; border-radius:999px;}
    .pill input{accent-color:#111;}
    .weights{display:flex; gap:14px; flex-wrap:wrap; align-items:flex-end}
    .slider{display:flex; flex-direction:column; gap:6px; min-width:180px}
    .slider label{font-size:12px; color:var(--muted)}
    .slider input[type="range"]{width:200px}
    .viewtabs{margin-left:auto; display:flex; gap:6px}
    .viewtabs button{border:1px solid var(--line); background:#fff; padding:6px 10px; border-radius:8px; cursor:pointer}
    .viewtabs button.active{background:#111; color:#fff}

    #main{display:grid; grid-template-rows:auto auto 1fr auto; gap:10px}
    #chart{width:100%; height:calc(70vh - 0px);}
    #chart svg{display:block; width:100%; height:100%}

    #factsToggle{margin:8px 14px 0}
    #facts{height:420px; border-top:1px solid var(--line); display:none}

    .legend{display:flex; gap:12px; align-items:center; flex-wrap:wrap; padding:6px 14px}
    .legend .item{display:flex; align-items:center; gap:6px; font-size:12px;}
    .legend .sw{width:12px;height:12px;border-radius:3px;}

    .tooltip{position:fixed; pointer-events:none; background:#fff; border:1px solid var(--line); padding:8px 10px; border-radius:8px; box-shadow:0 6px 20px rgba(0,0,0,0.12); max-width:320px; font-size:12px;}
    .sr-only{position:absolute; left:-9999px}
  </style>
</head>
<body>

  <div id="topbar">
    <h1>Compare Historical Hypotheses (McCullagh)</h1>
    <div class="group" id="hypotheses"></div>

    <div class="group weights" id="weights"></div>

    <div class="group">
      <label class="pill"><input type="checkbox" id="applyWeights" checked> Apply weights to visuals</label>
      <label class="pill"><input type="checkbox" id="showValues" checked> Show numeric values</label>
    </div>

    <div class="viewtabs" role="tablist" aria-label="Primary view">
      <button data-view="radar" class="active" role="tab" aria-selected="true">Radar</button>
      <button data-view="heatmap" role="tab" aria-selected="false">Heatmap</button>
    </div>
  </div>

  <div id="main">
    <div class="legend" id="legend"></div>
    <div id="chart" aria-live="polite"></div>

    <label id="factsToggle" class="pill"><input type="checkbox" id="toggleFacts"> Show facts network</label>
    <div id="facts"></div>
  </div>

  <div id="tt" class="tooltip" style="display:none"></div>

  <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
  <script>
  // ---------------------------
  // Data scaffold (edit this)
  // ---------------------------
  const Data = {
    criteria: [
      { id:"derivation", label:"1. Derivation (implies present data)", short:"Derivation", desc:"The hypothesis + other truths implies further statements describing present observable data." },
      { id:"scope", label:"2. Explanatory scope", short:"Scope", desc:"Explains more of the accepted facts than rivals." },
      { id:"power", label:"3. Explanatory power", short:"Power", desc:"Makes the facts more probable than rivals do." },
      { id:"plausibility", label:"4. Plausibility", short:"Plausibility", desc:"Fits better with background knowledge than rivals." },
      { id:"adHoc", label:"5. Less ad hoc", short:"Less ad hoc", desc:"Requires fewer new/unsupported assumptions than rivals." },
      { id:"notDisconfirmed", label:"6. Fewer disconfirmations", short:"Fewer disconf.", desc:"Is disconfirmed by fewer accepted beliefs than rivals." },
      { id:"exceeds", label:"7. Exceeds rivals", short:"Exceeds", desc:"Significantly exceeds rivals overall on these criteria." }
    ],

    // Craig-style core facts to visualize coverage/conflict below
    facts: [
      { id:"burial", label:"Burial by Joseph of Arimathea", weight:1.0, tip:"Citations: Mark 15:42–47; 1 Cor 15:4; supporting scholarship." },
      { id:"empty", label:"Discovery of the empty tomb (by women)", weight:1.0, tip:"Citations: Mark 16; multiple attestation arguments; early polemic." },
      { id:"appearances", label:"Post-mortem appearances (individuals & groups)", weight:1.0, tip:"Citations: 1 Cor 15:3–7; Gospels; Acts; James & Paul cases." },
      { id:"origin", label:"Origin of disciples’ resurrection belief", weight:0.8, tip:"Citations: early proclamation in Jerusalem; readiness to suffer." }
    ],

    // Hypotheses (placeholder scores 0–1). Add/adjust as needed.
    hypotheses: [
      {
        id:"resurrection", label:"Resurrection", color:"#2563eb",
        scores:{ derivation:.9, scope:.95, power:.9, plausibility:.7, adHoc:.85, notDisconfirmed:.8, exceeds:.9 },
        notes:{
          derivation:"Given martyr testimony + early creed, the hypothesis implies the kinds of data we observe.",
          scope:"Explains empty tomb, appearances (multiple modes), conversions (Paul/James), early proclamation.",
          power:"These data are strongly expected if Jesus rose; unlikely under chance or disparate natural causes.",
          plausibility:"Requires theism/miracle-permission; otherwise neutral to background 1st-century context.",
          adHoc:"Adds few auxiliary assumptions beyond the central claim.",
          notDisconfirmed:"Conflicts mainly with anti-supernaturalism (a philosophical stance, not a historical datum).",
          exceeds:"Outperforms on combined criteria across rivals in typical analyses."
        },
        covers:[
          { factId:"burial", strength:.9, tip:"Burial coheres with early sources; matches expectations post-crucifixion." },
          { factId:"empty", strength:.95, tip:"Resurrection entails empty tomb; women witnesses fit embarrassment criterion." },
          { factId:"appearances", strength:.9, tip:"Multiple appearances (individual & group) fit well if bodily risen." },
          { factId:"origin", strength:.85, tip:"Explains transformation & proclamation despite risk." }
        ],
        conflicts:[]
      },
      {
        id:"hallucination", label:"Hallucination", color:"#16a34a",
        scores:{ derivation:.6, scope:.5, power:.45, plausibility:.55, adHoc:.4, notDisconfirmed:.35, exceeds:.2 },
        notes:{
          derivation:"Some appearances could yield present testimony, but requires strong auxiliary suppositions.",
          scope:"Does not explain empty tomb; struggles with James/Paul cases and group reports.",
          power:"Same-content, multi-person experiences are rare; predictive fit is weak.",
          plausibility:"Individual grief-hallucinations plausible; shared detailed events are not.",
          adHoc:"Needs multiple independent add-ons (e.g., tomb confusion, stolen body).",
          notDisconfirmed:"Conflicts with psychology (group hallucinations), and leaves burial/empty tomb data unaddressed.",
          exceeds:"Falls behind rivals on most criteria."
        },
        covers:[ { factId:"appearances", strength:.6, tip:"Explains some individual appearance claims." } ],
        conflicts:[
          { note:"Group hallucinations rarity / shared content", weight:.4 },
          { note:"No account of empty tomb", weight:.5 }
        ]
      },
      {
        id:"theft", label:"Theft/Conspiracy", color:"#f59e0b",
        scores:{ derivation:.55, scope:.55, power:.4, plausibility:.35, adHoc:.3, notDisconfirmed:.45, exceeds:.25 },
        notes:{
          derivation:"Could imply empty tomb + some testimony, but requires coordinated deceit.",
          scope:"Explains empty tomb; fails to explain sincere willingness to suffer/die for proclaimed truth.",
          power:"Predicts secrecy, not bold proclamation in Jerusalem against interests.",
          plausibility:"Low: risks high, motives unclear; conflicts with character evidence.",
          adHoc:"Requires many auxiliaries (guards bribed/asleep, perfect secrecy, no confessions).",
          notDisconfirmed:"Clashes with accepted beliefs about group behavior and incentives.",
          exceeds:"Outperformed by resurrection on scope/power."
        },
        covers:[
          { factId:"empty", strength:.75, tip:"Accounts for empty tomb if body was removed." },
          { factId:"appearances", strength:.2, tip:"Requires deception to create appearance reports." }
        ],
        conflicts:[
          { note:"No plausible motive strong enough vs. risk", weight:.35 },
          { note:"No credible confessions despite pressure", weight:.35 }
        ]
      }
    ],

    // User-adjustable weights for criteria
    weights:{ derivation:1.0, scope:1.3, power:1.2, plausibility:1.0, adHoc:1.0, notDisconfirmed:1.1, exceeds:1.4 }
  };

  // ---------------------------
  // State & helpers
  // ---------------------------
  const state = {
    view:"radar",
    selected: new Set(Data.hypotheses.map(h=>h.id)),
    weights: {...Data.weights},
    applyWeights:true,
    showValues:true
  };

  const byId = (arr)=>Object.fromEntries(arr.map(d=>[d.id,d]));
  const C = byId(Data.criteria);
  const Facts = byId(Data.facts);
  const Hy = byId(Data.hypotheses);

  const fmt = d3.format(".2f");
  const avgWeight = ()=> d3.mean(Object.values(state.weights));
  const weighted = (k, v)=> state.applyWeights ? Math.max(0, Math.min(1, v * (state.weights[k]/avgWeight()))) : v;

  function totalScore(h){
    // Weighted mean of criteria
    const wsum = d3.sum(Object.values(state.weights));
    const sum = d3.sum(Object.keys(C).map(k => (state.weights[k] * Hy[h].scores[k])));
    return sum / wsum; // 0–1
  }

  // ---------------------------
  // UI: hypotheses pills
  // ---------------------------
  const hypWrap = d3.select('#hypotheses');
  const hyp = hypWrap.selectAll('.pill').data(Data.hypotheses).join('label').attr('class','pill');
  hyp.append('input')
    .attr('type','checkbox')
    .attr('checked', true)
    .attr('aria-label', d=>`Toggle ${d.label}`)
    .on('change', (e,d)=>{ e.target.checked ? state.selected.add(d.id) : state.selected.delete(d.id); render(); });
  hyp.append('span').text(d=>d.label);

  // Legend
  const legend = d3.select('#legend');
  function renderLegend(){
    const selData = Data.hypotheses.filter(h=>state.selected.has(h.id));
    const items = legend.selectAll('.item').data(selData, d=>d.id).join(
      enter => {
        const g = enter.append('div').attr('class','item');
        g.append('span').attr('class','sw').style('background', d=>d.color);
        g.append('span').text(d=>`${d.label} — score ${fmt(totalScore(d.id))}`);
        return g;
      },
      update => update,
      exit => exit.remove()
    );
  }

  // ---------------------------
  // UI: weight sliders
  // ---------------------------
  const weightsWrap = d3.select('#weights');
  const sliders = weightsWrap.selectAll('.slider').data(Data.criteria).join('div').attr('class','slider');
  sliders.append('label').text(d=>d.label);
  sliders.append('input')
    .attr('type','range').attr('min',0.2).attr('max',2).attr('step',0.1)
    .attr('value', d=>state.weights[d.id])
    .on('input', (e,d)=>{ state.weights[d.id] = +e.target.value; render(); });

  d3.select('#applyWeights').on('change', e=>{ state.applyWeights = e.target.checked; render(); });
  d3.select('#showValues').on('change', e=>{ state.showValues = e.target.checked; render(); });

  // Tabs
  d3.selectAll('.viewtabs button').on('click', (e)=>{
    d3.selectAll('.viewtabs button').classed('active', false).attr('aria-selected', false);
    d3.select(e.currentTarget).classed('active', true).attr('aria-selected', true);
    state.view = e.currentTarget.dataset.view; render();
  });

  // Facts toggle
  d3.select('#toggleFacts').on('change', (e)=>{
    const on = e.target.checked; d3.select('#facts').style('display', on? 'block':'none'); if(on) renderFacts();
  });

  // Tooltip helpers
  const tt = d3.select('#tt');
  function showTT(html, mousePos){
    // mousePos is [x, y] relative to the SVG element that triggered the event
    // Use the correct SVG element for getBoundingClientRect
    const svgEl = (d3.event && d3.event.target && d3.event.target.ownerSVGElement) ? d3.event.target.ownerSVGElement : document.querySelector('svg');
    const svgRect = svgEl.getBoundingClientRect();
    const x = svgRect.left + mousePos[0];
    const y = svgRect.top + mousePos[1];
    tt.html(html)
      .style('left', x + 'px')
      .style('top', y + 'px')
      .style('display','block');
  }
  function hideTT(){ tt.style('display','none'); }

  // ---------------------------
  // View: Radar chart
  // ---------------------------
  function renderRadar(container){
    const pad = 36, w = container.clientWidth, h = container.clientHeight, r = Math.min(w,h)/2 - pad;
    const svg = d3.select(container).append('svg');
    const g = svg.append('g').attr('transform', `translate(${w/2},${h/2})`);

    const axes = Data.criteria.map((d,i)=>{
      const angle = (Math.PI*2 * i) / Data.criteria.length - Math.PI/2; // start at top
      return { ...d, angle, x: Math.cos(angle), y: Math.sin(angle) };
    });

    const rScale = d3.scaleLinear().domain([0,1]).range([0,r]);

    // grid circles
    const levels = d3.range(0.2, 1.01, 0.2);
    g.append('g').selectAll('circle').data(levels).join('circle')
      .attr('r', d=>rScale(d)).attr('fill','none').attr('stroke','#e5e7eb');

    // axis lines & labels
    const ax = g.append('g').selectAll('g').data(axes).join('g');
    ax.append('line')
      .attr('x1',0).attr('y1',0)
      .attr('x2', d=>d.x * r).attr('y2', d=>d.y * r)
      .attr('stroke','#cbd5e1');
    ax.append('text')
      .attr('x', d=>d.x * (r+14)).attr('y', d=>d.y * (r+14))
      .attr('text-anchor', d=> Math.abs(d.x) < 0.3 ? 'middle' : (d.x>0? 'start':'end'))
      .attr('dominant-baseline','central')
      .attr('font-size',12)
      .text(d=>d.short)
      .append('title').text(d=>d.label + " — " + d.desc);

    // selected hypotheses polygons
    const sel = Data.hypotheses.filter(h=>state.selected.has(h.id));

    function pointsFor(h){
      return axes.map(a=>{
        const v = Hy[h.id].scores[a.id];
        const vv = weighted(a.id, v);
        const rr = rScale(vv);
        return [a.x*rr, a.y*rr];
      });
    }

    const poly = g.append('g').selectAll('path').data(sel, d=>d.id).join('path')
      .attr('d', d=> d3.line().curve(d3.curveLinearClosed)(pointsFor(d)))
      .attr('fill', d=> d3.color(d.color).copy({opacity:0.15}))
      .attr('stroke', d=> d.color).attr('stroke-width',2)
      .on('mousemove', (e,d)=>{
        const scoreLines = Data.criteria.map(c=>{
          const raw = Hy[d.id].scores[c.id];
          const val = weighted(c.id, raw);
          return `<div><strong>${c.short}</strong>: ${fmt(val)} <span style="color:#6b7280">(raw ${fmt(raw)})</span></div>`;
        }).join("");
        showTT(`<div style="font-weight:600">${d.label}</div>` + scoreLines, d3.pointer(e, e.target.ownerSVGElement));
      })
      .on('mouseleave', hideTT);

    if(state.showValues){
      // vertex dots & labels
      sel.forEach(hh=>{
        const pts = pointsFor(hh);
        g.append('g').selectAll('circle').data(pts.map((p,i)=>({p,i, h:hh}))).join('circle')
          .attr('cx',d=>d.p[0]).attr('cy',d=>d.p[1]).attr('r',3)
          .attr('fill',hh.color)
          .on('mousemove',(e,d)=>{
            const c = Data.criteria[d.i];
            const raw = Hy[d.h.id].scores[c.id];
            const val = weighted(c.id, raw);
            showTT(`<div><strong>${d.h.label}</strong></div><div>${c.label}</div><div>Value: ${fmt(val)} <span style="color:#6b7280">(raw ${fmt(raw)})</span></div><div style="margin-top:4px;color:#6b7280">${Hy[d.h.id].notes[c.id]||''}</div>`, d3.pointer(e, e.target.ownerSVGElement));
          })
          .on('mouseleave', hideTT);

        if(state.showValues){
          g.append('g').selectAll('text').data(pts.map((p,i)=>({p,i, h:hh}))).join('text')
            .attr('x',d=>d.p[0]).attr('y',d=>d.p[1])
            .attr('font-size',10)
            .attr('dy','-0.35em')
            .attr('text-anchor','middle')
            .attr('fill',hh.color)
            .text(d=>fmt(weighted(Data.criteria[d.i].id, Hy[d.h.id].scores[Data.criteria[d.i].id])));
        }
      });
    }
  }

  // ---------------------------
  // View: Heatmap
  // ---------------------------
  function renderHeatmap(container){
    const pad = {t:30,r:10,b:30,l:160};
    const w = container.clientWidth, h = container.clientHeight;
    const svg = d3.select(container).append('svg');

    const hySel = Data.hypotheses.filter(h=>state.selected.has(h.id));
    const x = d3.scaleBand().domain(hySel.map(d=>d.id)).range([pad.l, w-pad.r]).padding(0.08);
    const y = d3.scaleBand().domain(Data.criteria.map(d=>d.id)).range([pad.t, h-pad.b]).padding(0.08);
    const color = d3.scaleSequential().domain([0,1]).interpolator(d3.interpolateViridis);

    // axes labels
    svg.append('g').selectAll('text').data(Data.criteria).join('text')
      .attr('x', pad.l-8).attr('y', d=> y(d.id)+y.bandwidth()/2)
      .attr('text-anchor','end').attr('dominant-baseline','middle')
      .text(d=>d.short)
      .append('title').text(d=>d.label);

    svg.append('g').selectAll('text').data(hySel).join('text')
      .attr('x', d=> x(d.id)+x.bandwidth()/2).attr('y', pad.t-10)
      .attr('text-anchor','middle')
      .text(d=>d.label);

    // cells
    const cells = svg.append('g').selectAll('rect')
      .data(Data.criteria.flatMap(c=>hySel.map(h=>({c,h}))))
      .join('rect')
      .attr('x', d=>x(d.h.id)).attr('y', d=>y(d.c.id))
      .attr('width', x.bandwidth()).attr('height', y.bandwidth())
      .attr('rx',4)
      .attr('fill', d=> color( weighted(d.c.id, Hy[d.h.id].scores[d.c.id]) ))
      .on('mousemove', (e,d)=>{
        const raw = Hy[d.h.id].scores[d.c.id];
        const val = weighted(d.c.id, raw);
        showTT(`<div style="font-weight:600">${d.h.label}</div><div>${C[d.c.id].label}</div><div>Value: ${fmt(val)} <span style='color:#6b7280'>(raw ${fmt(raw)})</span></div><div style='margin-top:4px;color:#6b7280'>${Hy[d.h.id].notes[d.c.id]||''}</div>`, d3.pointer(e, e.target.ownerSVGElement));
      })
      .on('mouseleave', hideTT);
  }

  // ---------------------------
  // Facts network (bipartite force)
  // ---------------------------
  function renderFacts(){
    const el = document.getElementById('facts');
    const w = el.clientWidth || el.getBoundingClientRect().width; const h = el.clientHeight || 420;
    d3.select(el).selectAll('*').remove();
    const svg = d3.select(el).append('svg').attr('width','100%').attr('height','100%');

    const hySel = Data.hypotheses.filter(h=>state.selected.has(h.id));

    // Distribute fact nodes with even greater vertical offset
    const factNodes = Data.facts.map((f,i)=>({type:'fact', id:f.id, label:f.label, index:i, yPos: 80 + i*120}));
    const hypNodes  = hySel.map((h,i)=>({type:'hyp', id:h.id, label:h.label, color:h.color, index:i}));
    const links = [];
    const conflictNodes = [];
    hySel.forEach(h=>{
      h.covers.forEach(c=>{ links.push({source:c.factId, target:h.id, kind:'covers', strength:c.strength, tip:c.tip}); });
      (h.conflicts||[]).forEach(c=>{
        const conflictId = 'fact-conflict-'+Math.random().toString(36).slice(2);
        links.push({source:h.id, target:conflictId, kind:'conflict', note:c.note, weight:c.weight});
        conflictNodes.push({type:'conflict', id:conflictId, label:'Conflict', note:c.note});
      });
    });
    const nodes = [...factNodes, ...hypNodes, ...conflictNodes];

    const sim = d3.forceSimulation(nodes)
      .force('charge', d3.forceManyBody().strength(d=> d.type==='fact' ? -320 : -180))
      .force('center', d3.forceCenter((w)/2, h/2))
      .force('x', d3.forceX(d=> d.type==='fact' ? (w*0.25) : (w*0.75)).strength(0.22))
      .force('y', d3.forceY(d=> {
        // Use explicit yPos for facts, spread others as before
        if (d.type === 'fact') return d.yPos;
        if (d.type === 'hyp') return h*0.5 + d.index*60;
        if (d.type === 'conflict') return h*0.7 + d.index*50;
        return h/2;
  }).strength(0.85))
      .force('link', d3.forceLink(links).id(d=>d.id).distance(l=> l.kind==='covers'? 220: 160).strength(0.22));

    const link = svg.append('g').attr('stroke','#cbd5e1').attr('stroke-width',1.5)
      .selectAll('line').data(links).join('line')
      .attr('stroke-dasharray', d=> d.kind==='conflict' ? '4,4' : null)
      .on('mousemove', (e,d)=>{
        if(d.kind==='covers') showTT(`<div><strong>Explains:</strong> ${(Facts[d.source]?.label)||''} → ${(Hy[d.target]?.label)||''}</div><div>Strength: ${fmt(d.strength)}</div><div style='color:#6b7280'>${d.tip||''}</div>`, d3.pointer(e));
        else showTT(`<div><strong>Conflict note</strong></div><div>${d.note||''}</div><div>Weight: ${fmt(d.weight||0)}</div>`, d3.pointer(e));
      })
      .on('mouseleave', hideTT);

    const node = svg.append('g').selectAll('g').data(nodes).join('g').call(drag(sim));

    node.append('circle')
      .attr('r', d=> d.type==='fact' ? 10 : (d.type==='conflict' ? 9 : 8))
      .attr('fill', d=> d.type==='hyp' ? (d.color||'#111') : (d.type==='conflict' ? '#f87171' : '#0ea5e9'))
      .attr('stroke', d=> d.type==='conflict' ? '#b91c1c' : '#111')
      .attr('stroke-width', d=> d.type==='conflict' ? 2 : 0.6);

    // Add labels to all nodes, with conflict nodes showing their note
    node.append('text')
      .attr('x', 14)
      .attr('y', 4)
      .attr('font-size', '15px')
      .attr('fill', d=> d.type==='conflict' ? '#b91c1c' : '#222')
      .text(d=> d.type === 'conflict' ? (d.note || 'Conflict') : d.label);

    sim.on('tick', ()=>{
      link.attr('x1', d=>xC(d.source)).attr('y1', d=>yC(d.source)).attr('x2', d=>xC(d.target)).attr('y2', d=>yC(d.target));
      node.attr('transform', d=>`translate(${xC(d)},${yC(d)})`);
    });

    function xC(d){ return Math.max(12, Math.min((w-12), d.x||0)); }
    function yC(d){ return Math.max(12, Math.min((h-12), d.y||0)); }

    function drag(sim){
      function dragstarted(event,d){ if(!event.active) sim.alphaTarget(0.3).restart(); d.fx=d.x; d.fy=d.y; }
      function dragged(event,d){ d.fx=event.x; d.fy=event.y; }
      function dragended(event,d){ if(!event.active) sim.alphaTarget(0); d.fx=null; d.fy=null; }
      return d3.drag().on('start',dragstarted).on('drag',dragged).on('end',dragended);
    }
}
  // ---------------------------
  // Render switcher
  // ---------------------------
  function render(){
    renderLegend();
    const el = document.getElementById('chart');
    d3.select(el).selectAll('*').remove();
    if(state.view==='radar') renderRadar(el); else renderHeatmap(el);
    if(document.getElementById('toggleFacts').checked) renderFacts();
  }

  // Initial draw
  render();

  </script>
</body>
</html>
